<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OS," />










<meta name="description" content="1.    一、操作系统引论1.1.     计算机层次结构1.1.1.     软件应用软件系统软件数据库系统、汇编器、编译软件操作系统OS1.1.2.     硬件裸机1.2.     操作系统定义1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合1.3">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Lexie_W&#39;s World">
<meta property="og:description" content="1.    一、操作系统引论1.1.     计算机层次结构1.1.1.     软件应用软件系统软件数据库系统、汇编器、编译软件操作系统OS1.1.2.     硬件裸机1.2.     操作系统定义1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合1.3">
<meta property="article:published_time" content="2020-08-20T07:34:10.639Z">
<meta property="article:modified_time" content="2020-08-20T07:34:16.939Z">
<meta property="article:author" content="Lexie_W">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":"flase","scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Latte'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/20/操作系统/"/>





  <title>操作系统 | Lexie_W's World</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lexie_W's World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-varchive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




<script>

	window.onload = function(){
		var path = 'https://lexie1wxy.github.io/'; //这里要改成你博客的地址
		var localhostItem = String(window.location).split(path)[1];
		var LiNode = document.querySelectorAll('#menu > li > a')

		for(var i = 0; i< LiNode.length;i++){
			var item = String(LiNode[i].href).split(path)[1];
			if(item == localhostItem && item != undefined){
				LiNode[i].setAttribute('style','border-bottom:1px solid black');
			}
		}
	};

</script>
 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lexie_W">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lexie_W's World">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-20T15:34:10+08:00">
                2020-08-20
              </time>
            

            

           

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  19.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  68
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-一、操作系统引论"><a href="#1-一、操作系统引论" class="headerlink" title="1.    一、操作系统引论"></a>1.    一、操作系统引论</h1><h2 id="1-1-计算机层次结构"><a href="#1-1-计算机层次结构" class="headerlink" title="1.1.     计算机层次结构"></a>1.1.     计算机层次结构</h2><h3 id="1-1-1-软件"><a href="#1-1-1-软件" class="headerlink" title="1.1.1.     软件"></a>1.1.1.     软件</h3><h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><h5 id="数据库系统、汇编器、编译软件"><a href="#数据库系统、汇编器、编译软件" class="headerlink" title="数据库系统、汇编器、编译软件"></a>数据库系统、汇编器、编译软件</h5><h5 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h5><h3 id="1-1-2-硬件"><a href="#1-1-2-硬件" class="headerlink" title="1.1.2.     硬件"></a>1.1.2.     硬件</h3><h4 id="裸机"><a href="#裸机" class="headerlink" title="裸机"></a>裸机</h4><h2 id="1-2-操作系统定义"><a href="#1-2-操作系统定义" class="headerlink" title="1.2.     操作系统定义"></a>1.2.     操作系统定义</h2><h3 id="1-2-1-1、配置在计算机硬件上的第一层软件，是对硬件系统的补充"><a href="#1-2-1-1、配置在计算机硬件上的第一层软件，是对硬件系统的补充" class="headerlink" title="1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充"></a>1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充</h3><h3 id="1-2-2-2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合"><a href="#1-2-2-2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合" class="headerlink" title="1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合"></a>1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合</h3><h2 id="1-3-操作系统目标"><a href="#1-3-操作系统目标" class="headerlink" title="1.3.     操作系统目标"></a>1.3.     操作系统目标</h2><h3 id="1-3-1-1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别"><a href="#1-3-1-1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别" class="headerlink" title="1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别"></a>1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别</h3><h3 id="1-3-2-2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程"><a href="#1-3-2-2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程" class="headerlink" title="1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程"></a>1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程</h3><h3 id="1-3-3-3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作"><a href="#1-3-3-3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作" class="headerlink" title="1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作"></a>1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作</h3><h2 id="1-4-操作系统作用"><a href="#1-4-操作系统作用" class="headerlink" title="1.4.     操作系统作用"></a>1.4.     操作系统作用</h2><h3 id="1-4-1-1、用户与计算机硬件系统之间的接口"><a href="#1-4-1-1、用户与计算机硬件系统之间的接口" class="headerlink" title="1.4.1.     1、用户与计算机硬件系统之间的接口"></a>1.4.1.     1、用户与计算机硬件系统之间的接口</h3><h3 id="1-4-2-2、计算机资源的管理者"><a href="#1-4-2-2、计算机资源的管理者" class="headerlink" title="1.4.2.     2、计算机资源的管理者"></a>1.4.2.     2、计算机资源的管理者</h3><h3 id="1-4-3-3、实现对计算机资源的抽象（扩展机-虚拟机）"><a href="#1-4-3-3、实现对计算机资源的抽象（扩展机-虚拟机）" class="headerlink" title="1.4.3.     3、实现对计算机资源的抽象（扩展机/虚拟机）"></a>1.4.3.     3、实现对计算机资源的抽象（扩展机/虚拟机）</h3><h2 id="1-5-操作系统分类"><a href="#1-5-操作系统分类" class="headerlink" title="1.5.     操作系统分类"></a>1.5.     操作系统分类</h2><h3 id="1-5-1-人工操作"><a href="#1-5-1-人工操作" class="headerlink" title="1.5.1.     人工操作"></a>1.5.1.     人工操作</h3><h4 id="利用率-执行时间-（执行时间-读卡时间）"><a href="#利用率-执行时间-（执行时间-读卡时间）" class="headerlink" title="利用率=执行时间/（执行时间+读卡时间）"></a>利用率=执行时间/（执行时间+读卡时间）</h4><h3 id="1-5-2-批处理系统"><a href="#1-5-2-批处理系统" class="headerlink" title="1.5.2.     批处理系统"></a>1.5.2.     批处理系统</h3><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><h6 id="若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。"><a href="#若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。" class="headerlink" title="若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。"></a>若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。</h6><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="1、优点：改善了CPU和I-O设备的使用效率；提高了系统吞吐量"><a href="#1、优点：改善了CPU和I-O设备的使用效率；提高了系统吞吐量" class="headerlink" title="1、优点：改善了CPU和I/O设备的使用效率；提高了系统吞吐量"></a>1、优点：改善了CPU和I/O设备的使用效率；提高了系统吞吐量</h6><h6 id="2、缺点：系统资源得不到充分利用；CPU和I-O外设忙闲不均"><a href="#2、缺点：系统资源得不到充分利用；CPU和I-O外设忙闲不均" class="headerlink" title="2、缺点：系统资源得不到充分利用；CPU和I/O外设忙闲不均"></a>2、缺点：系统资源得不到充分利用；CPU和I/O外设忙闲不均</h6><h5 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h5><h6 id="1、自动性"><a href="#1、自动性" class="headerlink" title="1、自动性"></a>1、自动性</h6><h6 id="2、顺序性"><a href="#2、顺序性" class="headerlink" title="2、顺序性"></a>2、顺序性</h6><h6 id="3、单道性"><a href="#3、单道性" class="headerlink" title="3、单道性"></a>3、单道性</h6><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><h6 id="作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。"><a href="#作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。" class="headerlink" title="作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。"></a>作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。</h6><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）"><a href="#1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）" class="headerlink" title="1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）"></a>1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）</h6><h6 id="2、缺点："><a href="#2、缺点：" class="headerlink" title="2、缺点："></a>2、缺点：</h6><p>用户交互性差：整个作业完成后或中间出错时，才与用户交互</p>
<p>作业平均周转时间长：短作业周转时间显著增长</p>
<h5 id="主要特征-1"><a href="#主要特征-1" class="headerlink" title="主要特征"></a>主要特征</h5><h6 id="1、多道：内存中同时存放多个作业"><a href="#1、多道：内存中同时存放多个作业" class="headerlink" title="1、多道：内存中同时存放多个作业"></a>1、多道：内存中同时存放多个作业</h6><h6 id="2、宏观：并行运行，都处于运行状态"><a href="#2、宏观：并行运行，都处于运行状态" class="headerlink" title="2、宏观：并行运行，都处于运行状态"></a>2、宏观：并行运行，都处于运行状态</h6><h6 id="3、微观：串行运行，各作业交替使用CPU"><a href="#3、微观：串行运行，各作业交替使用CPU" class="headerlink" title="3、微观：串行运行，各作业交替使用CPU"></a>3、微观：串行运行，各作业交替使用CPU</h6><h5 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h5><h3 id="1-5-3-分时系统"><a href="#1-5-3-分时系统" class="headerlink" title="1.5.3.     分时系统"></a>1.5.3.     分时系统</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><h5 id="是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。"><a href="#是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。" class="headerlink" title="是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。"></a>是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。</h5><h4 id="主要特征-2"><a href="#主要特征-2" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、交互性：用户与系统可以进行广泛的人机对话"><a href="#1、交互性：用户与系统可以进行广泛的人机对话" class="headerlink" title="1、交互性：用户与系统可以进行广泛的人机对话"></a>1、交互性：用户与系统可以进行广泛的人机对话</h5><h5 id="2、多路性：多用户在各自终端上使用同一CPU"><a href="#2、多路性：多用户在各自终端上使用同一CPU" class="headerlink" title="2、多路性：多用户在各自终端上使用同一CPU"></a>2、多路性：多用户在各自终端上使用同一CPU</h5><h5 id="3、独立性：用户独立操作，互不干扰"><a href="#3、独立性：用户独立操作，互不干扰" class="headerlink" title="3、独立性：用户独立操作，互不干扰"></a>3、独立性：用户独立操作，互不干扰</h5><h5 id="4、及时性-用户短时间内得到系统地及时回答"><a href="#4、及时性-用户短时间内得到系统地及时回答" class="headerlink" title="4、及时性:用户短时间内得到系统地及时回答"></a>4、及时性:用户短时间内得到系统地及时回答</h5><h5 id="ps：可靠性：较低"><a href="#ps：可靠性：较低" class="headerlink" title="ps：可靠性：较低"></a>ps：可靠性：较低</h5><h4 id="影响响应时间的因素"><a href="#影响响应时间的因素" class="headerlink" title="影响响应时间的因素"></a>影响响应时间的因素</h4><h5 id="终端数目；时间片大小；信息交换量；信息交换速度"><a href="#终端数目；时间片大小；信息交换量；信息交换速度" class="headerlink" title="终端数目；时间片大小；信息交换量；信息交换速度"></a>终端数目；时间片大小；信息交换量；信息交换速度</h5><h3 id="1-5-4-实时系统"><a href="#1-5-4-实时系统" class="headerlink" title="1.5.4.     实时系统"></a>1.5.4.     实时系统</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><h5 id="能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位"><a href="#能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位" class="headerlink" title="能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位"></a>能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位</h5><h4 id="主要特征-3"><a href="#主要特征-3" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序"><a href="#1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序" class="headerlink" title="1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序"></a>1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序</h5><h5 id="2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构"><a href="#2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构" class="headerlink" title="2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构"></a>2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构</h5><h5 id="3、独立性：独立操作互不干扰"><a href="#3、独立性：独立操作互不干扰" class="headerlink" title="3、独立性：独立操作互不干扰"></a>3、独立性：独立操作互不干扰</h5><h5 id="4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级"><a href="#4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级" class="headerlink" title="4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级"></a>4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级</h5><h5 id="ps-可靠性：高度可靠"><a href="#ps-可靠性：高度可靠" class="headerlink" title="ps:可靠性：高度可靠"></a>ps:可靠性：高度可靠</h5><h4 id="实时系统分类"><a href="#实时系统分类" class="headerlink" title="实时系统分类"></a>实时系统分类</h4><h5 id="实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统"><a href="#实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统" class="headerlink" title="实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统"></a>实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统</h5><h5 id="实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答"><a href="#实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答" class="headerlink" title="实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答"></a>实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答</h5><h4 id="任务类型分类"><a href="#任务类型分类" class="headerlink" title="任务类型分类"></a>任务类型分类</h4><h5 id="任务执行是否周期性"><a href="#任务执行是否周期性" class="headerlink" title="任务执行是否周期性"></a>任务执行是否周期性</h5><h6 id="周期性实时任务：设备周期性发送信号"><a href="#周期性实时任务：设备周期性发送信号" class="headerlink" title="周期性实时任务：设备周期性发送信号"></a>周期性实时任务：设备周期性发送信号</h6><h6 id="非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）"><a href="#非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）" class="headerlink" title="非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）"></a>非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）</h6><h5 id="截止时间的要求"><a href="#截止时间的要求" class="headerlink" title="截止时间的要求"></a>截止时间的要求</h5><h6 id="硬实时任务：必须满足截止时间"><a href="#硬实时任务：必须满足截止时间" class="headerlink" title="硬实时任务：必须满足截止时间"></a>硬实时任务：必须满足截止时间</h6><h6 id="软实时任务：允许偶尔不满足截止时间"><a href="#软实时任务：允许偶尔不满足截止时间" class="headerlink" title="软实时任务：允许偶尔不满足截止时间"></a>软实时任务：允许偶尔不满足截止时间</h6><h3 id="1-5-5-多处理机操作系统"><a href="#1-5-5-多处理机操作系统" class="headerlink" title="1.5.5.     多处理机操作系统"></a>1.5.5.     多处理机操作系统</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）"><a href="#增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）" class="headerlink" title="增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）"></a>增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）</h5><h5 id="提高系统可靠性：故障时系统降级运行"><a href="#提高系统可靠性：故障时系统降级运行" class="headerlink" title="提高系统可靠性：故障时系统降级运行"></a>提高系统可靠性：故障时系统降级运行</h5><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连"><a href="#并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连" class="headerlink" title="并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连"></a>并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连</h5><h6 id="对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式"><a href="#对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式" class="headerlink" title="对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式"></a>对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式</h6><h6 id="非对称式多重处理（主从模式-主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I-O处理。负载不匀，可靠性较低（通常要求硬件也非对称）"><a href="#非对称式多重处理（主从模式-主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I-O处理。负载不匀，可靠性较低（通常要求硬件也非对称）" class="headerlink" title="非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I/O处理。负载不匀，可靠性较低（通常要求硬件也非对称）"></a>非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I/O处理。负载不匀，可靠性较低（通常要求硬件也非对称）</h6><h5 id="分布式系统（松散耦合）：各处理机有各自的存储器，OS和I-O设备，由通道或通信线路相连"><a href="#分布式系统（松散耦合）：各处理机有各自的存储器，OS和I-O设备，由通道或通信线路相连" class="headerlink" title="分布式系统（松散耦合）：各处理机有各自的存储器，OS和I/O设备，由通道或通信线路相连"></a>分布式系统（松散耦合）：各处理机有各自的存储器，OS和I/O设备，由通道或通信线路相连</h5><h3 id="1-5-6-网络操作系统"><a href="#1-5-6-网络操作系统" class="headerlink" title="1.5.6.     网络操作系统"></a>1.5.6.     网络操作系统</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><h5 id="提供网络通信和网络服务功能的操作系统"><a href="#提供网络通信和网络服务功能的操作系统" class="headerlink" title="提供网络通信和网络服务功能的操作系统"></a>提供网络通信和网络服务功能的操作系统</h5><h4 id="主要特征-4"><a href="#主要特征-4" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、耦合程度"><a href="#1、耦合程度" class="headerlink" title="1、耦合程度"></a>1、耦合程度</h5><h6 id="松散耦合，允许异种OS互联，遵循“协议同质”"><a href="#松散耦合，允许异种OS互联，遵循“协议同质”" class="headerlink" title="松散耦合，允许异种OS互联，遵循“协议同质”"></a>松散耦合，允许异种OS互联，遵循“协议同质”</h6><h5 id="2、并行性"><a href="#2、并行性" class="headerlink" title="2、并行性"></a>2、并行性</h5><h6 id="各机进程独立"><a href="#各机进程独立" class="headerlink" title="各机进程独立"></a>各机进程独立</h6><h5 id="3、透明性（用户是否知道或指定资源在哪个机器上）"><a href="#3、透明性（用户是否知道或指定资源在哪个机器上）" class="headerlink" title="3、透明性（用户是否知道或指定资源在哪个机器上）"></a>3、透明性（用户是否知道或指定资源在哪个机器上）</h5><h6 id="用户明确指定要使用的网络资源"><a href="#用户明确指定要使用的网络资源" class="headerlink" title="用户明确指定要使用的网络资源"></a>用户明确指定要使用的网络资源</h6><h5 id="4、健壮性"><a href="#4、健壮性" class="headerlink" title="4、健壮性"></a>4、健壮性</h5><h6 id="要求不高"><a href="#要求不高" class="headerlink" title="要求不高"></a>要求不高</h6><h3 id="1-5-7-分布式操作系统"><a href="#1-5-7-分布式操作系统" class="headerlink" title="1.5.7.     分布式操作系统"></a>1.5.7.     分布式操作系统</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><h5 id="以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配"><a href="#以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配" class="headerlink" title="以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配"></a>以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配</h5><h4 id="主要特征-5"><a href="#主要特征-5" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、耦合程度-1"><a href="#1、耦合程度-1" class="headerlink" title="1、耦合程度"></a>1、耦合程度</h5><h6 id="紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。"><a href="#紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。" class="headerlink" title="紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。"></a>紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。</h6><h5 id="2、并行性-1"><a href="#2、并行性-1" class="headerlink" title="2、并行性"></a>2、并行性</h5><h6 id="一个进程可以分散在各机上并行执行，“进程迁移”"><a href="#一个进程可以分散在各机上并行执行，“进程迁移”" class="headerlink" title="一个进程可以分散在各机上并行执行，“进程迁移”"></a>一个进程可以分散在各机上并行执行，“进程迁移”</h6><h5 id="3、透明性"><a href="#3、透明性" class="headerlink" title="3、透明性"></a>3、透明性</h5><h6 id="网络资源调度对用户透明，用户不了解所占有资源所在位置"><a href="#网络资源调度对用户透明，用户不了解所占有资源所在位置" class="headerlink" title="网络资源调度对用户透明，用户不了解所占有资源所在位置"></a>网络资源调度对用户透明，用户不了解所占有资源所在位置</h6><h5 id="4、健壮性-1"><a href="#4、健壮性-1" class="headerlink" title="4、健壮性"></a>4、健壮性</h5><h6 id="要求比网络OS更强的容错能力（工作时系统重构）"><a href="#要求比网络OS更强的容错能力（工作时系统重构）" class="headerlink" title="要求比网络OS更强的容错能力（工作时系统重构）"></a>要求比网络OS更强的容错能力（工作时系统重构）</h6><h3 id="1-5-8-个人计算机操作系统"><a href="#1-5-8-个人计算机操作系统" class="headerlink" title="1.5.8.     个人计算机操作系统"></a>1.5.8.     个人计算机操作系统</h3><h4 id="单用户单任务"><a href="#单用户单任务" class="headerlink" title="单用户单任务"></a>单用户单任务</h4><h5 id="只允许一个用户上机，只允许用户程序作为一个任务运行"><a href="#只允许一个用户上机，只允许用户程序作为一个任务运行" class="headerlink" title="只允许一个用户上机，只允许用户程序作为一个任务运行"></a>只允许一个用户上机，只允许用户程序作为一个任务运行</h5><h4 id="单用户多任务"><a href="#单用户多任务" class="headerlink" title="单用户多任务"></a>单用户多任务</h4><h5 id="只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能"><a href="#只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能" class="headerlink" title="只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能"></a>只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能</h5><h4 id="多用户多任务"><a href="#多用户多任务" class="headerlink" title="多用户多任务"></a>多用户多任务</h4><h5 id="允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能"><a href="#允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能" class="headerlink" title="允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能"></a>允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能</h5><h2 id="1-6-操作系统基本特征"><a href="#1-6-操作系统基本特征" class="headerlink" title="1.6.     操作系统基本特征"></a>1.6.     操作系统基本特征</h2><h3 id="1-6-1-并发"><a href="#1-6-1-并发" class="headerlink" title="1.6.1.     并发"></a>1.6.1.     并发</h3><h4 id="多个事件同一时间段发生"><a href="#多个事件同一时间段发生" class="headerlink" title="多个事件同一时间段发生"></a>多个事件同一时间段发生</h4><h4 id="ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行"><a href="#ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行" class="headerlink" title="ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行"></a>ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行</h4><h3 id="1-6-2-共享"><a href="#1-6-2-共享" class="headerlink" title="1.6.2.     共享"></a>1.6.2.     共享</h3><h4 id="计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问"><a href="#计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问" class="headerlink" title="计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问"></a>计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问</h4><h3 id="1-6-3-虚拟"><a href="#1-6-3-虚拟" class="headerlink" title="1.6.3.     虚拟"></a>1.6.3.     虚拟</h3><h4 id="一个物理实体映射为多个逻辑实体——分时或分空间"><a href="#一个物理实体映射为多个逻辑实体——分时或分空间" class="headerlink" title="一个物理实体映射为多个逻辑实体——分时或分空间"></a>一个物理实体映射为多个逻辑实体——分时或分空间</h4><h3 id="1-6-4-异步"><a href="#1-6-4-异步" class="headerlink" title="1.6.4.     异步"></a>1.6.4.     异步</h3><h4 id="又称不确定性；指进程的执行顺序和执行时间的不确定性。"><a href="#又称不确定性；指进程的执行顺序和执行时间的不确定性。" class="headerlink" title="又称不确定性；指进程的执行顺序和执行时间的不确定性。"></a>又称不确定性；指进程的执行顺序和执行时间的不确定性。</h4><h2 id="1-7-操作系统组成"><a href="#1-7-操作系统组成" class="headerlink" title="1.7.     操作系统组成"></a>1.7.     操作系统组成</h2><h3 id="1-7-1-管理模块"><a href="#1-7-1-管理模块" class="headerlink" title="1.7.1.     管理模块"></a>1.7.1.     管理模块</h3><h4 id="针对不同管理对象模块的程序模块（通常被称为操作系统核心）"><a href="#针对不同管理对象模块的程序模块（通常被称为操作系统核心）" class="headerlink" title="针对不同管理对象模块的程序模块（通常被称为操作系统核心）"></a>针对不同管理对象模块的程序模块（通常被称为操作系统核心）</h4><h3 id="1-7-2-用户接口"><a href="#1-7-2-用户接口" class="headerlink" title="1.7.2.     用户接口"></a>1.7.2.     用户接口</h3><h4 id="如外壳（shell）、窗口系统"><a href="#如外壳（shell）、窗口系统" class="headerlink" title="如外壳（shell）、窗口系统"></a>如外壳（shell）、窗口系统</h4><h2 id="1-8-操作系统主要功能"><a href="#1-8-操作系统主要功能" class="headerlink" title="1.8.     操作系统主要功能"></a>1.8.     操作系统主要功能</h2><h3 id="1-8-1-存储管理"><a href="#1-8-1-存储管理" class="headerlink" title="1.8.1.     存储管理"></a>1.8.1.     存储管理</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><h5 id="提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行"><a href="#提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行" class="headerlink" title="提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行"></a>提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行</h5><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="1、存储分配和回收"><a href="#1、存储分配和回收" class="headerlink" title="1、存储分配和回收"></a>1、存储分配和回收</h5><h5 id="2、存储保护"><a href="#2、存储保护" class="headerlink" title="2、存储保护"></a>2、存储保护</h5><h6 id="保证进程互不干扰"><a href="#保证进程互不干扰" class="headerlink" title="保证进程互不干扰"></a>保证进程互不干扰</h6><h5 id="3、地址映射"><a href="#3、地址映射" class="headerlink" title="3、地址映射"></a>3、地址映射</h5><h6 id="进程逻辑地址到内存物理地址的映射"><a href="#进程逻辑地址到内存物理地址的映射" class="headerlink" title="进程逻辑地址到内存物理地址的映射"></a>进程逻辑地址到内存物理地址的映射</h6><h5 id="4、内存扩充"><a href="#4、内存扩充" class="headerlink" title="4、内存扩充"></a>4、内存扩充</h5><h6 id="覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间"><a href="#覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间" class="headerlink" title="覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间"></a>覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间</h6><h3 id="1-8-2-处理机管理"><a href="#1-8-2-处理机管理" class="headerlink" title="1.8.2.     处理机管理"></a>1.8.2.     处理机管理</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><h5 id="处理机资源的分配调度"><a href="#处理机资源的分配调度" class="headerlink" title="处理机资源的分配调度"></a>处理机资源的分配调度</h5><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><h5 id="1、进程控制"><a href="#1、进程控制" class="headerlink" title="1、进程控制"></a>1、进程控制</h5><h6 id="创建、撤销、挂起、改变优先级等"><a href="#创建、撤销、挂起、改变优先级等" class="headerlink" title="创建、撤销、挂起、改变优先级等"></a>创建、撤销、挂起、改变优先级等</h6><h5 id="2、进程同步"><a href="#2、进程同步" class="headerlink" title="2、进程同步"></a>2、进程同步</h5><h6 id="协调并发进程之间的推进步骤，以协调资源共享"><a href="#协调并发进程之间的推进步骤，以协调资源共享" class="headerlink" title="协调并发进程之间的推进步骤，以协调资源共享"></a>协调并发进程之间的推进步骤，以协调资源共享</h6><h5 id="3、进程通信"><a href="#3、进程通信" class="headerlink" title="3、进程通信"></a>3、进程通信</h5><h6 id="进程之间传输数据，协调合作"><a href="#进程之间传输数据，协调合作" class="headerlink" title="进程之间传输数据，协调合作"></a>进程之间传输数据，协调合作</h6><h5 id="4、调度"><a href="#4、调度" class="headerlink" title="4、调度"></a>4、调度</h5><h6 id="作业或进程的运行切换"><a href="#作业或进程的运行切换" class="headerlink" title="作业或进程的运行切换"></a>作业或进程的运行切换</h6><h3 id="1-8-3-设备管理"><a href="#1-8-3-设备管理" class="headerlink" title="1.8.3.     设备管理"></a>1.8.3.     设备管理</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><h5 id="方便用户使用设备、提高CPU和I-O利用率"><a href="#方便用户使用设备、提高CPU和I-O利用率" class="headerlink" title="方便用户使用设备、提高CPU和I/O利用率"></a>方便用户使用设备、提高CPU和I/O利用率</h5><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><h5 id="1、设备操作"><a href="#1、设备操作" class="headerlink" title="1、设备操作"></a>1、设备操作</h5><h6 id="利用设备驱动程序完成对设备的操作"><a href="#利用设备驱动程序完成对设备的操作" class="headerlink" title="利用设备驱动程序完成对设备的操作"></a>利用设备驱动程序完成对设备的操作</h6><h5 id="2、设备独立性"><a href="#2、设备独立性" class="headerlink" title="2、设备独立性"></a>2、设备独立性</h5><h6 id="提供统一的I-O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容"><a href="#提供统一的I-O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容" class="headerlink" title="提供统一的I/O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容"></a>提供统一的I/O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容</h6><h5 id="3、设备分配与回收"><a href="#3、设备分配与回收" class="headerlink" title="3、设备分配与回收"></a>3、设备分配与回收</h5><h6 id="多用户间共享I-O设备"><a href="#多用户间共享I-O设备" class="headerlink" title="多用户间共享I/O设备"></a>多用户间共享I/O设备</h6><h3 id="1-8-4-文件管理"><a href="#1-8-4-文件管理" class="headerlink" title="1.8.4.     文件管理"></a>1.8.4.     文件管理</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><h5 id="管理用户文件和系统文件方便用户使用，并保证文件安全性"><a href="#管理用户文件和系统文件方便用户使用，并保证文件安全性" class="headerlink" title="管理用户文件和系统文件方便用户使用，并保证文件安全性"></a>管理用户文件和系统文件方便用户使用，并保证文件安全性</h5><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><h5 id="1、文件存储空间管理"><a href="#1、文件存储空间管理" class="headerlink" title="1、文件存储空间管理"></a>1、文件存储空间管理</h5><h5 id="2、目录管理"><a href="#2、目录管理" class="headerlink" title="2、目录管理"></a>2、目录管理</h5><h6 id="解决文件检索问题"><a href="#解决文件检索问题" class="headerlink" title="解决文件检索问题"></a>解决文件检索问题</h6><h5 id="3、文件读写管理与存取控制"><a href="#3、文件读写管理与存取控制" class="headerlink" title="3、文件读写管理与存取控制"></a>3、文件读写管理与存取控制</h5><h5 id="4、软件管理"><a href="#4、软件管理" class="headerlink" title="4、软件管理"></a>4、软件管理</h5><h6 id="软件版本、相互依赖关系、安装和卸载等"><a href="#软件版本、相互依赖关系、安装和卸载等" class="headerlink" title="软件版本、相互依赖关系、安装和卸载等"></a>软件版本、相互依赖关系、安装和卸载等</h6><h3 id="1-8-5-用户接口"><a href="#1-8-5-用户接口" class="headerlink" title="1.8.5.     用户接口"></a>1.8.5.     用户接口</h3><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><h5 id="提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供"><a href="#提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供" class="headerlink" title="提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供"></a>提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供</h5><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><h5 id="1、命令接口"><a href="#1、命令接口" class="headerlink" title="1、命令接口"></a>1、命令接口</h5><h6 id="联机用户接口：为联机用户提供，由键盘操作命令-命令解释程序组成"><a href="#联机用户接口：为联机用户提供，由键盘操作命令-命令解释程序组成" class="headerlink" title="联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成"></a>联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成</h6><h6 id="脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成"><a href="#脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成" class="headerlink" title="脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成"></a>脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成</h6><h5 id="2、程序接口"><a href="#2、程序接口" class="headerlink" title="2、程序接口"></a>2、程序接口</h5><h6 id="用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成"><a href="#用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成" class="headerlink" title="用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成"></a>用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成</h6><h5 id="3、图形接口"><a href="#3、图形接口" class="headerlink" title="3、图形接口"></a>3、图形接口</h5><h6 id="用鼠标通过菜单框来完成对应用程序和文件的操作"><a href="#用鼠标通过菜单框来完成对应用程序和文件的操作" class="headerlink" title="用鼠标通过菜单框来完成对应用程序和文件的操作"></a>用鼠标通过菜单框来完成对应用程序和文件的操作</h6><h2 id="1-9-双模式操作"><a href="#1-9-双模式操作" class="headerlink" title="1.9.     双模式操作"></a>1.9.     双模式操作</h2><h3 id="1-9-1-分类"><a href="#1-9-1-分类" class="headerlink" title="1.9.1.     分类"></a>1.9.1.     分类</h3><h4 id="1、用户模式（目态—模式位1）"><a href="#1、用户模式（目态—模式位1）" class="headerlink" title="1、用户模式（目态—模式位1）"></a>1、用户模式（目态—模式位1）</h4><h4 id="2、监控模式（管态—模式位0）"><a href="#2、监控模式（管态—模式位0）" class="headerlink" title="2、监控模式（管态—模式位0）"></a>2、监控模式（管态—模式位0）</h4><h3 id="1-9-2-切换"><a href="#1-9-2-切换" class="headerlink" title="1.9.2.     切换"></a>1.9.2.     切换</h3><h4 id="用户态-gt-系统态"><a href="#用户态-gt-系统态" class="headerlink" title="用户态-&gt;系统态"></a>用户态-&gt;系统态</h4><h5 id="中断、故障、系统调用（用户需要操作系统的服务）"><a href="#中断、故障、系统调用（用户需要操作系统的服务）" class="headerlink" title="中断、故障、系统调用（用户需要操作系统的服务）"></a>中断、故障、系统调用（用户需要操作系统的服务）</h5><h4 id="系统态-gt-用户态"><a href="#系统态-gt-用户态" class="headerlink" title="系统态-&gt;用户态"></a>系统态-&gt;用户态</h4><h5 id="OS设置用户态"><a href="#OS设置用户态" class="headerlink" title="OS设置用户态"></a>OS设置用户态</h5><h3 id="1-9-3-作用"><a href="#1-9-3-作用" class="headerlink" title="1.9.3.     作用"></a>1.9.3.     作用</h3><h4 id="确保系统和用户程序不受错误的系统程序的影响"><a href="#确保系统和用户程序不受错误的系统程序的影响" class="headerlink" title="确保系统和用户程序不受错误的系统程序的影响"></a>确保系统和用户程序不受错误的系统程序的影响</h4><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统"><a href="#将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统" class="headerlink" title="将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统"></a>将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统</h5><h3 id="1-9-4-特权指令"><a href="#1-9-4-特权指令" class="headerlink" title="1.9.4.     特权指令"></a>1.9.4.     特权指令</h3><h4 id="1、有关I-O设备的指令"><a href="#1、有关I-O设备的指令" class="headerlink" title="1、有关I/O设备的指令"></a>1、有关I/O设备的指令</h4><h4 id="2、访问程序状态的指令"><a href="#2、访问程序状态的指令" class="headerlink" title="2、访问程序状态的指令"></a>2、访问程序状态的指令</h4><h4 id="3、存储特殊寄存器的指令"><a href="#3、存储特殊寄存器的指令" class="headerlink" title="3、存储特殊寄存器的指令"></a>3、存储特殊寄存器的指令</h4><h4 id="4、其他指令"><a href="#4、其他指令" class="headerlink" title="4、其他指令"></a>4、其他指令</h4><h2 id="1-10-操作系统保护机制"><a href="#1-10-操作系统保护机制" class="headerlink" title="1.10.   操作系统保护机制"></a>1.10.   操作系统保护机制</h2><h3 id="1-10-1-I-O保护"><a href="#1-10-1-I-O保护" class="headerlink" title="1.10.1.   I/O保护"></a>1.10.1.   I/O保护</h3><h4 id="所有的I-O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权"><a href="#所有的I-O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权" class="headerlink" title="所有的I/O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权"></a>所有的I/O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权</h4><h3 id="1-10-2-存储保护"><a href="#1-10-2-存储保护" class="headerlink" title="1.10.2.   存储保护"></a>1.10.2.   存储保护</h3><h4 id="某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区"><a href="#某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区" class="headerlink" title="某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区"></a>某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区</h4><h4 id="为了实现存储保护，增加两个寄存器"><a href="#为了实现存储保护，增加两个寄存器" class="headerlink" title="为了实现存储保护，增加两个寄存器"></a>为了实现存储保护，增加两个寄存器</h4><h5 id="基地址寄存器：存放本进程最低的内存物理地址"><a href="#基地址寄存器：存放本进程最低的内存物理地址" class="headerlink" title="基地址寄存器：存放本进程最低的内存物理地址"></a>基地址寄存器：存放本进程最低的内存物理地址</h5><h5 id="界限寄存器：存放本进程的存储区域大小"><a href="#界限寄存器：存放本进程的存储区域大小" class="headerlink" title="界限寄存器：存放本进程的存储区域大小"></a>界限寄存器：存放本进程的存储区域大小</h5><h4 id="硬件保护原则"><a href="#硬件保护原则" class="headerlink" title="硬件保护原则"></a>硬件保护原则</h4><h5 id="管态下OS可以无限制访问核心和所有用户程序的地址空间"><a href="#管态下OS可以无限制访问核心和所有用户程序的地址空间" class="headerlink" title="管态下OS可以无限制访问核心和所有用户程序的地址空间"></a>管态下OS可以无限制访问核心和所有用户程序的地址空间</h5><h4 id="修改基地址寄存器和界限寄存器的指令属于特权指令"><a href="#修改基地址寄存器和界限寄存器的指令属于特权指令" class="headerlink" title="修改基地址寄存器和界限寄存器的指令属于特权指令"></a>修改基地址寄存器和界限寄存器的指令属于特权指令</h4><h3 id="1-10-3-CPU保护"><a href="#1-10-3-CPU保护" class="headerlink" title="1.10.3.   CPU保护"></a>1.10.3.   CPU保护</h3><h4 id="为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断"><a href="#为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断" class="headerlink" title="为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断"></a>为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断</h4><h4 id="定时时钟是实现分时操作系统的基础"><a href="#定时时钟是实现分时操作系统的基础" class="headerlink" title="定时时钟是实现分时操作系统的基础"></a>定时时钟是实现分时操作系统的基础</h4><h4 id="修改定时时钟的指令为特权指令"><a href="#修改定时时钟的指令为特权指令" class="headerlink" title="修改定时时钟的指令为特权指令"></a>修改定时时钟的指令为特权指令</h4><h1 id="2-二、进程的描述与控制"><a href="#2-二、进程的描述与控制" class="headerlink" title="2.    二、进程的描述与控制"></a>2.    二、进程的描述与控制</h1><h2 id="2-1-进程描述"><a href="#2-1-进程描述" class="headerlink" title="2.1.     进程描述"></a>2.1.     进程描述</h2><h3 id="2-1-1-进程定义"><a href="#2-1-1-进程定义" class="headerlink" title="2.1.1.     进程定义"></a>2.1.1.     进程定义</h3><h4 id="一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程"><a href="#一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程" class="headerlink" title="一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程"></a>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</h4><h4 id="是资源分配和管理的基本单位"><a href="#是资源分配和管理的基本单位" class="headerlink" title="是资源分配和管理的基本单位"></a>是资源分配和管理的基本单位</h4><h3 id="2-1-2-进程执行方式"><a href="#2-1-2-进程执行方式" class="headerlink" title="2.1.2.     进程执行方式"></a>2.1.2.     进程执行方式</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><h6 id="1、顺序性"><a href="#1、顺序性" class="headerlink" title="1、顺序性"></a>1、顺序性</h6><h6 id="2、封闭性"><a href="#2、封闭性" class="headerlink" title="2、封闭性"></a>2、封闭性</h6><p>独占全部资源</p>
<h6 id="3、可再现性"><a href="#3、可再现性" class="headerlink" title="3、可再现性"></a>3、可再现性</h6><p>初始条件相同则结果相同</p>
<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><h6 id="提高资源利用率"><a href="#提高资源利用率" class="headerlink" title="提高资源利用率"></a>提高资源利用率</h6><h5 id="特征（不加入任何系统控制）"><a href="#特征（不加入任何系统控制）" class="headerlink" title="特征（不加入任何系统控制）"></a>特征（不加入任何系统控制）</h5><h6 id="1、间断性"><a href="#1、间断性" class="headerlink" title="1、间断性"></a>1、间断性</h6><h6 id="2、失去封闭性：共享资源"><a href="#2、失去封闭性：共享资源" class="headerlink" title="2、失去封闭性：共享资源"></a>2、失去封闭性：共享资源</h6><h6 id="3、失去可再现性"><a href="#3、失去可再现性" class="headerlink" title="3、失去可再现性"></a>3、失去可再现性</h6><h5 id="执行条件"><a href="#执行条件" class="headerlink" title="执行条件"></a>执行条件</h5><h6 id="达到封闭性和可再现性"><a href="#达到封闭性和可再现性" class="headerlink" title="达到封闭性和可再现性"></a>达到封闭性和可再现性</h6><h3 id="2-1-3-与程序的关系"><a href="#2-1-3-与程序的关系" class="headerlink" title="2.1.3.     与程序的关系"></a>2.1.3.     与程序的关系</h3><h4 id="一个进程多个线程，一个线程对应一个进程"><a href="#一个进程多个线程，一个线程对应一个进程" class="headerlink" title="一个进程多个线程，一个线程对应一个进程"></a>一个进程多个线程，一个线程对应一个进程</h4><h3 id="2-1-4-进程特征"><a href="#2-1-4-进程特征" class="headerlink" title="2.1.4.     进程特征"></a>2.1.4.     进程特征</h3><h4 id="1、动态性"><a href="#1、动态性" class="headerlink" title="1、动态性"></a>1、动态性</h4><h4 id="2、并发性"><a href="#2、并发性" class="headerlink" title="2、并发性"></a>2、并发性</h4><h4 id="3、独立性"><a href="#3、独立性" class="headerlink" title="3、独立性"></a>3、独立性</h4><h5 id="资源分配的基本单位"><a href="#资源分配的基本单位" class="headerlink" title="资源分配的基本单位"></a>资源分配的基本单位</h5><h4 id="4、异步性"><a href="#4、异步性" class="headerlink" title="4、异步性"></a>4、异步性</h4><h5 id="进程各自独立，推进速度不可预知"><a href="#进程各自独立，推进速度不可预知" class="headerlink" title="进程各自独立，推进速度不可预知"></a>进程各自独立，推进速度不可预知</h5><h4 id="5、结构化"><a href="#5、结构化" class="headerlink" title="5、结构化"></a>5、结构化</h4><h5 id="代码段-数据段-程序控制块（PCB）"><a href="#代码段-数据段-程序控制块（PCB）" class="headerlink" title="代码段+数据段+程序控制块（PCB）"></a>代码段+数据段+程序控制块（PCB）</h5><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><h3 id="2-1-5-进程基本状态及转换"><a href="#2-1-5-进程基本状态及转换" class="headerlink" title="2.1.5.     进程基本状态及转换"></a>2.1.5.     进程基本状态及转换</h3><h4 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h4><h5 id="就绪（Ready）状态"><a href="#就绪（Ready）状态" class="headerlink" title="就绪（Ready）状态"></a>就绪（Ready）状态</h5><h5 id="执行（Running）状态"><a href="#执行（Running）状态" class="headerlink" title="执行（Running）状态"></a>执行（Running）状态</h5><h5 id="阻塞（Block）状态"><a href="#阻塞（Block）状态" class="headerlink" title="阻塞（Block）状态"></a>阻塞（Block）状态</h5><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><h5 id="PPT-6"><a href="#PPT-6" class="headerlink" title="PPT-6"></a>PPT-6</h5><h2 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2.     进程控制"></a>2.2.     进程控制</h2><h3 id="2-2-1-程序控制块PCB"><a href="#2-2-1-程序控制块PCB" class="headerlink" title="2.2.1.     程序控制块PCB"></a>2.2.1.     程序控制块PCB</h3><h4 id="1、是描述进程的数据结构，保存与该进程有关的各种数据信息"><a href="#1、是描述进程的数据结构，保存与该进程有关的各种数据信息" class="headerlink" title="1、是描述进程的数据结构，保存与该进程有关的各种数据信息"></a>1、是描述进程的数据结构，保存与该进程有关的各种数据信息</h4><h5 id="1、进程描述信息：进程标识符"><a href="#1、进程描述信息：进程标识符" class="headerlink" title="1、进程描述信息：进程标识符"></a>1、进程描述信息：进程标识符</h5><h5 id="2、处理机状态信息：保存进程运行现场信息"><a href="#2、处理机状态信息：保存进程运行现场信息" class="headerlink" title="2、处理机状态信息：保存进程运行现场信息"></a>2、处理机状态信息：保存进程运行现场信息</h5><h5 id="3、进程调度信息"><a href="#3、进程调度信息" class="headerlink" title="3、进程调度信息"></a>3、进程调度信息</h5><h5 id="4、进程控制信息"><a href="#4、进程控制信息" class="headerlink" title="4、进程控制信息"></a>4、进程控制信息</h5><h4 id="2、进程的唯一标识，每个进程在OS的登记表项"><a href="#2、进程的唯一标识，每个进程在OS的登记表项" class="headerlink" title="2、进程的唯一标识，每个进程在OS的登记表项"></a>2、进程的唯一标识，每个进程在OS的登记表项</h4><h4 id="3、进程创建时生成，终止时回收"><a href="#3、进程创建时生成，终止时回收" class="headerlink" title="3、进程创建时生成，终止时回收"></a>3、进程创建时生成，终止时回收</h4><h4 id="4、在内存核心区，系统调用间接访问"><a href="#4、在内存核心区，系统调用间接访问" class="headerlink" title="4、在内存核心区，系统调用间接访问"></a>4、在内存核心区，系统调用间接访问</h4><h4 id="5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表"><a href="#5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表" class="headerlink" title="5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表"></a>5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表</h4><h5 id="OS怎么管理PCB进行进程调度？"><a href="#OS怎么管理PCB进行进程调度？" class="headerlink" title="OS怎么管理PCB进行进程调度？"></a>OS怎么管理PCB进行进程调度？</h5><h6 id="作业队列：所有进程集合"><a href="#作业队列：所有进程集合" class="headerlink" title="作业队列：所有进程集合"></a>作业队列：所有进程集合</h6><h6 id="就绪队列：就绪进程集合"><a href="#就绪队列：就绪进程集合" class="headerlink" title="就绪队列：就绪进程集合"></a>就绪队列：就绪进程集合</h6><h6 id="设备队列：等待I-O设备的进程集合"><a href="#设备队列：等待I-O设备的进程集合" class="headerlink" title="设备队列：等待I/O设备的进程集合"></a>设备队列：等待I/O设备的进程集合</h6><h6 id="令进程在各种不同的队列中迁移"><a href="#令进程在各种不同的队列中迁移" class="headerlink" title="令进程在各种不同的队列中迁移"></a>令进程在各种不同的队列中迁移</h6><h5 id="PCB组织方式"><a href="#PCB组织方式" class="headerlink" title="PCB组织方式"></a>PCB组织方式</h5><h6 id="同一状态进程的PCB构成一个链表"><a href="#同一状态进程的PCB构成一个链表" class="headerlink" title="同一状态进程的PCB构成一个链表"></a>同一状态进程的PCB构成一个链表</h6><h6 id="同一状态进程归入一个index表，由index指向PCB"><a href="#同一状态进程归入一个index表，由index指向PCB" class="headerlink" title="同一状态进程归入一个index表，由index指向PCB"></a>同一状态进程归入一个index表，由index指向PCB</h6><h3 id="2-2-2-进程管理"><a href="#2-2-2-进程管理" class="headerlink" title="2.2.2.     进程管理"></a>2.2.2.     进程管理</h3><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h5><h6 id="创建、运行、等待、唤醒、终止"><a href="#创建、运行、等待、唤醒、终止" class="headerlink" title="创建、运行、等待、唤醒、终止"></a>创建、运行、等待、唤醒、终止</h6><h5 id="进程控制任务"><a href="#进程控制任务" class="headerlink" title="进程控制任务"></a>进程控制任务</h5><h6 id="进程创建、终止、状态转变"><a href="#进程创建、终止、状态转变" class="headerlink" title="进程创建、终止、状态转变"></a>进程创建、终止、状态转变</h6><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="OS内核原语实现"><a href="#OS内核原语实现" class="headerlink" title="OS内核原语实现"></a>OS内核原语实现</h6><p>原语：若干条指令构成的原子操作</p>
<p>许多系统调用是原语，但不是全部</p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h5 id="引起创建的事件"><a href="#引起创建的事件" class="headerlink" title="引起创建的事件"></a>引起创建的事件</h5><h6 id="1、用户登录"><a href="#1、用户登录" class="headerlink" title="1、用户登录"></a>1、用户登录</h6><h6 id="2、作业调度"><a href="#2、作业调度" class="headerlink" title="2、作业调度"></a>2、作业调度</h6><h6 id="3、提供服务"><a href="#3、提供服务" class="headerlink" title="3、提供服务"></a>3、提供服务</h6><h6 id="4、应用请求"><a href="#4、应用请求" class="headerlink" title="4、应用请求"></a>4、应用请求</h6><h5 id="创建步骤（原语CREATE（））"><a href="#创建步骤（原语CREATE（））" class="headerlink" title="创建步骤（原语CREATE（））"></a>创建步骤（原语CREATE（））</h5><h6 id="1、申请空白PCB"><a href="#1、申请空白PCB" class="headerlink" title="1、申请空白PCB"></a>1、申请空白PCB</h6><h6 id="2、为新进程分配资源"><a href="#2、为新进程分配资源" class="headerlink" title="2、为新进程分配资源"></a>2、为新进程分配资源</h6><h6 id="3、初始化PCB"><a href="#3、初始化PCB" class="headerlink" title="3、初始化PCB"></a>3、初始化PCB</h6><h6 id="4、将新进程插入就绪队列"><a href="#4、将新进程插入就绪队列" class="headerlink" title="4、将新进程插入就绪队列"></a>4、将新进程插入就绪队列</h6><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><h5 id="引起终止的事件"><a href="#引起终止的事件" class="headerlink" title="引起终止的事件"></a>引起终止的事件</h5><h6 id="1、正常结束"><a href="#1、正常结束" class="headerlink" title="1、正常结束"></a>1、正常结束</h6><h6 id="2、异常结束"><a href="#2、异常结束" class="headerlink" title="2、异常结束"></a>2、异常结束</h6><h6 id="3、外界干预"><a href="#3、外界干预" class="headerlink" title="3、外界干预"></a>3、外界干预</h6><h5 id="终止步骤（原语EXIT（））"><a href="#终止步骤（原语EXIT（））" class="headerlink" title="终止步骤（原语EXIT（））"></a>终止步骤（原语EXIT（））</h5><h6 id="1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态"><a href="#1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态" class="headerlink" title="1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态"></a>1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态</h6><h6 id="2、若处于执行状态，终止该进程，置调度标志为1，重新调度"><a href="#2、若处于执行状态，终止该进程，置调度标志为1，重新调度" class="headerlink" title="2、若处于执行状态，终止该进程，置调度标志为1，重新调度"></a>2、若处于执行状态，终止该进程，置调度标志为1，重新调度</h6><h6 id="3、有子孙进程就终止"><a href="#3、有子孙进程就终止" class="headerlink" title="3、有子孙进程就终止"></a>3、有子孙进程就终止</h6><h6 id="4、进程资源归还给父进程或者系统"><a href="#4、进程资源归还给父进程或者系统" class="headerlink" title="4、进程资源归还给父进程或者系统"></a>4、进程资源归还给父进程或者系统</h6><h6 id="5、进程PCB移出所在队列"><a href="#5、进程PCB移出所在队列" class="headerlink" title="5、进程PCB移出所在队列"></a>5、进程PCB移出所在队列</h6><h4 id="进程阻塞与唤醒"><a href="#进程阻塞与唤醒" class="headerlink" title="进程阻塞与唤醒"></a>进程阻塞与唤醒</h4><h5 id="引起阻塞与唤醒的事件"><a href="#引起阻塞与唤醒的事件" class="headerlink" title="引起阻塞与唤醒的事件"></a>引起阻塞与唤醒的事件</h5><h6 id="1、请求系统共享资源服务"><a href="#1、请求系统共享资源服务" class="headerlink" title="1、请求系统共享资源服务"></a>1、请求系统共享资源服务</h6><h6 id="2、启动某种操作（例如I-O）"><a href="#2、启动某种操作（例如I-O）" class="headerlink" title="2、启动某种操作（例如I/O）"></a>2、启动某种操作（例如I/O）</h6><h6 id="3、新数据尚未到达"><a href="#3、新数据尚未到达" class="headerlink" title="3、新数据尚未到达"></a>3、新数据尚未到达</h6><h6 id="4、等待新任务的到达"><a href="#4、等待新任务的到达" class="headerlink" title="4、等待新任务的到达"></a>4、等待新任务的到达</h6><h5 id="阻塞步骤（原语BLOCK（））"><a href="#阻塞步骤（原语BLOCK（））" class="headerlink" title="阻塞步骤（原语BLOCK（））"></a>阻塞步骤（原语BLOCK（））</h5><h6 id="1、保存当前进程的CPU现场"><a href="#1、保存当前进程的CPU现场" class="headerlink" title="1、保存当前进程的CPU现场"></a>1、保存当前进程的CPU现场</h6><h6 id="2、置该进程状态（变为阻塞态）"><a href="#2、置该进程状态（变为阻塞态）" class="headerlink" title="2、置该进程状态（变为阻塞态）"></a>2、置该进程状态（变为阻塞态）</h6><h6 id="3、PCB进入等待队列"><a href="#3、PCB进入等待队列" class="headerlink" title="3、PCB进入等待队列"></a>3、PCB进入等待队列</h6><h6 id="4、转进程调度"><a href="#4、转进程调度" class="headerlink" title="4、转进程调度"></a>4、转进程调度</h6><h5 id="唤醒步骤（原语WAKEUP（））"><a href="#唤醒步骤（原语WAKEUP（））" class="headerlink" title="唤醒步骤（原语WAKEUP（））"></a>唤醒步骤（原语WAKEUP（））</h5><h6 id="1、等待队列中摘下被唤醒进程"><a href="#1、等待队列中摘下被唤醒进程" class="headerlink" title="1、等待队列中摘下被唤醒进程"></a>1、等待队列中摘下被唤醒进程</h6><h6 id="2、置该进程状态（变为就绪态）"><a href="#2、置该进程状态（变为就绪态）" class="headerlink" title="2、置该进程状态（变为就绪态）"></a>2、置该进程状态（变为就绪态）</h6><h6 id="3、进入就绪队列"><a href="#3、进入就绪队列" class="headerlink" title="3、进入就绪队列"></a>3、进入就绪队列</h6><h6 id="4、转进程调度或返回"><a href="#4、转进程调度或返回" class="headerlink" title="4、转进程调度或返回"></a>4、转进程调度或返回</h6><h4 id="进程挂起与激活"><a href="#进程挂起与激活" class="headerlink" title="进程挂起与激活"></a>进程挂起与激活</h4><h5 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h5><h6 id="挂起引入原因"><a href="#挂起引入原因" class="headerlink" title="挂起引入原因"></a>挂起引入原因</h6><p>1、终端用户请求</p>
<p>2、父进程请求</p>
<p>3、负荷调节需要</p>
<p>4、OS需要</p>
<h6 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h6><p>合理且充分的利用系统资源</p>
<h6 id="挂起步骤（原语SUSPEND（））"><a href="#挂起步骤（原语SUSPEND（））" class="headerlink" title="挂起步骤（原语SUSPEND（））"></a>挂起步骤（原语SUSPEND（））</h6><p>1、从内存调到外存，改变进程状态</p>
<p>2、若活动就绪/阻塞，转为静止就绪/阻塞</p>
<p>3、若正在执行，则转向调度程序重新调度</p>
<h5 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h5><h6 id="激活引入原因"><a href="#激活引入原因" class="headerlink" title="激活引入原因"></a>激活引入原因</h6><p>1、终端用户请求</p>
<p>2、父进程请求</p>
<p>3、内存空间足够</p>
<h6 id="激活步骤（原语ACTIVE（））"><a href="#激活步骤（原语ACTIVE（））" class="headerlink" title="激活步骤（原语ACTIVE（））"></a>激活步骤（原语ACTIVE（））</h6><p>1、从外存调到内存，改变进程状态</p>
<p>2、也可能引起处理机调度（比较被激活进程优先级和当前进程优先级）</p>
<h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3.     进程同步"></a>2.3.     进程同步</h2><h3 id="2-3-1-基本概念"><a href="#2-3-1-基本概念" class="headerlink" title="2.3.1.     基本概念"></a>2.3.1.     基本概念</h3><h4 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h4><h5 id="间接制约"><a href="#间接制约" class="headerlink" title="间接制约"></a>间接制约</h5><h6 id="进程之间共享某种系统资源而形成的相互制约"><a href="#进程之间共享某种系统资源而形成的相互制约" class="headerlink" title="进程之间共享某种系统资源而形成的相互制约"></a>进程之间共享某种系统资源而形成的相互制约</h6><h5 id="直接制约"><a href="#直接制约" class="headerlink" title="直接制约"></a>直接制约</h5><h6 id="进程间由于合作形成的相互制约"><a href="#进程间由于合作形成的相互制约" class="headerlink" title="进程间由于合作形成的相互制约"></a>进程间由于合作形成的相互制约</h6><h4 id="进程两大关系"><a href="#进程两大关系" class="headerlink" title="进程两大关系"></a>进程两大关系</h4><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><h6 id="由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权"><a href="#由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权" class="headerlink" title="由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权"></a>由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权</h6><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><h6 id="多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务"><a href="#多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务" class="headerlink" title="多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务"></a>多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务</h6><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><h5 id="一段时间内只允许一个进程访问的资源"><a href="#一段时间内只允许一个进程访问的资源" class="headerlink" title="一段时间内只允许一个进程访问的资源"></a>一段时间内只允许一个进程访问的资源</h5><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><h5 id="每个进程访问临界资源的那段代码被称为临界区"><a href="#每个进程访问临界资源的那段代码被称为临界区" class="headerlink" title="每个进程访问临界资源的那段代码被称为临界区"></a>每个进程访问临界资源的那段代码被称为临界区</h5><h3 id="2-3-2-基本准则"><a href="#2-3-2-基本准则" class="headerlink" title="2.3.2.     基本准则"></a>2.3.2.     基本准则</h3><h4 id="空闲则入"><a href="#空闲则入" class="headerlink" title="空闲则入"></a>空闲则入</h4><h4 id="忙则等待"><a href="#忙则等待" class="headerlink" title="忙则等待"></a>忙则等待</h4><h4 id="有限等待：不能死等"><a href="#有限等待：不能死等" class="headerlink" title="有限等待：不能死等"></a>有限等待：不能死等</h4><h4 id="让权等待：不能进入临界区的进程要释放CPU"><a href="#让权等待：不能进入临界区的进程要释放CPU" class="headerlink" title="让权等待：不能进入临界区的进程要释放CPU"></a>让权等待：不能进入临界区的进程要释放CPU</h4><h3 id="2-3-3-信号量机制"><a href="#2-3-3-信号量机制" class="headerlink" title="2.3.3.     信号量机制"></a>2.3.3.     信号量机制</h3><h4 id="1、整型信号量机制"><a href="#1、整型信号量机制" class="headerlink" title="1、整型信号量机制"></a>1、整型信号量机制</h4><h5 id="表示资源数目的整型量s和原子操作wait-s-signal-s"><a href="#表示资源数目的整型量s和原子操作wait-s-signal-s" class="headerlink" title="表示资源数目的整型量s和原子操作wait(s)+signal(s)"></a>表示资源数目的整型量s和原子操作wait(s)+signal(s)</h5><h4 id="2、记录型信号量机制"><a href="#2、记录型信号量机制" class="headerlink" title="2、记录型信号量机制"></a>2、记录型信号量机制</h4><h5 id="信号量s"><a href="#信号量s" class="headerlink" title="信号量s"></a>信号量s</h5><h6 id="s-count-处置表示某类资源的数目"><a href="#s-count-处置表示某类资源的数目" class="headerlink" title="s.count:处置表示某类资源的数目"></a>s.count:处置表示某类资源的数目</h6><h6 id="s-queue-阻塞在该信号量的各个进程的PCB链成的队列"><a href="#s-queue-阻塞在该信号量的各个进程的PCB链成的队列" class="headerlink" title="s.queue:阻塞在该信号量的各个进程的PCB链成的队列"></a>s.queue:阻塞在该信号量的各个进程的PCB链成的队列</h6><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><h6 id="wait-–s-count-if-s-count-lt-0-block-s-queue"><a href="#wait-–s-count-if-s-count-lt-0-block-s-queue" class="headerlink" title="wait():–s.count;if(s.count&lt;0) block(s.queue);"></a>wait():–s.count;if(s.count&lt;0) block(s.queue);</h6><h6 id="signal-s-count-if-s-count-lt-0-block-s-queue"><a href="#signal-s-count-if-s-count-lt-0-block-s-queue" class="headerlink" title="signal():++s,count;if(s.count&lt;=0) block(s.queue);"></a>signal():++s,count;if(s.count&lt;=0) block(s.queue);</h6><h4 id="3、AND型信号量"><a href="#3、AND型信号量" class="headerlink" title="3、AND型信号量"></a>3、AND型信号量</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><h6 id="将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放"><a href="#将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放" class="headerlink" title="将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放"></a>将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放</h6><h5 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a>原子操作</h5><h6 id="Swait"><a href="#Swait" class="headerlink" title="Swait()"></a>Swait()</h6><h4 id="4、二进制信号量"><a href="#4、二进制信号量" class="headerlink" title="4、二进制信号量"></a>4、二进制信号量</h4><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><h6 id="S1-1；S2-0；C-代表共享资源的初始值"><a href="#S1-1；S2-0；C-代表共享资源的初始值" class="headerlink" title="S1=1；S2=0；C=代表共享资源的初始值"></a>S1=1；S2=0；C=代表共享资源的初始值</h6><h3 id="2-3-4-信号量的应用"><a href="#2-3-4-信号量的应用" class="headerlink" title="2.3.4.     信号量的应用"></a>2.3.4.     信号量的应用</h3><h4 id="1、信号量实现互斥"><a href="#1、信号量实现互斥" class="headerlink" title="1、信号量实现互斥"></a>1、信号量实现互斥</h4><h5 id="设置互斥信号量mutex，初值为1"><a href="#设置互斥信号量mutex，初值为1" class="headerlink" title="设置互斥信号量mutex，初值为1"></a>设置互斥信号量mutex，初值为1</h5><h6 id="mutex-1，无进程进入临界区"><a href="#mutex-1，无进程进入临界区" class="headerlink" title="mutex=1，无进程进入临界区"></a>mutex=1，无进程进入临界区</h6><h6 id="mutex-0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列"><a href="#mutex-0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列" class="headerlink" title="mutex=0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列"></a>mutex=0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列</h6><h6 id="mutex-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒"><a href="#mutex-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒" class="headerlink" title="mutex=-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒"></a>mutex=-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒</h6><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><h6 id="wait-mutex-；临界区；signal-mutex-；剩余区"><a href="#wait-mutex-；临界区；signal-mutex-；剩余区" class="headerlink" title="wait(mutex)；临界区；signal(mutex)；剩余区"></a>wait(mutex)；临界区；signal(mutex)；剩余区</h6><h4 id="2、信号量实现同步"><a href="#2、信号量实现同步" class="headerlink" title="2、信号量实现同步"></a>2、信号量实现同步</h4><h5 id="为每个前驱关系设置一个信号量"><a href="#为每个前驱关系设置一个信号量" class="headerlink" title="为每个前驱关系设置一个信号量"></a>为每个前驱关系设置一个信号量</h5><h3 id="2-3-5-经典的进程同步问题"><a href="#2-3-5-经典的进程同步问题" class="headerlink" title="2.3.5.     经典的进程同步问题"></a>2.3.5.     经典的进程同步问题</h3><h4 id="1、生产者消费者问题"><a href="#1、生产者消费者问题" class="headerlink" title="1、生产者消费者问题"></a>1、生产者消费者问题</h4><h4 id="2、读者写者问题"><a href="#2、读者写者问题" class="headerlink" title="2、读者写者问题"></a>2、读者写者问题</h4><h4 id="3、哲学家进餐问题"><a href="#3、哲学家进餐问题" class="headerlink" title="3、哲学家进餐问题"></a>3、哲学家进餐问题</h4><h2 id="2-4-进程通信"><a href="#2-4-进程通信" class="headerlink" title="2.4.     进程通信"></a>2.4.     进程通信</h2><h3 id="2-4-1-基本概念：进程之间的信息交换"><a href="#2-4-1-基本概念：进程之间的信息交换" class="headerlink" title="2.4.1.     基本概念：进程之间的信息交换"></a>2.4.1.     基本概念：进程之间的信息交换</h3><h4 id="低级通信"><a href="#低级通信" class="headerlink" title="低级通信"></a>低级通信</h4><h5 id="效率低"><a href="#效率低" class="headerlink" title="效率低"></a>效率低</h5><h5 id="通信对用户不透明"><a href="#通信对用户不透明" class="headerlink" title="通信对用户不透明"></a>通信对用户不透明</h5><h5 id="包括信号量和管程机制"><a href="#包括信号量和管程机制" class="headerlink" title="包括信号量和管程机制"></a>包括信号量和管程机制</h5><h4 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h4><h5 id="指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高"><a href="#指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高" class="headerlink" title="指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高"></a>指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高</h5><h5 id="使用方便；高效地传送大量数据"><a href="#使用方便；高效地传送大量数据" class="headerlink" title="使用方便；高效地传送大量数据"></a>使用方便；高效地传送大量数据</h5><h5 id="包括下面三种系统"><a href="#包括下面三种系统" class="headerlink" title="包括下面三种系统"></a>包括下面三种系统</h5><h3 id="2-4-2-进程通信类型"><a href="#2-4-2-进程通信类型" class="headerlink" title="2.4.2.     进程通信类型"></a>2.4.2.     进程通信类型</h3><h4 id="1、共享存储器系统"><a href="#1、共享存储器系统" class="headerlink" title="1、共享存储器系统"></a>1、共享存储器系统</h4><h5 id="1、共享数据结构"><a href="#1、共享数据结构" class="headerlink" title="1、共享数据结构"></a>1、共享数据结构</h5><h6 id="低级通信-1"><a href="#低级通信-1" class="headerlink" title="低级通信"></a>低级通信</h6><h5 id="2、共享存储区"><a href="#2、共享存储区" class="headerlink" title="2、共享存储区"></a>2、共享存储区</h5><h4 id="2、消息传递系统"><a href="#2、消息传递系统" class="headerlink" title="2、消息传递系统"></a>2、消息传递系统</h4><h5 id="系统提供一组通信原语"><a href="#系统提供一组通信原语" class="headerlink" title="系统提供一组通信原语"></a>系统提供一组通信原语</h5><h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h6><p>发送进程利用OS提供的发送原语把消息之间发送给目标进程</p>
<h6 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h6><p>借助收发进程以外的共享数据结构（比如信箱）作为通信中转</p>
<h4 id="3、管道通信系统"><a href="#3、管道通信系统" class="headerlink" title="3、管道通信系统"></a>3、管道通信系统</h4><h5 id="连接读写进程的一个共享文件，pipe文件"><a href="#连接读写进程的一个共享文件，pipe文件" class="headerlink" title="连接读写进程的一个共享文件，pipe文件"></a>连接读写进程的一个共享文件，pipe文件</h5><h5 id="必须提供的协调能力"><a href="#必须提供的协调能力" class="headerlink" title="必须提供的协调能力"></a>必须提供的协调能力</h5><h6 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h6><h6 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h6><h6 id="确定对方是否存在，只有对方存在才能通信"><a href="#确定对方是否存在，只有对方存在才能通信" class="headerlink" title="确定对方是否存在，只有对方存在才能通信"></a>确定对方是否存在，只有对方存在才能通信</h6><h2 id="2-5-线程Thread简介"><a href="#2-5-线程Thread简介" class="headerlink" title="2.5.     线程Thread简介"></a>2.5.     线程Thread简介</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1.     定义"></a>2.5.1.     定义</h3><h4 id="进程当中的一条执行流程"><a href="#进程当中的一条执行流程" class="headerlink" title="进程当中的一条执行流程"></a>进程当中的一条执行流程</h4><h3 id="2-5-2-属性"><a href="#2-5-2-属性" class="headerlink" title="2.5.2.     属性"></a>2.5.2.     属性</h3><h4 id="1、共享进程资源"><a href="#1、共享进程资源" class="headerlink" title="1、共享进程资源"></a>1、共享进程资源</h4><h4 id="2、轻型实体：每个线程只拥有少量资源"><a href="#2、轻型实体：每个线程只拥有少量资源" class="headerlink" title="2、轻型实体：每个线程只拥有少量资源"></a>2、轻型实体：每个线程只拥有少量资源</h4><h4 id="3、处理机调度的单位"><a href="#3、处理机调度的单位" class="headerlink" title="3、处理机调度的单位"></a>3、处理机调度的单位</h4><h4 id="4、可并发执行"><a href="#4、可并发执行" class="headerlink" title="4、可并发执行"></a>4、可并发执行</h4><h3 id="2-5-3-优缺点"><a href="#2-5-3-优缺点" class="headerlink" title="2.5.3.     优缺点"></a>2.5.3.     优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><h5 id="1、一个进程可对应多个线程"><a href="#1、一个进程可对应多个线程" class="headerlink" title="1、一个进程可对应多个线程"></a>1、一个进程可对应多个线程</h5><h5 id="2、可并发执行"><a href="#2、可并发执行" class="headerlink" title="2、可并发执行"></a>2、可并发执行</h5><h5 id="3、创建和终止时间比进程短"><a href="#3、创建和终止时间比进程短" class="headerlink" title="3、创建和终止时间比进程短"></a>3、创建和终止时间比进程短</h5><h5 id="4、各个线程资源共享，可直接通信不通过OS内核"><a href="#4、各个线程资源共享，可直接通信不通过OS内核" class="headerlink" title="4、各个线程资源共享，可直接通信不通过OS内核"></a>4、各个线程资源共享，可直接通信不通过OS内核</h5><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="一个线程崩溃会导致所属进程的所有线程崩溃"><a href="#一个线程崩溃会导致所属进程的所有线程崩溃" class="headerlink" title="一个线程崩溃会导致所属进程的所有线程崩溃"></a>一个线程崩溃会导致所属进程的所有线程崩溃</h5><h3 id="2-5-4-OS支持线程的方法"><a href="#2-5-4-OS支持线程的方法" class="headerlink" title="2.5.4.     OS支持线程的方法"></a>2.5.4.     OS支持线程的方法</h3><h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><h5 id="1、存在于用户空间，内核不了解"><a href="#1、存在于用户空间，内核不了解" class="headerlink" title="1、存在于用户空间，内核不了解"></a>1、存在于用户空间，内核不了解</h5><h5 id="2、应用进程利用线程库函数来控制用户线程"><a href="#2、应用进程利用线程库函数来控制用户线程" class="headerlink" title="2、应用进程利用线程库函数来控制用户线程"></a>2、应用进程利用线程库函数来控制用户线程</h5><h5 id="3、一个线程阻塞，整个进程等待"><a href="#3、一个线程阻塞，整个进程等待" class="headerlink" title="3、一个线程阻塞，整个进程等待"></a>3、一个线程阻塞，整个进程等待</h5><h5 id="4、时间片分配给进程，线程多了每个线程执行时间相对就少"><a href="#4、时间片分配给进程，线程多了每个线程执行时间相对就少" class="headerlink" title="4、时间片分配给进程，线程多了每个线程执行时间相对就少"></a>4、时间片分配给进程，线程多了每个线程执行时间相对就少</h5><h4 id="2、内核线程"><a href="#2、内核线程" class="headerlink" title="2、内核线程"></a>2、内核线程</h4><h5 id="1、OS支持，负责线程的创建、切换等操作"><a href="#1、OS支持，负责线程的创建、切换等操作" class="headerlink" title="1、OS支持，负责线程的创建、切换等操作"></a>1、OS支持，负责线程的创建、切换等操作</h5><h5 id="2、线程的管理慢于用户级线程"><a href="#2、线程的管理慢于用户级线程" class="headerlink" title="2、线程的管理慢于用户级线程"></a>2、线程的管理慢于用户级线程</h5><h5 id="3、一个线程阻塞，整个进程不会阻塞"><a href="#3、一个线程阻塞，整个进程不会阻塞" class="headerlink" title="3、一个线程阻塞，整个进程不会阻塞"></a>3、一个线程阻塞，整个进程不会阻塞</h5><h4 id="ps：多线程模型"><a href="#ps：多线程模型" class="headerlink" title="ps：多线程模型"></a>ps：多线程模型</h4><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><h1 id="3-三、处理机调度和死锁"><a href="#3-三、处理机调度和死锁" class="headerlink" title="3.    三、处理机调度和死锁"></a>3.    三、处理机调度和死锁</h1><h2 id="3-1-处理机调度算法的层次"><a href="#3-1-处理机调度算法的层次" class="headerlink" title="3.1.     处理机调度算法的层次"></a>3.1.     处理机调度算法的层次</h2><h3 id="3-1-1-高级调度"><a href="#3-1-1-高级调度" class="headerlink" title="3.1.1.     高级调度"></a>3.1.1.     高级调度</h3><h4 id="又称：长程调度或作业调度"><a href="#又称：长程调度或作业调度" class="headerlink" title="又称：长程调度或作业调度"></a>又称：长程调度或作业调度</h4><h4 id="调度对象：作业（用户利用计算机进行一次运行所需工作的集合）"><a href="#调度对象：作业（用户利用计算机进行一次运行所需工作的集合）" class="headerlink" title="调度对象：作业（用户利用计算机进行一次运行所需工作的集合）"></a>调度对象：作业（用户利用计算机进行一次运行所需工作的集合）</h4><h4 id="主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列"><a href="#主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列" class="headerlink" title="主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列"></a>主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列</h4><h4 id="相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度"><a href="#相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度" class="headerlink" title="相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度"></a>相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度</h4><h3 id="3-1-2-低级调度"><a href="#3-1-2-低级调度" class="headerlink" title="3.1.2.     低级调度"></a>3.1.2.     低级调度</h3><h4 id="进程调度或短程调度"><a href="#进程调度或短程调度" class="headerlink" title="进程调度或短程调度"></a>进程调度或短程调度</h4><h5 id="非抢先式调度"><a href="#非抢先式调度" class="headerlink" title="非抢先式调度"></a>非抢先式调度</h5><h6 id="拥有处理机的进程完成或阻塞时才把处理机分配给其他进程"><a href="#拥有处理机的进程完成或阻塞时才把处理机分配给其他进程" class="headerlink" title="拥有处理机的进程完成或阻塞时才把处理机分配给其他进程"></a>拥有处理机的进程完成或阻塞时才把处理机分配给其他进程</h6><h5 id="抢先式调度"><a href="#抢先式调度" class="headerlink" title="抢先式调度"></a>抢先式调度</h5><h6 id="允许暂停拥有处理机的进程，重新分配处理机给另一个进程"><a href="#允许暂停拥有处理机的进程，重新分配处理机给另一个进程" class="headerlink" title="允许暂停拥有处理机的进程，重新分配处理机给另一个进程"></a>允许暂停拥有处理机的进程，重新分配处理机给另一个进程</h6><h6 id="时间片原则；优先权原则"><a href="#时间片原则；优先权原则" class="headerlink" title="时间片原则；优先权原则"></a>时间片原则；优先权原则</h6><h4 id="调度对象：进程（或内核级线程）"><a href="#调度对象：进程（或内核级线程）" class="headerlink" title="调度对象：进程（或内核级线程）"></a>调度对象：进程（或内核级线程）</h4><h4 id="主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）"><a href="#主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）" class="headerlink" title="主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）"></a>主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）</h4><h4 id="相关系统：多道、分时、实时三种类型的OS中，都必须配置"><a href="#相关系统：多道、分时、实时三种类型的OS中，都必须配置" class="headerlink" title="相关系统：多道、分时、实时三种类型的OS中，都必须配置"></a>相关系统：多道、分时、实时三种类型的OS中，都必须配置</h4><h3 id="3-1-3-中级调度"><a href="#3-1-3-中级调度" class="headerlink" title="3.1.3.     中级调度"></a>3.1.3.     中级调度</h3><h4 id="又称：内存调度"><a href="#又称：内存调度" class="headerlink" title="又称：内存调度"></a>又称：内存调度</h4><h4 id="使用目的：提高内存利用率和系统吞吐量"><a href="#使用目的：提高内存利用率和系统吞吐量" class="headerlink" title="使用目的：提高内存利用率和系统吞吐量"></a>使用目的：提高内存利用率和系统吞吐量</h4><h4 id="主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态"><a href="#主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态" class="headerlink" title="主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态"></a>主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态</h4><h2 id="3-2-选择处理机调度方式和算法的准则"><a href="#3-2-选择处理机调度方式和算法的准则" class="headerlink" title="3.2.     选择处理机调度方式和算法的准则"></a>3.2.     选择处理机调度方式和算法的准则</h2><h3 id="3-2-1-面向用户"><a href="#3-2-1-面向用户" class="headerlink" title="3.2.1.     面向用户"></a>3.2.1.     面向用户</h3><h4 id="周转时间短"><a href="#周转时间短" class="headerlink" title="周转时间短"></a>周转时间短</h4><h5 id="批处理系统的重要指标：作业从提交到完成（得到结果）"><a href="#批处理系统的重要指标：作业从提交到完成（得到结果）" class="headerlink" title="批处理系统的重要指标：作业从提交到完成（得到结果）"></a>批处理系统的重要指标：作业从提交到完成（得到结果）</h5><h5 id="平均周转时间：完成时间-提交时间"><a href="#平均周转时间：完成时间-提交时间" class="headerlink" title="平均周转时间：完成时间-提交时间"></a>平均周转时间：完成时间-提交时间</h5><h5 id="平均带权周转时间：平均周转时间-CPU执行时间"><a href="#平均带权周转时间：平均周转时间-CPU执行时间" class="headerlink" title="平均带权周转时间：平均周转时间/CPU执行时间"></a>平均带权周转时间：平均周转时间/CPU执行时间</h5><h4 id="响应时间快"><a href="#响应时间快" class="headerlink" title="响应时间快"></a>响应时间快</h4><h5 id="分时系统的重要指标：输入请求到系统给出首次响应的时间"><a href="#分时系统的重要指标：输入请求到系统给出首次响应的时间" class="headerlink" title="分时系统的重要指标：输入请求到系统给出首次响应的时间"></a>分时系统的重要指标：输入请求到系统给出首次响应的时间</h5><h4 id="保证截止时间"><a href="#保证截止时间" class="headerlink" title="保证截止时间"></a>保证截止时间</h4><h5 id="实时系统的重要指标：开始截止时间和完成截止时间"><a href="#实时系统的重要指标：开始截止时间和完成截止时间" class="headerlink" title="实时系统的重要指标：开始截止时间和完成截止时间"></a>实时系统的重要指标：开始截止时间和完成截止时间</h5><h4 id="优先权原则"><a href="#优先权原则" class="headerlink" title="优先权原则"></a>优先权原则</h4><h5 id="批处理、分时、实时系统都可遵循"><a href="#批处理、分时、实时系统都可遵循" class="headerlink" title="批处理、分时、实时系统都可遵循"></a>批处理、分时、实时系统都可遵循</h5><h5 id="公平性：不因为作业或进程本身特性而使上述指标恶化。"><a href="#公平性：不因为作业或进程本身特性而使上述指标恶化。" class="headerlink" title="公平性：不因为作业或进程本身特性而使上述指标恶化。"></a>公平性：不因为作业或进程本身特性而使上述指标恶化。</h5><h3 id="3-2-2-面向系统"><a href="#3-2-2-面向系统" class="headerlink" title="3.2.2.     面向系统"></a>3.2.2.     面向系统</h3><h4 id="系统吞吐量高"><a href="#系统吞吐量高" class="headerlink" title="系统吞吐量高"></a>系统吞吐量高</h4><h5 id="批处理系统的重要指标"><a href="#批处理系统的重要指标" class="headerlink" title="批处理系统的重要指标"></a>批处理系统的重要指标</h5><h5 id="吞吐量：单位时间内所完成的作业数"><a href="#吞吐量：单位时间内所完成的作业数" class="headerlink" title="吞吐量：单位时间内所完成的作业数"></a>吞吐量：单位时间内所完成的作业数</h5><h4 id="处理机利用率高"><a href="#处理机利用率高" class="headerlink" title="处理机利用率高"></a>处理机利用率高</h4><h4 id="资源的平衡利用"><a href="#资源的平衡利用" class="headerlink" title="资源的平衡利用"></a>资源的平衡利用</h4><h3 id="3-2-3-调度算法本身的调度性能准则"><a href="#3-2-3-调度算法本身的调度性能准则" class="headerlink" title="3.2.3.     调度算法本身的调度性能准则"></a>3.2.3.     调度算法本身的调度性能准则</h3><h4 id="易于实现"><a href="#易于实现" class="headerlink" title="易于实现"></a>易于实现</h4><h4 id="执行开销比"><a href="#执行开销比" class="headerlink" title="执行开销比"></a>执行开销比</h4><h2 id="3-3-调度算法"><a href="#3-3-调度算法" class="headerlink" title="3.3.     调度算法"></a>3.3.     调度算法</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1.     定义"></a>3.3.1.     定义</h3><h4 id="根据系统的资源分配策略所规定的资源分配算法"><a href="#根据系统的资源分配策略所规定的资源分配算法" class="headerlink" title="根据系统的资源分配策略所规定的资源分配算法"></a>根据系统的资源分配策略所规定的资源分配算法</h4><h3 id="3-3-2-分类"><a href="#3-3-2-分类" class="headerlink" title="3.3.2.     分类"></a>3.3.2.     分类</h3><h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。"><a href="#按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。" class="headerlink" title="按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。"></a>按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。</h6><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><h6 id="利于长作业而不利于短作业"><a href="#利于长作业而不利于短作业" class="headerlink" title="利于长作业而不利于短作业"></a>利于长作业而不利于短作业</h6><h6 id="利于CPU繁忙的作业而不利于I-O繁忙的作业"><a href="#利于CPU繁忙的作业而不利于I-O繁忙的作业" class="headerlink" title="利于CPU繁忙的作业而不利于I/O繁忙的作业"></a>利于CPU繁忙的作业而不利于I/O繁忙的作业</h6><h4 id="短作业（进程）优先调度算法（SJF-SPF）"><a href="#短作业（进程）优先调度算法（SJF-SPF）" class="headerlink" title="短作业（进程）优先调度算法（SJF/SPF）"></a>短作业（进程）优先调度算法（SJF/SPF）</h4><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式"><a href="#对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式" class="headerlink" title="对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式"></a>对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式</h6><h6 id="对FCFS的改进，目标减少平均周转时间"><a href="#对FCFS的改进，目标减少平均周转时间" class="headerlink" title="对FCFS的改进，目标减少平均周转时间"></a>对FCFS的改进，目标减少平均周转时间</h6><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><p>比FCFS改善平均周转时间和平均带权周转时间</p>
<p>提高系统吞吐量</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>对长作业非常不利</p>
<p>未能根据作业的紧迫程度来划分执行的优先级</p>
<p>不能准确估计作业的执行时间，从而影响调度性能</p>
<h5 id="变型"><a href="#变型" class="headerlink" title="变型"></a>变型</h5><h6 id="最短剩余时间优先（SRT）"><a href="#最短剩余时间优先（SRT）" class="headerlink" title="最短剩余时间优先（SRT）"></a>最短剩余时间优先（SRT）</h6><p>允许抢占</p>
<h6 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h6><p>响应比=（等待时间+要求执行时间）/要求执行时间</p>
<p>FCFS和SJF的折衷</p>
<h4 id="优先权调度算法"><a href="#优先权调度算法" class="headerlink" title="优先权调度算法"></a>优先权调度算法</h4><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h6><p>算法用于作业调度时，系统从后备队列中选择优先权最高的作业装入内存</p>
<h6 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h6><p>算法用于进程调度时，系统从就绪队列中选择优先权最高的作业派发处理机</p>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><p>抢占式和非抢占式，可抢占程度越高，对实时系统满足度越好</p>
<h5 id="优先权类型"><a href="#优先权类型" class="headerlink" title="优先权类型"></a>优先权类型</h5><h6 id="静态优先级"><a href="#静态优先级" class="headerlink" title="静态优先级"></a>静态优先级</h6><p>概念</p>
<p>依据进程类型、对资源需求、用户要求等在创建进程使就确定进程优先级，直到进程终止前都不改变</p>
<p>特点</p>
<p>简单，系统开销小</p>
<p>不精确，仅在要求不高的系统中使用</p>
<h6 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h6><p>概念</p>
<p>在创建时赋予的优先级可以在运行时改变，以便获得更好的调度性能</p>
<h5 id="高响应比优先调度算法（HRRN）"><a href="#高响应比优先调度算法（HRRN）" class="headerlink" title="高响应比优先调度算法（HRRN）"></a>高响应比优先调度算法（HRRN）</h5><h6 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h6><p>服务时间越短/等待时间越长，优先级越高</p>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>响应比的计算增加系统开销</p>
<h6 id="响应比-（等待时间-要求执行时间）-要求执行时间"><a href="#响应比-（等待时间-要求执行时间）-要求执行时间" class="headerlink" title="响应比=（等待时间+要求执行时间）/要求执行时间"></a>响应比=（等待时间+要求执行时间）/要求执行时间</h6><h4 id="时间片轮转法（RR）"><a href="#时间片轮转法（RR）" class="headerlink" title="时间片轮转法（RR）"></a>时间片轮转法（RR）</h4><h5 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个"><a href="#就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个" class="headerlink" title="就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个"></a>就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个</h6><h6 id="设计目标：提高资源利用率"><a href="#设计目标：提高资源利用率" class="headerlink" title="设计目标：提高资源利用率"></a>设计目标：提高资源利用率</h6><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><h6 id="时间片长度的影响"><a href="#时间片长度的影响" class="headerlink" title="时间片长度的影响"></a>时间片长度的影响</h6><p>太长：退化为FCFS</p>
<p>太短：响应时间长</p>
<h6 id="就绪进程越多，时间片越小"><a href="#就绪进程越多，时间片越小" class="headerlink" title="就绪进程越多，时间片越小"></a>就绪进程越多，时间片越小</h6><h6 id="系统的处理能力应当使用户输入通常在一个时间片内能处理完"><a href="#系统的处理能力应当使用户输入通常在一个时间片内能处理完" class="headerlink" title="系统的处理能力应当使用户输入通常在一个时间片内能处理完"></a>系统的处理能力应当使用户输入通常在一个时间片内能处理完</h6><h4 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h4><h5 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长"><a href="#设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长" class="headerlink" title="设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长"></a>设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长</h6><h6 id="当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降"><a href="#当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降" class="headerlink" title="当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降"></a>当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降</h6><h6 id="较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾"><a href="#较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾" class="headerlink" title="较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾"></a>较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</h6><h5 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h5><h6 id="终端型进程（I-O）"><a href="#终端型进程（I-O）" class="headerlink" title="终端型进程（I/O）"></a>终端型进程（I/O）</h6><p>最高优先级</p>
<h6 id="计算型进程（长批处理作业）"><a href="#计算型进程（长批处理作业）" class="headerlink" title="计算型进程（长批处理作业）"></a>计算型进程（长批处理作业）</h6><p>每次执行完时间片降低优先级</p>
<h6 id="短批处理作业"><a href="#短批处理作业" class="headerlink" title="短批处理作业"></a>短批处理作业</h6><p>先放入最高级，一般1-2级完成</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><h6 id="为提高I-O资源利用率和缩短响应时间照顾I-O型进程"><a href="#为提高I-O资源利用率和缩短响应时间照顾I-O型进程" class="headerlink" title="为提高I/O资源利用率和缩短响应时间照顾I/O型进程"></a>为提高I/O资源利用率和缩短响应时间照顾I/O型进程</h6><h6 id="为提高系统吞吐量和缩短平均周转时间而照顾短进程"><a href="#为提高系统吞吐量和缩短平均周转时间而照顾短进程" class="headerlink" title="为提高系统吞吐量和缩短平均周转时间而照顾短进程"></a>为提高系统吞吐量和缩短平均周转时间而照顾短进程</h6><h6 id="不用估计进程执行时间，动态调节"><a href="#不用估计进程执行时间，动态调节" class="headerlink" title="不用估计进程执行时间，动态调节"></a>不用估计进程执行时间，动态调节</h6><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4.     实时调度"></a>3.4.     实时调度</h2><h3 id="3-4-1-基本条件"><a href="#3-4-1-基本条件" class="headerlink" title="3.4.1.     基本条件"></a>3.4.1.     基本条件</h3><h4 id="1、提供必要信息"><a href="#1、提供必要信息" class="headerlink" title="1、提供必要信息"></a>1、提供必要信息</h4><h5 id="就绪时间"><a href="#就绪时间" class="headerlink" title="就绪时间"></a>就绪时间</h5><h5 id="开始截止时间-结束截止时间"><a href="#开始截止时间-结束截止时间" class="headerlink" title="开始截止时间+结束截止时间"></a>开始截止时间+结束截止时间</h5><h5 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h5><h5 id="资源要求"><a href="#资源要求" class="headerlink" title="资源要求"></a>资源要求</h5><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><h4 id="2、系统处理能力强"><a href="#2、系统处理能力强" class="headerlink" title="2、系统处理能力强"></a>2、系统处理能力强</h4><h5 id="单处理机"><a href="#单处理机" class="headerlink" title="单处理机"></a>单处理机</h5><h6 id="处理时间Ci-周期时间Pi之和-lt-1"><a href="#处理时间Ci-周期时间Pi之和-lt-1" class="headerlink" title="处理时间Ci/周期时间Pi之和&lt;=1"></a>处理时间Ci/周期时间Pi之和&lt;=1</h6><h5 id="多处理机"><a href="#多处理机" class="headerlink" title="多处理机"></a>多处理机</h5><h6 id="处理时间Ci-周期时间Pi之和-lt-N"><a href="#处理时间Ci-周期时间Pi之和-lt-N" class="headerlink" title="处理时间Ci/周期时间Pi之和&lt;=N"></a>处理时间Ci/周期时间Pi之和&lt;=N</h6><h4 id="3、抢占式调度机制"><a href="#3、抢占式调度机制" class="headerlink" title="3、抢占式调度机制"></a>3、抢占式调度机制</h4><h4 id="4、快速切换机制"><a href="#4、快速切换机制" class="headerlink" title="4、快速切换机制"></a>4、快速切换机制</h4><h5 id="对外部中断快速响应"><a href="#对外部中断快速响应" class="headerlink" title="对外部中断快速响应"></a>对外部中断快速响应</h5><h5 id="快速任务分配"><a href="#快速任务分配" class="headerlink" title="快速任务分配"></a>快速任务分配</h5><h3 id="3-4-2-分类"><a href="#3-4-2-分类" class="headerlink" title="3.4.2.     分类"></a>3.4.2.     分类</h3><h4 id="1、非抢占式调度算法"><a href="#1、非抢占式调度算法" class="headerlink" title="1、非抢占式调度算法"></a>1、非抢占式调度算法</h4><h5 id="1、非抢占式轮转调度算法：同RR"><a href="#1、非抢占式轮转调度算法：同RR" class="headerlink" title="1、非抢占式轮转调度算法：同RR"></a>1、非抢占式轮转调度算法：同RR</h5><h5 id="2、非抢占式优先调度算法：严格按优先级"><a href="#2、非抢占式优先调度算法：严格按优先级" class="headerlink" title="2、非抢占式优先调度算法：严格按优先级"></a>2、非抢占式优先调度算法：严格按优先级</h5><h4 id="2、抢占式调度算法"><a href="#2、抢占式调度算法" class="headerlink" title="2、抢占式调度算法"></a>2、抢占式调度算法</h4><h5 id="1、基于时钟中断的抢占式优先权调度算法"><a href="#1、基于时钟中断的抢占式优先权调度算法" class="headerlink" title="1、基于时钟中断的抢占式优先权调度算法"></a>1、基于时钟中断的抢占式优先权调度算法</h5><h6 id="优先级低于当前任务就等待"><a href="#优先级低于当前任务就等待" class="headerlink" title="优先级低于当前任务就等待"></a>优先级低于当前任务就等待</h6><h5 id="2、立即抢占"><a href="#2、立即抢占" class="headerlink" title="2、立即抢占"></a>2、立即抢占</h5><h6 id="立即响应外部中断"><a href="#立即响应外部中断" class="headerlink" title="立即响应外部中断"></a>立即响应外部中断</h6><h3 id="3-4-3-常用实时调度算法"><a href="#3-4-3-常用实时调度算法" class="headerlink" title="3.4.3.     常用实时调度算法"></a>3.4.3.     常用实时调度算法</h3><h4 id="1、最早截止时间优先（EDF）"><a href="#1、最早截止时间优先（EDF）" class="headerlink" title="1、最早截止时间优先（EDF）"></a>1、最早截止时间优先（EDF）</h4><h5 id="抢占-非抢占都可"><a href="#抢占-非抢占都可" class="headerlink" title="抢占/非抢占都可"></a>抢占/非抢占都可</h5><h6 id="子主题"><a href="#子主题" class="headerlink" title="子主题"></a>子主题</h6><h5 id="非抢占式调度方式-gt-非周期实时任务；抢占式调度方式-gt-周期实时任务"><a href="#非抢占式调度方式-gt-非周期实时任务；抢占式调度方式-gt-周期实时任务" class="headerlink" title="非抢占式调度方式-&gt;非周期实时任务；抢占式调度方式-&gt;周期实时任务"></a>非抢占式调度方式-&gt;非周期实时任务；抢占式调度方式-&gt;周期实时任务</h5><h4 id="2、最低松弛度优先算法（LLF）"><a href="#2、最低松弛度优先算法（LLF）" class="headerlink" title="2、最低松弛度优先算法（LLF）"></a>2、最低松弛度优先算法（LLF）</h4><h5 id="主要可抢占"><a href="#主要可抢占" class="headerlink" title="主要可抢占"></a>主要可抢占</h5><h5 id="松弛度越低（紧急度越高），优先级越高"><a href="#松弛度越低（紧急度越高），优先级越高" class="headerlink" title="松弛度越低（紧急度越高），优先级越高"></a>松弛度越低（紧急度越高），优先级越高</h5><h5 id="松弛度-必须完成时间-本身运行时间-当前时间"><a href="#松弛度-必须完成时间-本身运行时间-当前时间" class="headerlink" title="松弛度=必须完成时间-本身运行时间-当前时间"></a>松弛度=必须完成时间-本身运行时间-当前时间</h5><h2 id="3-5-死锁"><a href="#3-5-死锁" class="headerlink" title="3.5.     死锁"></a>3.5.     死锁</h2><h3 id="3-5-1-概念"><a href="#3-5-1-概念" class="headerlink" title="3.5.1.     概念"></a>3.5.1.     概念</h3><h4 id="多个进程争夺资源造成的僵局"><a href="#多个进程争夺资源造成的僵局" class="headerlink" title="多个进程争夺资源造成的僵局"></a>多个进程争夺资源造成的僵局</h4><h3 id="3-5-2-死锁起因"><a href="#3-5-2-死锁起因" class="headerlink" title="3.5.2.     死锁起因"></a>3.5.2.     死锁起因</h3><h4 id="竞争资源"><a href="#竞争资源" class="headerlink" title="竞争资源"></a>竞争资源</h4><h5 id="概念：资源数目不能满足进程需要"><a href="#概念：资源数目不能满足进程需要" class="headerlink" title="概念：资源数目不能满足进程需要"></a>概念：资源数目不能满足进程需要</h5><h5 id="竞争不可抢占性资源-临时性资源"><a href="#竞争不可抢占性资源-临时性资源" class="headerlink" title="竞争不可抢占性资源/临时性资源"></a>竞争不可抢占性资源/临时性资源</h5><h4 id="顺序不当"><a href="#顺序不当" class="headerlink" title="顺序不当"></a>顺序不当</h4><h5 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h5><h3 id="3-5-3-产生死锁的必要条件（同时满足）"><a href="#3-5-3-产生死锁的必要条件（同时满足）" class="headerlink" title="3.5.3.     产生死锁的必要条件（同时满足）"></a>3.5.3.     产生死锁的必要条件（同时满足）</h3><h4 id="1、互斥：任一个时刻只允许一个进程使用资源"><a href="#1、互斥：任一个时刻只允许一个进程使用资源" class="headerlink" title="1、互斥：任一个时刻只允许一个进程使用资源"></a>1、互斥：任一个时刻只允许一个进程使用资源</h4><h4 id="2、请求和保持：进程保持了至少一个资源，但又请求新的资源"><a href="#2、请求和保持：进程保持了至少一个资源，但又请求新的资源" class="headerlink" title="2、请求和保持：进程保持了至少一个资源，但又请求新的资源"></a>2、请求和保持：进程保持了至少一个资源，但又请求新的资源</h4><h4 id="3、不可抢占：已占用资源不可被抢占"><a href="#3、不可抢占：已占用资源不可被抢占" class="headerlink" title="3、不可抢占：已占用资源不可被抢占"></a>3、不可抢占：已占用资源不可被抢占</h4><h4 id="4、环路等待"><a href="#4、环路等待" class="headerlink" title="4、环路等待"></a>4、环路等待</h4><h3 id="3-5-4-处理死锁方法"><a href="#3-5-4-处理死锁方法" class="headerlink" title="3.5.4.     处理死锁方法"></a>3.5.4.     处理死锁方法</h3><h4 id="1、预防死锁"><a href="#1、预防死锁" class="headerlink" title="1、预防死锁"></a>1、预防死锁</h4><h5 id="概念：限制并发进程对资源的请求，使之不同时满足四个条件"><a href="#概念：限制并发进程对资源的请求，使之不同时满足四个条件" class="headerlink" title="概念：限制并发进程对资源的请求，使之不同时满足四个条件"></a>概念：限制并发进程对资源的请求，使之不同时满足四个条件</h5><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><h6 id="1、摒弃”请求保持“"><a href="#1、摒弃”请求保持“" class="headerlink" title="1、摒弃”请求保持“"></a>1、摒弃”请求保持“</h6><p>预先静态分配法：预先分配全部资源，保证不等待</p>
<p>优点：简单、安全、容易实现</p>
<p>缺点：资源被严重浪费，降低了资源利用率，较低进程并发程度；有可能无法预先知道所有资源</p>
<h6 id="2、摒弃”不可剥夺“"><a href="#2、摒弃”不可剥夺“" class="headerlink" title="2、摒弃”不可剥夺“"></a>2、摒弃”不可剥夺“</h6><p>进程保持了至少一个资源，但又请求新的资源但没得到满足时。立即释放所持有的资源</p>
<p>缺点</p>
<p>实现复杂，要付出代价</p>
<p>重复申请释放资源，降低系统吞吐率</p>
<h6 id="3、摒弃”环路等待“"><a href="#3、摒弃”环路等待“" class="headerlink" title="3、摒弃”环路等待“"></a>3、摒弃”环路等待“</h6><p>有序资源使用法：资源分类按顺序排列，进程按顺序请求</p>
<p>缺点：</p>
<p>资源序号固定，限制新设备增加</p>
<p>降低资源利用率</p>
<p>限制用户简单自主的编程</p>
<h4 id="2、避免死锁"><a href="#2、避免死锁" class="headerlink" title="2、避免死锁"></a>2、避免死锁</h4><h5 id="概念：资源动态分配过程中，防止系统进入不安全状态"><a href="#概念：资源动态分配过程中，防止系统进入不安全状态" class="headerlink" title="概念：资源动态分配过程中，防止系统进入不安全状态"></a>概念：资源动态分配过程中，防止系统进入不安全状态</h5><h5 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h5><h6 id="按照安全序列为进程分配资源使每个进程都可以顺利完成"><a href="#按照安全序列为进程分配资源使每个进程都可以顺利完成" class="headerlink" title="按照安全序列为进程分配资源使每个进程都可以顺利完成"></a>按照安全序列为进程分配资源使每个进程都可以顺利完成</h6><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><h6 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h6><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p>允许互斥、部分分配和不可抢占，可提高资源利用率</p>
<p>要求事先说明最大资源要求，在现实中很困难</p>
<h4 id="3、检测死锁"><a href="#3、检测死锁" class="headerlink" title="3、检测死锁"></a>3、检测死锁</h4><h5 id="概念：允许系统进入死锁，但及时检测"><a href="#概念：允许系统进入死锁，但及时检测" class="headerlink" title="概念：允许系统进入死锁，但及时检测"></a>概念：允许系统进入死锁，但及时检测</h5><h5 id="死锁定理："><a href="#死锁定理：" class="headerlink" title="死锁定理："></a>死锁定理：</h5><h6 id="S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程"><a href="#S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程" class="headerlink" title="S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程"></a>S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程</h6><h6 id="资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤"><a href="#资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤" class="headerlink" title="资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤"></a>资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤</h6><h5 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h5><h5 id="死锁检测算法的应用"><a href="#死锁检测算法的应用" class="headerlink" title="死锁检测算法的应用"></a>死锁检测算法的应用</h5><h4 id="4、解除死锁"><a href="#4、解除死锁" class="headerlink" title="4、解除死锁"></a>4、解除死锁</h4><h5 id="概念：检测到死锁，采取措施解除"><a href="#概念：检测到死锁，采取措施解除" class="headerlink" title="概念：检测到死锁，采取措施解除"></a>概念：检测到死锁，采取措施解除</h5><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><p>1、终止所有死锁进程，代价大、容易实现</p>
<p>2、一次只终止一个进程直到消除环路</p>
<h6 id="剥夺资源"><a href="#剥夺资源" class="headerlink" title="剥夺资源"></a>剥夺资源</h6><p>选择一个牺牲者：代价最小</p>
<p>后退：退回到安全状态，重新启动进程/完全回滚，终止进程后重新开始</p>
<p>饿死：避免某进程”饿死“，增加一个元素：做牺牲品的次数</p>
<h1 id="4-四、存储器管理"><a href="#4-四、存储器管理" class="headerlink" title="4.    四、存储器管理"></a>4.    四、存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1.     存储器的层次结构"></a>4.1.     存储器的层次结构</h2><h3 id="4-1-1-存储管理概念"><a href="#4-1-1-存储管理概念" class="headerlink" title="4.1.1.     存储管理概念"></a>4.1.1.     存储管理概念</h3><h4 id="OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存"><a href="#OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存" class="headerlink" title="OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存"></a>OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存</h4><h4 id="可执行存储器：寄存器-主存"><a href="#可执行存储器：寄存器-主存" class="headerlink" title="可执行存储器：寄存器+主存"></a>可执行存储器：寄存器+主存</h4><h3 id="4-1-2-层次结构"><a href="#4-1-2-层次结构" class="headerlink" title="4.1.2.     层次结构"></a>4.1.2.     层次结构</h3><h4 id="CPU寄存器"><a href="#CPU寄存器" class="headerlink" title="CPU寄存器"></a>CPU寄存器</h4><h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><h6 id="CPU访问速度最快"><a href="#CPU访问速度最快" class="headerlink" title="CPU访问速度最快"></a>CPU访问速度最快</h6><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><h5 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h5><h6 id="备份主存常用数据；减少对主存访问速度"><a href="#备份主存常用数据；减少对主存访问速度" class="headerlink" title="备份主存常用数据；减少对主存访问速度"></a>备份主存常用数据；减少对主存访问速度</h6><h5 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h5><h6 id="保存进程运行时程序和数据，速度远低于处理机执行"><a href="#保存进程运行时程序和数据，速度远低于处理机执行" class="headerlink" title="保存进程运行时程序和数据，速度远低于处理机执行"></a>保存进程运行时程序和数据，速度远低于处理机执行</h6><h5 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h5><h6 id="备份磁盘常用数据，不是独立的存储器（是主存的部分空间）"><a href="#备份磁盘常用数据，不是独立的存储器（是主存的部分空间）" class="headerlink" title="备份磁盘常用数据，不是独立的存储器（是主存的部分空间）"></a>备份磁盘常用数据，不是独立的存储器（是主存的部分空间）</h6><h4 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h4><h5 id="固定磁盘"><a href="#固定磁盘" class="headerlink" title="固定磁盘"></a>固定磁盘</h5><h5 id="可移动存储介质"><a href="#可移动存储介质" class="headerlink" title="可移动存储介质"></a>可移动存储介质</h5><h2 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2.     程序的装入和链接"></a>4.2.     程序的装入和链接</h2><h3 id="4-2-1-程序的处理步骤"><a href="#4-2-1-程序的处理步骤" class="headerlink" title="4.2.1.     程序的处理步骤"></a>4.2.1.     程序的处理步骤</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><h5 id="由编译程序将源程序-cpp-asm-编译成目标模块-obj"><a href="#由编译程序将源程序-cpp-asm-编译成目标模块-obj" class="headerlink" title="由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)"></a>由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)</h5><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="由链接程序把目标模块-obj-和它们所需要的库函数链接在一起形成装入模块-EXE-DLL"><a href="#由链接程序把目标模块-obj-和它们所需要的库函数链接在一起形成装入模块-EXE-DLL" class="headerlink" title="由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE/DLL)"></a>由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE/DLL)</h5><h4 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h4><h5 id="由装入程序将装入模块-EXE-DLL-装入内存-成为进程"><a href="#由装入程序将装入模块-EXE-DLL-装入内存-成为进程" class="headerlink" title="由装入程序将装入模块(EXE/DLL)装入内存,成为进程"></a>由装入程序将装入模块(EXE/DLL)装入内存,成为进程</h5><h3 id="4-2-2-程序的装入"><a href="#4-2-2-程序的装入" class="headerlink" title="4.2.2.     程序的装入"></a>4.2.2.     程序的装入</h3><h4 id="1、绝对装入"><a href="#1、绝对装入" class="headerlink" title="1、绝对装入"></a>1、绝对装入</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><h6 id="编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码"><a href="#编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码" class="headerlink" title="编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码"></a>编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码</h6><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><p>装入过程简单</p>
<h6 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h6><p>依赖硬件结构，适用于单道而不适用于多道程序</p>
<h4 id="2、可重定位装入"><a href="#2、可重定位装入" class="headerlink" title="2、可重定位装入"></a>2、可重定位装入</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><h6 id="装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量"><a href="#装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量" class="headerlink" title="装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量"></a>装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量</h6><h6 id="地址变换装入时一次完成，进程不再移动，故称为静态重定位"><a href="#地址变换装入时一次完成，进程不再移动，故称为静态重定位" class="headerlink" title="地址变换装入时一次完成，进程不再移动，故称为静态重定位"></a>地址变换装入时一次完成，进程不再移动，故称为静态重定位</h6><h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h6><p>不需要硬件支持，可放入多道程序</p>
<h6 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h6><p>一个程序装入需要连续的内存空间，装入后不能移动，不易共享</p>
<h4 id="3、动态运行时装入"><a href="#3、动态运行时装入" class="headerlink" title="3、动态运行时装入"></a>3、动态运行时装入</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><h6 id="进程开始执行时部分装入，运行时需要哪个装哪个"><a href="#进程开始执行时部分装入，运行时需要哪个装哪个" class="headerlink" title="进程开始执行时部分装入，运行时需要哪个装哪个"></a>进程开始执行时部分装入，运行时需要哪个装哪个</h6><h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h6><p>可以将一个程序分散在不连续的内存空间中，可以移动，有利于共享</p>
<p>支持程序执行中的地址引用，比如指针变量</p>
<h6 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h6><p>需要硬件支持（通常指CPU），OS实现复杂，是虚拟存储的基础</p>
<h3 id="4-2-3-程序的链接"><a href="#4-2-3-程序的链接" class="headerlink" title="4.2.3.     程序的链接"></a>4.2.3.     程序的链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><h6 id="程序运行前把目标模块和库函数直接链接，以后不再拆开"><a href="#程序运行前把目标模块和库函数直接链接，以后不再拆开" class="headerlink" title="程序运行前把目标模块和库函数直接链接，以后不再拆开"></a>程序运行前把目标模块和库函数直接链接，以后不再拆开</h6><h6 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h6><p>修改相对地址；变换外部调用符号</p>
<h5 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h6><p>简单易操作</p>
<h6 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h6><p>多用户、多任务冗余（库函数重复）</p>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><h6 id="边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址"><a href="#边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址" class="headerlink" title="边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址"></a>边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址</h6><h5 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h6><p>共享：多个进程共享一个模块</p>
<p>便于修改更新</p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><h5 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h5><h6 id="将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上"><a href="#将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上" class="headerlink" title="将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上"></a>将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上</h6><h5 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h6><p>部分装入</p>
<p>局部代码修改</p>
<p>便于适应运行环境</p>
<h6 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h6><p>链接开销</p>
<p>管理开销</p>
<h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3.     连续分配存储管理方式"></a>4.3.     连续分配存储管理方式</h2><h3 id="4-3-1-单一连续分配"><a href="#4-3-1-单一连续分配" class="headerlink" title="4.3.1.     单一连续分配"></a>4.3.1.     单一连续分配</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><h5 id="内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间"><a href="#内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间" class="headerlink" title="内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间"></a>内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间</h5><h4 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h5><h6 id="最简单，适用于单用户、单任务，易于管理"><a href="#最简单，适用于单用户、单任务，易于管理" class="headerlink" title="最简单，适用于单用户、单任务，易于管理"></a>最简单，适用于单用户、单任务，易于管理</h6><h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><h6 id="不常用的进程也占用内存"><a href="#不常用的进程也占用内存" class="headerlink" title="不常用的进程也占用内存"></a>不常用的进程也占用内存</h6><h6 id="对要求内存空间少的进程，造成内存浪费"><a href="#对要求内存空间少的进程，造成内存浪费" class="headerlink" title="对要求内存空间少的进程，造成内存浪费"></a>对要求内存空间少的进程，造成内存浪费</h6><h3 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2.     固定分区分配"></a>4.3.2.     固定分区分配</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><h5 id="划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）"><a href="#划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）" class="headerlink" title="划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）"></a>划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）</h5><h4 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h5><h6 id="易于实现，开销小"><a href="#易于实现，开销小" class="headerlink" title="易于实现，开销小"></a>易于实现，开销小</h6><h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h5><h6 id="内碎片浪费，分区总数固定，限制了并发执行的程序数目"><a href="#内碎片浪费，分区总数固定，限制了并发执行的程序数目" class="headerlink" title="内碎片浪费，分区总数固定，限制了并发执行的程序数目"></a>内碎片浪费，分区总数固定，限制了并发执行的程序数目</h6><h4 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h4><h5 id="分区之内未利用空间"><a href="#分区之内未利用空间" class="headerlink" title="分区之内未利用空间"></a>分区之内未利用空间</h5><h4 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h4><h5 id="分区之间空闲分区（通常是小空闲分区）"><a href="#分区之间空闲分区（通常是小空闲分区）" class="headerlink" title="分区之间空闲分区（通常是小空闲分区）"></a>分区之间空闲分区（通常是小空闲分区）</h5><h3 id="4-3-3-动态分区分配"><a href="#4-3-3-动态分区分配" class="headerlink" title="4.3.3.     动态分区分配"></a>4.3.3.     动态分区分配</h3><h4 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h4><h5 id="OS根据进程的实际需要为各进程分配连续的内存空间"><a href="#OS根据进程的实际需要为各进程分配连续的内存空间" class="headerlink" title="OS根据进程的实际需要为各进程分配连续的内存空间"></a>OS根据进程的实际需要为各进程分配连续的内存空间</h5><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="1、空闲分区表"><a href="#1、空闲分区表" class="headerlink" title="1、空闲分区表"></a>1、空闲分区表</h5><h5 id="2、空闲分区链表"><a href="#2、空闲分区链表" class="headerlink" title="2、空闲分区链表"></a>2、空闲分区链表</h5><h4 id="动态分区算法分类"><a href="#动态分区算法分类" class="headerlink" title="动态分区算法分类"></a>动态分区算法分类</h4><h5 id="1、首次适应算法（first-fit）"><a href="#1、首次适应算法（first-fit）" class="headerlink" title="1、首次适应算法（first-fit）"></a>1、首次适应算法（first-fit）</h5><h6 id="概念：按分区先后次序查找"><a href="#概念：按分区先后次序查找" class="headerlink" title="概念：按分区先后次序查找"></a>概念：按分区先后次序查找</h6><h6 id="优点：分配和释放时间性能较好，空闲分区多分布在内存高端"><a href="#优点：分配和释放时间性能较好，空闲分区多分布在内存高端" class="headerlink" title="优点：分配和释放时间性能较好，空闲分区多分布在内存高端"></a>优点：分配和释放时间性能较好，空闲分区多分布在内存高端</h6><h6 id="缺点：查找时间会逐渐增大"><a href="#缺点：查找时间会逐渐增大" class="headerlink" title="缺点：查找时间会逐渐增大"></a>缺点：查找时间会逐渐增大</h6><h5 id="2、循环首次适应算法（next-fit）"><a href="#2、循环首次适应算法（next-fit）" class="headerlink" title="2、循环首次适应算法（next-fit）"></a>2、循环首次适应算法（next-fit）</h5><h6 id="概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针"><a href="#概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针" class="headerlink" title="概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针"></a>概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针</h6><h6 id="优点：分配和释放时间性能较好，空闲分区分布均匀"><a href="#优点：分配和释放时间性能较好，空闲分区分布均匀" class="headerlink" title="优点：分配和释放时间性能较好，空闲分区分布均匀"></a>优点：分配和释放时间性能较好，空闲分区分布均匀</h6><h6 id="缺点：较大的空闲分区不宜保留"><a href="#缺点：较大的空闲分区不宜保留" class="headerlink" title="缺点：较大的空闲分区不宜保留"></a>缺点：较大的空闲分区不宜保留</h6><h5 id="3、最佳适应算法（best-fit）"><a href="#3、最佳适应算法（best-fit）" class="headerlink" title="3、最佳适应算法（best-fit）"></a>3、最佳适应算法（best-fit）</h5><h6 id="概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区"><a href="#概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区" class="headerlink" title="概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区"></a>概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区</h6><h6 id="优点：速度较快，可以保留较大的空闲分区"><a href="#优点：速度较快，可以保留较大的空闲分区" class="headerlink" title="优点：速度较快，可以保留较大的空闲分区"></a>优点：速度较快，可以保留较大的空闲分区</h6><h6 id="缺点：会形成较多外碎片"><a href="#缺点：会形成较多外碎片" class="headerlink" title="缺点：会形成较多外碎片"></a>缺点：会形成较多外碎片</h6><h5 id="4、最坏适应法（worst-fit）"><a href="#4、最坏适应法（worst-fit）" class="headerlink" title="4、最坏适应法（worst-fit）"></a>4、最坏适应法（worst-fit）</h5><h6 id="概念：空闲分区表按从大到小排序，找到最大的空闲分区"><a href="#概念：空闲分区表按从大到小排序，找到最大的空闲分区" class="headerlink" title="概念：空闲分区表按从大到小排序，找到最大的空闲分区"></a>概念：空闲分区表按从大到小排序，找到最大的空闲分区</h6><h6 id="优点：基本不留下小空闲分区"><a href="#优点：基本不留下小空闲分区" class="headerlink" title="优点：基本不留下小空闲分区"></a>优点：基本不留下小空闲分区</h6><h6 id="缺点：较大的空闲分区不被保留"><a href="#缺点：较大的空闲分区不被保留" class="headerlink" title="缺点：较大的空闲分区不被保留"></a>缺点：较大的空闲分区不被保留</h6><h5 id="5、快速适应算法"><a href="#5、快速适应算法" class="headerlink" title="5、快速适应算法"></a>5、快速适应算法</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><p>空闲分区根据容量分类，每类分区容量相同</p>
<p>1、设置空闲分区链表分别指向每类分区</p>
<p>2、管理索引表指向每类空闲分区链表表头</p>
<h6 id="优点：查找效率高，能保留较大分区"><a href="#优点：查找效率高，能保留较大分区" class="headerlink" title="优点：查找效率高，能保留较大分区"></a>优点：查找效率高，能保留较大分区</h6><h6 id="缺点：回收分区时开销大；空闲分区划分越细，浪费越严重"><a href="#缺点：回收分区时开销大；空闲分区划分越细，浪费越严重" class="headerlink" title="缺点：回收分区时开销大；空闲分区划分越细，浪费越严重"></a>缺点：回收分区时开销大；空闲分区划分越细，浪费越严重</h6><h5 id="6、伙伴系统"><a href="#6、伙伴系统" class="headerlink" title="6、伙伴系统"></a>6、伙伴系统</h5><h6 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h6><p>动态分区分配和固定分区分配的折衷方案</p>
<p>规定分配的分区和空闲分区大小都是2的k次方，1&lt;=k&lt;=m</p>
<p>算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间</p>
<p>分区回收方法：由伙伴碎片就合并，继而又有伙伴碎片，持续往下合并</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>快速搜索合并；外碎片少</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>内部碎片多</p>
<p>按2的幂划分可能产生的内碎片大</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><h6 id="利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区"><a href="#利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区" class="headerlink" title="利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区"></a>利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区</h6><h5 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h5><h6 id="1、与前一个空闲分区相邻"><a href="#1、与前一个空闲分区相邻" class="headerlink" title="1、与前一个空闲分区相邻"></a>1、与前一个空闲分区相邻</h6><h6 id="2、与后一个空闲分区相邻"><a href="#2、与后一个空闲分区相邻" class="headerlink" title="2、与后一个空闲分区相邻"></a>2、与后一个空闲分区相邻</h6><h6 id="3、与前、后空闲分区相邻"><a href="#3、与前、后空闲分区相邻" class="headerlink" title="3、与前、后空闲分区相邻"></a>3、与前、后空闲分区相邻</h6><h6 id="4、不与空闲分区相邻"><a href="#4、不与空闲分区相邻" class="headerlink" title="4、不与空闲分区相邻"></a>4、不与空闲分区相邻</h6><h3 id="4-3-4-动态重定位分区分配"><a href="#4-3-4-动态重定位分区分配" class="headerlink" title="4.3.4.     动态重定位分区分配"></a>4.3.4.     动态重定位分区分配</h3><h4 id="1、紧凑"><a href="#1、紧凑" class="headerlink" title="1、紧凑"></a>1、紧凑</h4><h5 id="各个占用分区向内存一端移动，使空闲分区合并在另一端"><a href="#各个占用分区向内存一端移动，使空闲分区合并在另一端" class="headerlink" title="各个占用分区向内存一端移动，使空闲分区合并在另一端"></a>各个占用分区向内存一端移动，使空闲分区合并在另一端</h5><h5 id="何时执行紧凑"><a href="#何时执行紧凑" class="headerlink" title="何时执行紧凑"></a>何时执行紧凑</h5><h6 id="每个分区释放后、或者内存分配找不到满足条件的空闲分区时"><a href="#每个分区释放后、或者内存分配找不到满足条件的空闲分区时" class="headerlink" title="每个分区释放后、或者内存分配找不到满足条件的空闲分区时"></a>每个分区释放后、或者内存分配找不到满足条件的空闲分区时</h6><h4 id="2、动态重定位"><a href="#2、动态重定位" class="headerlink" title="2、动态重定位"></a>2、动态重定位</h4><h5 id="不用修改程序，用新起始地址置换原来的起始地址即可"><a href="#不用修改程序，用新起始地址置换原来的起始地址即可" class="headerlink" title="不用修改程序，用新起始地址置换原来的起始地址即可"></a>不用修改程序，用新起始地址置换原来的起始地址即可</h5><h4 id="3、动态重定位分区分配算法"><a href="#3、动态重定位分区分配算法" class="headerlink" title="3、动态重定位分区分配算法"></a>3、动态重定位分区分配算法</h4><h5 id="找得到按动态分区方式分配"><a href="#找得到按动态分区方式分配" class="headerlink" title="找得到按动态分区方式分配"></a>找得到按动态分区方式分配</h5><h5 id="找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回"><a href="#找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回" class="headerlink" title="找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回"></a>找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回</h5><h2 id="4-4-覆盖"><a href="#4-4-覆盖" class="headerlink" title="4.4.     覆盖"></a>4.4.     覆盖</h2><h3 id="4-4-1-引入目标"><a href="#4-4-1-引入目标" class="headerlink" title="4.4.1.     引入目标"></a>4.4.1.     引入目标</h3><h4 id="在较小内存运行较大的程序，常与固定分区配合"><a href="#在较小内存运行较大的程序，常与固定分区配合" class="headerlink" title="在较小内存运行较大的程序，常与固定分区配合"></a>在较小内存运行较大的程序，常与固定分区配合</h4><h3 id="4-4-2-原理"><a href="#4-4-2-原理" class="headerlink" title="4.4.2.     原理"></a>4.4.2.     原理</h3><h4 id="程序的几个代码段和数据段按时间顺序先后占用同一内存空间"><a href="#程序的几个代码段和数据段按时间顺序先后占用同一内存空间" class="headerlink" title="程序的几个代码段和数据段按时间顺序先后占用同一内存空间"></a>程序的几个代码段和数据段按时间顺序先后占用同一内存空间</h4><h5 id="1、必要部分常驻内存"><a href="#1、必要部分常驻内存" class="headerlink" title="1、必要部分常驻内存"></a>1、必要部分常驻内存</h5><h5 id="2、不常用部分其他程序模块实现，平时在外存，要用调入内存"><a href="#2、不常用部分其他程序模块实现，平时在外存，要用调入内存" class="headerlink" title="2、不常用部分其他程序模块实现，平时在外存，要用调入内存"></a>2、不常用部分其他程序模块实现，平时在外存，要用调入内存</h5><h5 id="3、不存在调用关系的模块不提示调入内存，可以相互覆盖"><a href="#3、不存在调用关系的模块不提示调入内存，可以相互覆盖" class="headerlink" title="3、不存在调用关系的模块不提示调入内存，可以相互覆盖"></a>3、不存在调用关系的模块不提示调入内存，可以相互覆盖</h5><h3 id="4-4-3-缺点"><a href="#4-4-3-缺点" class="headerlink" title="4.4.3.     缺点"></a>4.4.3.     缺点</h3><h4 id="增加了编程复杂度：程序员必须了解程序模块之间的划分关系"><a href="#增加了编程复杂度：程序员必须了解程序模块之间的划分关系" class="headerlink" title="增加了编程复杂度：程序员必须了解程序模块之间的划分关系"></a>增加了编程复杂度：程序员必须了解程序模块之间的划分关系</h4><h4 id="外存覆盖内存速度慢，时间换空间"><a href="#外存覆盖内存速度慢，时间换空间" class="headerlink" title="外存覆盖内存速度慢，时间换空间"></a>外存覆盖内存速度慢，时间换空间</h4><h2 id="4-5-对换"><a href="#4-5-对换" class="headerlink" title="4.5.     对换"></a>4.5.     对换</h2><h3 id="4-5-1-概念"><a href="#4-5-1-概念" class="headerlink" title="4.5.1.     概念"></a>4.5.1.     概念</h3><h4 id="将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进-滚出（roll-in-roll-out）"><a href="#将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进-滚出（roll-in-roll-out）" class="headerlink" title="将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进/滚出（roll-in/roll-out）"></a>将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进/滚出（roll-in/roll-out）</h4><h4 id="交换单位"><a href="#交换单位" class="headerlink" title="交换单位"></a>交换单位</h4><h5 id="整个进程的地址空间"><a href="#整个进程的地址空间" class="headerlink" title="整个进程的地址空间"></a>整个进程的地址空间</h5><h3 id="4-5-2-原理"><a href="#4-5-2-原理" class="headerlink" title="4.5.2.     原理"></a>4.5.2.     原理</h3><h4 id="换入"><a href="#换入" class="headerlink" title="换入"></a>换入</h4><h5 id="OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入"><a href="#OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入" class="headerlink" title="OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入"></a>OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入</h5><h4 id="换出"><a href="#换出" class="headerlink" title="换出"></a>换出</h4><h5 id="内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存"><a href="#内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存" class="headerlink" title="内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存"></a>内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存</h5><h3 id="4-5-3-优缺点"><a href="#4-5-3-优缺点" class="headerlink" title="4.5.3.     优缺点"></a>4.5.3.     优缺点</h3><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><h5 id="增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率"><a href="#增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率" class="headerlink" title="增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率"></a>增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率</h5><h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><h5 id="对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性"><a href="#对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性" class="headerlink" title="对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性"></a>对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性</h5><h3 id="4-5-4-与覆盖对比"><a href="#4-5-4-与覆盖对比" class="headerlink" title="4.5.4.     与覆盖对比"></a>4.5.4.     与覆盖对比</h3><h4 id="1、交换不要求程序员了解程序段之间的覆盖结构"><a href="#1、交换不要求程序员了解程序段之间的覆盖结构" class="headerlink" title="1、交换不要求程序员了解程序段之间的覆盖结构"></a>1、交换不要求程序员了解程序段之间的覆盖结构</h4><h4 id="2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行"><a href="#2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行" class="headerlink" title="2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行"></a>2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行</h4><h4 id="3、覆盖只能覆盖与覆盖程序段无关的程序段"><a href="#3、覆盖只能覆盖与覆盖程序段无关的程序段" class="headerlink" title="3、覆盖只能覆盖与覆盖程序段无关的程序段"></a>3、覆盖只能覆盖与覆盖程序段无关的程序段</h4><h2 id="4-6-离散分配存储管理方式"><a href="#4-6-离散分配存储管理方式" class="headerlink" title="4.6.     离散分配存储管理方式"></a>4.6.     离散分配存储管理方式</h2><h3 id="4-6-1-连续分配带来的问题：形成内外碎片；紧凑带来开销"><a href="#4-6-1-连续分配带来的问题：形成内外碎片；紧凑带来开销" class="headerlink" title="4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销"></a>4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销</h3><h3 id="4-6-2-分页存储管理方式"><a href="#4-6-2-分页存储管理方式" class="headerlink" title="4.6.2.     分页存储管理方式"></a>4.6.2.     分页存储管理方式</h3><h4 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h4><h5 id="将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB"><a href="#将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB" class="headerlink" title="将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB"></a>将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB</h5><h5 id="内存空间划分为和页对应大小的块，称为物理块或页框"><a href="#内存空间划分为和页对应大小的块，称为物理块或页框" class="headerlink" title="内存空间划分为和页对应大小的块，称为物理块或页框"></a>内存空间划分为和页对应大小的块，称为物理块或页框</h5><h5 id="页和块一一对应，由页面映像表记录"><a href="#页和块一一对应，由页面映像表记录" class="headerlink" title="页和块一一对应，由页面映像表记录"></a>页和块一一对应，由页面映像表记录</h5><h4 id="进程装载"><a href="#进程装载" class="headerlink" title="进程装载"></a>进程装载</h4><h5 id="装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。"><a href="#装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。" class="headerlink" title="装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。"></a>装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。</h5><h5 id="要解决地址映像，需要硬件支持"><a href="#要解决地址映像，需要硬件支持" class="headerlink" title="要解决地址映像，需要硬件支持"></a>要解决地址映像，需要硬件支持</h5><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="进程页表："><a href="#进程页表：" class="headerlink" title="进程页表："></a>进程页表：</h5><h6 id="每个进程一个进程页表，描述进程每个页对应的页框"><a href="#每个进程一个进程页表，描述进程每个页对应的页框" class="headerlink" title="每个进程一个进程页表，描述进程每个页对应的页框"></a>每个进程一个进程页表，描述进程每个页对应的页框</h6><h5 id="物理页面表"><a href="#物理页面表" class="headerlink" title="物理页面表"></a>物理页面表</h5><h6 id="描述每个物理页框的分配使用情况；数据结构：位示图-空闲页面列表"><a href="#描述每个物理页框的分配使用情况；数据结构：位示图-空闲页面列表" class="headerlink" title="描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表"></a>描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表</h6><h5 id="请求表"><a href="#请求表" class="headerlink" title="请求表"></a>请求表</h5><h6 id="描述系统内各个进程页表的位置和大小，用于地址转换"><a href="#描述系统内各个进程页表的位置和大小，用于地址转换" class="headerlink" title="描述系统内各个进程页表的位置和大小，用于地址转换"></a>描述系统内各个进程页表的位置和大小，用于地址转换</h6><h6 id="请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号"><a href="#请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号" class="headerlink" title="请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号"></a>请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号</h6><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><h5 id="逻辑页号（m-n）-页内偏移量（n位）"><a href="#逻辑页号（m-n）-页内偏移量（n位）" class="headerlink" title="逻辑页号（m-n）+页内偏移量（n位）"></a>逻辑页号（m-n）+页内偏移量（n位）</h5><h5 id="逻辑地址空间2的m次方，页框大小2的n次方"><a href="#逻辑地址空间2的m次方，页框大小2的n次方" class="headerlink" title="逻辑地址空间2的m次方，页框大小2的n次方"></a>逻辑地址空间2的m次方，页框大小2的n次方</h5><h4 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h5><h6 id="没有外碎片，内碎片大小不超过页大小"><a href="#没有外碎片，内碎片大小不超过页大小" class="headerlink" title="没有外碎片，内碎片大小不超过页大小"></a>没有外碎片，内碎片大小不超过页大小</h6><h6 id="程序不必连续存放，便于改变程序占用空间的大小"><a href="#程序不必连续存放，便于改变程序占用空间的大小" class="headerlink" title="程序不必连续存放，便于改变程序占用空间的大小"></a>程序不必连续存放，便于改变程序占用空间的大小</h6><h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h5><h6 id="程序全部装入内存"><a href="#程序全部装入内存" class="headerlink" title="程序全部装入内存"></a>程序全部装入内存</h6><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><h6 id="逻辑地址-逻辑页号-页内偏移地址"><a href="#逻辑地址-逻辑页号-页内偏移地址" class="headerlink" title="逻辑地址=逻辑页号+页内偏移地址"></a>逻辑地址=逻辑页号+页内偏移地址</h6><h6 id="物理地址-页框号-页框内偏移地址"><a href="#物理地址-页框号-页框内偏移地址" class="headerlink" title="物理地址=页框号+页框内偏移地址"></a>物理地址=页框号+页框内偏移地址</h6><h6 id="根据页号查进程页表转换为页框号，页内偏移地址-页框内偏移地址"><a href="#根据页号查进程页表转换为页框号，页内偏移地址-页框内偏移地址" class="headerlink" title="根据页号查进程页表转换为页框号，页内偏移地址=页框内偏移地址"></a>根据页号查进程页表转换为页框号，页内偏移地址=页框内偏移地址</h6><h5 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><h6 id="大多数页表存储在内存中，需访问两次"><a href="#大多数页表存储在内存中，需访问两次" class="headerlink" title="大多数页表存储在内存中，需访问两次"></a>大多数页表存储在内存中，需访问两次</h6><p>第一次读取页表</p>
<p>第二次访问数据</p>
<h6 id="联想（关联）存储器（快表TLB）"><a href="#联想（关联）存储器（快表TLB）" class="headerlink" title="联想（关联）存储器（快表TLB）"></a>联想（关联）存储器（快表TLB）</h6><p>具有并行查找功能的高速缓冲寄存器</p>
<p>根据程序局部性原理，将页表的一部分放在里面（8~32个）</p>
<h6 id="地址变换步骤"><a href="#地址变换步骤" class="headerlink" title="地址变换步骤"></a>地址变换步骤</h6><p>1、首先查找快表，直接命中生成物理地址，访存一次</p>
<p>2、不命中查找内存，置换页表再生成，访存两次</p>
<h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><h5 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h5><h6 id="页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法"><a href="#页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法" class="headerlink" title="页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法"></a>页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法</h6><h6 id="分散存储"><a href="#分散存储" class="headerlink" title="分散存储"></a>分散存储</h6><p>将页表分页，每个页面大小与物理页框大小相同，解决难以找到连续的物理内存的问题</p>
<h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><h6 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h6><p>增加页表的页表（外层页表），也叫页目录表，存放页表起始地址</p>
<h6 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><p>外层页号（页表目录）+外存页内地址（页表）+页内地址</p>
<h6 id="访存次数"><a href="#访存次数" class="headerlink" title="访存次数"></a>访存次数</h6><p>3次</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><h6 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h6><p>增加多个页表的页表（外层页表）</p>
<h6 id="访存次数-1"><a href="#访存次数-1" class="headerlink" title="访存次数"></a>访存次数</h6><p>n+1</p>
<h6 id="计算方法："><a href="#计算方法：" class="headerlink" title="计算方法："></a>计算方法：</h6><p>把逻辑地址转换为二进制，根据每位0/1查找页表，加上页内偏移地址就是对应的物理地址了（PPT27）</p>
<h5 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h5><h6 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h6><p>每个进程一张页表，页表按照进程的逻辑地址顺序排序，内容位物理块号（页框号）</p>
<h6 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a>检索方式</h6><p>根据进程id和页号检索</p>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><p>系统只有一张页表，每个物理页框在页表中只有一项</p>
<p>访问查页表速度慢，可能需要查找整张表</p>
<p>不易于实现页面共享</p>
<h3 id="4-6-3-分段存储管理方式"><a href="#4-6-3-分段存储管理方式" class="headerlink" title="4.6.3.     分段存储管理方式"></a>4.6.3.     分段存储管理方式</h3><h4 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h4><h5 id="按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始"><a href="#按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始" class="headerlink" title="按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始"></a>按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始</h5><h5 id="程序划分为数据段、代码段、和共享段，可以分别编写编译"><a href="#程序划分为数据段、代码段、和共享段，可以分别编写编译" class="headerlink" title="程序划分为数据段、代码段、和共享段，可以分别编写编译"></a>程序划分为数据段、代码段、和共享段，可以分别编写编译</h5><h4 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h4><h5 id="方便编程"><a href="#方便编程" class="headerlink" title="方便编程"></a>方便编程</h5><h5 id="分段共享"><a href="#分段共享" class="headerlink" title="分段共享"></a>分段共享</h5><h5 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h5><h6 id="根据不同类型的段采取不同的保护措施"><a href="#根据不同类型的段采取不同的保护措施" class="headerlink" title="根据不同类型的段采取不同的保护措施"></a>根据不同类型的段采取不同的保护措施</h6><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><h6 id="进程开始时只装入主模块，运行时再根据需要装入其他模块"><a href="#进程开始时只装入主模块，运行时再根据需要装入其他模块" class="headerlink" title="进程开始时只装入主模块，运行时再根据需要装入其他模块"></a>进程开始时只装入主模块，运行时再根据需要装入其他模块</h6><h5 id="动态增长"><a href="#动态增长" class="headerlink" title="动态增长"></a>动态增长</h5><h6 id="比如数据段可能根据需要增大"><a href="#比如数据段可能根据需要增大" class="headerlink" title="比如数据段可能根据需要增大"></a>比如数据段可能根据需要增大</h6><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="进程段表："><a href="#进程段表：" class="headerlink" title="进程段表："></a>进程段表：</h5><h6 id="每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长"><a href="#每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长" class="headerlink" title="每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长"></a>每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长</h6><h5 id="系统段表"><a href="#系统段表" class="headerlink" title="系统段表"></a>系统段表</h5><h6 id="描述每个占用段的分配使用情况"><a href="#描述每个占用段的分配使用情况" class="headerlink" title="描述每个占用段的分配使用情况"></a>描述每个占用段的分配使用情况</h6><h5 id="空闲段表"><a href="#空闲段表" class="headerlink" title="空闲段表"></a>空闲段表</h5><h6 id="描述每个空闲段，可以结合到系统段表中"><a href="#描述每个空闲段，可以结合到系统段表中" class="headerlink" title="描述每个空闲段，可以结合到系统段表中"></a>描述每个空闲段，可以结合到系统段表中</h6><h4 id="逻辑地址结构-2"><a href="#逻辑地址结构-2" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><h5 id="段号（m-n）-段内地址（n位）"><a href="#段号（m-n）-段内地址（n位）" class="headerlink" title="段号（m-n）+段内地址（n位）"></a>段号（m-n）+段内地址（n位）</h5><h4 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h5><h6 id="没有内碎片，外碎片可以紧凑来消除"><a href="#没有内碎片，外碎片可以紧凑来消除" class="headerlink" title="没有内碎片，外碎片可以紧凑来消除"></a>没有内碎片，外碎片可以紧凑来消除</h6><h6 id="程序不必连续存放，便于改变程序占用空间的大小-1"><a href="#程序不必连续存放，便于改变程序占用空间的大小-1" class="headerlink" title="程序不必连续存放，便于改变程序占用空间的大小"></a>程序不必连续存放，便于改变程序占用空间的大小</h6><h5 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h5><h6 id="程序全部装入内存-1"><a href="#程序全部装入内存-1" class="headerlink" title="程序全部装入内存"></a>程序全部装入内存</h6><h4 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构-1"><a href="#基本地址变换机构-1" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><h6 id="逻辑地址-段号S-段内地址d"><a href="#逻辑地址-段号S-段内地址d" class="headerlink" title="逻辑地址=段号S+段内地址d"></a>逻辑地址=段号S+段内地址d</h6><h6 id="段表寄存器-段表始地址f-段表长度TL"><a href="#段表寄存器-段表始地址f-段表长度TL" class="headerlink" title="段表寄存器=段表始地址f+段表长度TL"></a>段表寄存器=段表始地址f+段表长度TL</h6><h6 id="段表-段长SL-段基址d"><a href="#段表-段长SL-段基址d" class="headerlink" title="段表=段长SL+段基址d"></a>段表=段长SL+段基址d</h6><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>1、比较段号S和段表长度TL，若S&gt;TL，访问越界，产生越界中断信号</p>
<p>2、未越界：根据段表始地址f和段号S，计算该段对应段表项的位置，从而读出该段在内存的起始地址</p>
<p>3、比较段内地址d是否超过该段段长SL，若d&gt;SL,访问越界，产生越界中断信号</p>
<p>4、未越界，段基址d与段内地址d相加得到物理地址</p>
<h5 id="具有快表的地址变换机构-1"><a href="#具有快表的地址变换机构-1" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><h5 id="1、单位：页是物理单位，段是逻辑单位。"><a href="#1、单位：页是物理单位，段是逻辑单位。" class="headerlink" title="1、单位：页是物理单位，段是逻辑单位。"></a>1、单位：页是物理单位，段是逻辑单位。</h5><h5 id="2、目的：分页目的是系统管理，分段目的是用户需要"><a href="#2、目的：分页目的是系统管理，分段目的是用户需要" class="headerlink" title="2、目的：分页目的是系统管理，分段目的是用户需要"></a>2、目的：分页目的是系统管理，分段目的是用户需要</h5><h5 id="3、大小：页大小系统固定，段不固定"><a href="#3、大小：页大小系统固定，段不固定" class="headerlink" title="3、大小：页大小系统固定，段不固定"></a>3、大小：页大小系统固定，段不固定</h5><h5 id="4、地址空间：分页一维（页号），分段二维（段号-段内地址）"><a href="#4、地址空间：分页一维（页号），分段二维（段号-段内地址）" class="headerlink" title="4、地址空间：分页一维（页号），分段二维（段号+段内地址）"></a>4、地址空间：分页一维（页号），分段二维（段号+段内地址）</h5><h5 id="5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度"><a href="#5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度" class="headerlink" title="5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度"></a>5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度</h5><h5 id="6、共享：分段方便共享代码"><a href="#6、共享：分段方便共享代码" class="headerlink" title="6、共享：分段方便共享代码"></a>6、共享：分段方便共享代码</h5><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><h5 id="能共享的代码必须是可重入代码"><a href="#能共享的代码必须是可重入代码" class="headerlink" title="能共享的代码必须是可重入代码"></a>能共享的代码必须是可重入代码</h5><h5 id="可重入代码："><a href="#可重入代码：" class="headerlink" title="可重入代码："></a>可重入代码：</h5><h6 id="允许多个进程同时访问，代码执行时不允许修改"><a href="#允许多个进程同时访问，代码执行时不允许修改" class="headerlink" title="允许多个进程同时访问，代码执行时不允许修改"></a>允许多个进程同时访问，代码执行时不允许修改</h6><h5 id="调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量"><a href="#调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量" class="headerlink" title="调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量"></a>调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量</h5><h3 id="4-6-4-段页式存储管理方式"><a href="#4-6-4-段页式存储管理方式" class="headerlink" title="4.6.4.     段页式存储管理方式"></a>4.6.4.     段页式存储管理方式</h3><h4 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h4><h5 id="段内分页，先将用户程序分为若干段，每个段再分为若干页"><a href="#段内分页，先将用户程序分为若干段，每个段再分为若干页" class="headerlink" title="段内分页，先将用户程序分为若干段，每个段再分为若干页"></a>段内分页，先将用户程序分为若干段，每个段再分为若干页</h5><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="每个进程一张段表，每个段一张页表。"><a href="#每个进程一张段表，每个段一张页表。" class="headerlink" title="每个进程一张段表，每个段一张页表。"></a>每个进程一张段表，每个段一张页表。</h5><h5 id="段表-段表大小-段表首地址"><a href="#段表-段表大小-段表首地址" class="headerlink" title="段表=段表大小+段表首地址"></a>段表=段表大小+段表首地址</h5><h5 id="页表-段号-段内页号-页内偏移量"><a href="#页表-段号-段内页号-页内偏移量" class="headerlink" title="页表=段号+段内页号+页内偏移量"></a>页表=段号+段内页号+页内偏移量</h5><h4 id="地址变换机构-2"><a href="#地址变换机构-2" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="暂定"><a href="#暂定" class="headerlink" title="暂定"></a>暂定</h5><h1 id="5-五、虚拟存储器"><a href="#5-五、虚拟存储器" class="headerlink" title="5.    五、虚拟存储器"></a>5.    五、虚拟存储器</h1><h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1.     虚拟存储器概述"></a>5.1.     虚拟存储器概述</h2><h3 id="5-1-1-问题"><a href="#5-1-1-问题" class="headerlink" title="5.1.1.     问题"></a>5.1.1.     问题</h3><h4 id="前面介绍的方式：1、进程一次性装入内存-2、有大量进程等待运行，但实际内存不足以全部装入"><a href="#前面介绍的方式：1、进程一次性装入内存-2、有大量进程等待运行，但实际内存不足以全部装入" class="headerlink" title="前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入"></a>前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入</h4><h3 id="5-1-2-常规存储管理方式特征"><a href="#5-1-2-常规存储管理方式特征" class="headerlink" title="5.1.2.     常规存储管理方式特征"></a>5.1.2.     常规存储管理方式特征</h3><h4 id="1、一次性"><a href="#1、一次性" class="headerlink" title="1、一次性"></a>1、一次性</h4><h4 id="2、程序的驻留性"><a href="#2、程序的驻留性" class="headerlink" title="2、程序的驻留性"></a>2、程序的驻留性</h4><h5 id="装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用"><a href="#装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用" class="headerlink" title="装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用"></a>装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用</h5><h3 id="5-1-3-定义"><a href="#5-1-3-定义" class="headerlink" title="5.1.3.     定义"></a>5.1.3.     定义</h3><h4 id="是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统"><a href="#是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统" class="headerlink" title="是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统"></a>是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统</h4><h4 id="借助于外存空间，允许一个进程在其运行过程只部分装入"><a href="#借助于外存空间，允许一个进程在其运行过程只部分装入" class="headerlink" title="借助于外存空间，允许一个进程在其运行过程只部分装入"></a>借助于外存空间，允许一个进程在其运行过程只部分装入</h4><h4 id="虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和"><a href="#虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和" class="headerlink" title="虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和"></a>虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和</h4><h4 id="对用户透明，用户地址空间称为虚存空间或虚地址空间"><a href="#对用户透明，用户地址空间称为虚存空间或虚地址空间" class="headerlink" title="对用户透明，用户地址空间称为虚存空间或虚地址空间"></a>对用户透明，用户地址空间称为虚存空间或虚地址空间</h4><h3 id="5-1-4-工作过程"><a href="#5-1-4-工作过程" class="headerlink" title="5.1.4.     工作过程"></a>5.1.4.     工作过程</h3><h4 id="1、进程部分装入"><a href="#1、进程部分装入" class="headerlink" title="1、进程部分装入"></a>1、进程部分装入</h4><h4 id="2、执行时内容不在内存（缺页-缺段），请求调入"><a href="#2、执行时内容不在内存（缺页-缺段），请求调入" class="headerlink" title="2、执行时内容不在内存（缺页/缺段），请求调入"></a>2、执行时内容不在内存（缺页/缺段），请求调入</h4><h4 id="3、若此时内存已满，请求置换"><a href="#3、若此时内存已满，请求置换" class="headerlink" title="3、若此时内存已满，请求置换"></a>3、若此时内存已满，请求置换</h4><h3 id="5-1-5-好处"><a href="#5-1-5-好处" class="headerlink" title="5.1.5.     好处"></a>5.1.5.     好处</h3><h4 id="1、较小的内存可以运行较大的进程"><a href="#1、较小的内存可以运行较大的进程" class="headerlink" title="1、较小的内存可以运行较大的进程"></a>1、较小的内存可以运行较大的进程</h4><h4 id="2、容纳更多进程并发执行"><a href="#2、容纳更多进程并发执行" class="headerlink" title="2、容纳更多进程并发执行"></a>2、容纳更多进程并发执行</h4><h4 id="3、不影响编程的程序结构（和覆盖不同）"><a href="#3、不影响编程的程序结构（和覆盖不同）" class="headerlink" title="3、不影响编程的程序结构（和覆盖不同）"></a>3、不影响编程的程序结构（和覆盖不同）</h4><h4 id="4、提供的虚拟内存空间大于物理内存"><a href="#4、提供的虚拟内存空间大于物理内存" class="headerlink" title="4、提供的虚拟内存空间大于物理内存"></a>4、提供的虚拟内存空间大于物理内存</h4><h3 id="5-1-6-局部性原理"><a href="#5-1-6-局部性原理" class="headerlink" title="5.1.6.     局部性原理"></a>5.1.6.     局部性原理</h3><h4 id="指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域"><a href="#指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域" class="headerlink" title="指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域"></a>指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域</h4><h4 id="1、时间局部性"><a href="#1、时间局部性" class="headerlink" title="1、时间局部性"></a>1、时间局部性</h4><h5 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h5><h6 id="指令-数据的执行-访问局限在较短时期"><a href="#指令-数据的执行-访问局限在较短时期" class="headerlink" title="指令/数据的执行/访问局限在较短时期"></a>指令/数据的执行/访问局限在较短时期</h6><h4 id="2、空间局部性"><a href="#2、空间局部性" class="headerlink" title="2、空间局部性"></a>2、空间局部性</h4><h5 id="顺序执行-1"><a href="#顺序执行-1" class="headerlink" title="顺序执行"></a>顺序执行</h5><h6 id="访问的地址局限在一定范围内（例如·数组）"><a href="#访问的地址局限在一定范围内（例如·数组）" class="headerlink" title="访问的地址局限在一定范围内（例如·数组）"></a>访问的地址局限在一定范围内（例如·数组）</h6><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h3 id="5-1-7-实现方式"><a href="#5-1-7-实现方式" class="headerlink" title="5.1.7.     实现方式"></a>5.1.7.     实现方式</h3><h4 id="分页请求系统"><a href="#分页请求系统" class="headerlink" title="分页请求系统"></a>分页请求系统</h4><h5 id="纯分页系统-请求调页-页面置换——页面虚拟存储器"><a href="#纯分页系统-请求调页-页面置换——页面虚拟存储器" class="headerlink" title="纯分页系统+请求调页+页面置换——页面虚拟存储器"></a>纯分页系统+请求调页+页面置换——页面虚拟存储器</h5><h5 id="1、硬件支持"><a href="#1、硬件支持" class="headerlink" title="1、硬件支持"></a>1、硬件支持</h5><h6 id="1、页表增加项"><a href="#1、页表增加项" class="headerlink" title="1、页表增加项"></a>1、页表增加项</h6><h6 id="2、缺页中断"><a href="#2、缺页中断" class="headerlink" title="2、缺页中断"></a>2、缺页中断</h6><h6 id="3、地址变换机构"><a href="#3、地址变换机构" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h6><h5 id="2、实现请求分页的软件"><a href="#2、实现请求分页的软件" class="headerlink" title="2、实现请求分页的软件"></a>2、实现请求分页的软件</h5><h4 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h4><h5 id="纯分段系统-请求调段-分段置换——段式虚拟存储器"><a href="#纯分段系统-请求调段-分段置换——段式虚拟存储器" class="headerlink" title="纯分段系统+请求调段+分段置换——段式虚拟存储器"></a>纯分段系统+请求调段+分段置换——段式虚拟存储器</h5><h5 id="1、硬件支持-1"><a href="#1、硬件支持-1" class="headerlink" title="1、硬件支持"></a>1、硬件支持</h5><h6 id="1、段表增加项"><a href="#1、段表增加项" class="headerlink" title="1、段表增加项"></a>1、段表增加项</h6><h6 id="2、缺段中断"><a href="#2、缺段中断" class="headerlink" title="2、缺段中断"></a>2、缺段中断</h6><h6 id="3、地址变换机构-1"><a href="#3、地址变换机构-1" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h6><h5 id="需要CPU、MMU支持，段页式"><a href="#需要CPU、MMU支持，段页式" class="headerlink" title="需要CPU、MMU支持，段页式"></a>需要CPU、MMU支持，段页式</h5><h3 id="5-1-8-特征"><a href="#5-1-8-特征" class="headerlink" title="5.1.8.     特征"></a>5.1.8.     特征</h3><h4 id="1、多次性"><a href="#1、多次性" class="headerlink" title="1、多次性"></a>1、多次性</h4><h5 id="进程-作业多次调度"><a href="#进程-作业多次调度" class="headerlink" title="进程/作业多次调度"></a>进程/作业多次调度</h5><h4 id="2、对换性"><a href="#2、对换性" class="headerlink" title="2、对换性"></a>2、对换性</h4><h4 id="3、虚拟性"><a href="#3、虚拟性" class="headerlink" title="3、虚拟性"></a>3、虚拟性</h4><h5 id="逻辑地址空间-gt-实际物理内存"><a href="#逻辑地址空间-gt-实际物理内存" class="headerlink" title="逻辑地址空间&gt;实际物理内存"></a>逻辑地址空间&gt;实际物理内存</h5><h4 id="4、离散性"><a href="#4、离散性" class="headerlink" title="4、离散性"></a>4、离散性</h4><h5 id="进程的物理空间不连续"><a href="#进程的物理空间不连续" class="headerlink" title="进程的物理空间不连续"></a>进程的物理空间不连续</h5><h2 id="5-2-请求分页存储器管理方式"><a href="#5-2-请求分页存储器管理方式" class="headerlink" title="5.2.     请求分页存储器管理方式"></a>5.2.     请求分页存储器管理方式</h2><h3 id="5-2-1-概念"><a href="#5-2-1-概念" class="headerlink" title="5.2.1.     概念"></a>5.2.1.     概念</h3><h4 id="在基础分页存储管理基础上增加请求调页和页面置换功能"><a href="#在基础分页存储管理基础上增加请求调页和页面置换功能" class="headerlink" title="在基础分页存储管理基础上增加请求调页和页面置换功能"></a>在基础分页存储管理基础上增加请求调页和页面置换功能</h4><h4 id="基本单位：长度固定的页"><a href="#基本单位：长度固定的页" class="headerlink" title="基本单位：长度固定的页"></a>基本单位：长度固定的页</h4><h4 id="ps-虚拟存储是最常用的实现方式"><a href="#ps-虚拟存储是最常用的实现方式" class="headerlink" title="ps:虚拟存储是最常用的实现方式"></a>ps:虚拟存储是最常用的实现方式</h4><h3 id="5-2-2-硬件支持"><a href="#5-2-2-硬件支持" class="headerlink" title="5.2.2.     硬件支持"></a>5.2.2.     硬件支持</h3><h4 id="1、进程页表：增加项"><a href="#1、进程页表：增加项" class="headerlink" title="1、进程页表：增加项"></a>1、进程页表：增加项</h4><h5 id="1、状态位：在内存还是外存"><a href="#1、状态位：在内存还是外存" class="headerlink" title="1、状态位：在内存还是外存"></a>1、状态位：在内存还是外存</h5><h5 id="2、修改位：该页是否修改过"><a href="#2、修改位：该页是否修改过" class="headerlink" title="2、修改位：该页是否修改过"></a>2、修改位：该页是否修改过</h5><h5 id="3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔"><a href="#3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔" class="headerlink" title="3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔"></a>3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔</h5><h5 id="4、外存地址：磁盘地址"><a href="#4、外存地址：磁盘地址" class="headerlink" title="4、外存地址：磁盘地址"></a>4、外存地址：磁盘地址</h5><h4 id="2、缺页中断机构"><a href="#2、缺页中断机构" class="headerlink" title="2、缺页中断机构"></a>2、缺页中断机构</h4><h5 id="概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序"><a href="#概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序" class="headerlink" title="概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序"></a>概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序</h5><h5 id="缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）"><a href="#缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）" class="headerlink" title="缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）"></a>缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）</h5><h4 id="3、地址变换机构-2"><a href="#3、地址变换机构-2" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h4><h5 id="在原基础上增加缺页中断，具体看PPT29"><a href="#在原基础上增加缺页中断，具体看PPT29" class="headerlink" title="在原基础上增加缺页中断，具体看PPT29"></a>在原基础上增加缺页中断，具体看PPT29</h5><h3 id="5-2-3-内存分配"><a href="#5-2-3-内存分配" class="headerlink" title="5.2.3.     内存分配"></a>5.2.3.     内存分配</h3><h4 id="1、最小物理块数的确定"><a href="#1、最小物理块数的确定" class="headerlink" title="1、最小物理块数的确定"></a>1、最小物理块数的确定</h4><h5 id="OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行"><a href="#OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行" class="headerlink" title="OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行"></a>OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行</h5><h5 id="进程运行最小页框数和指令系统有关"><a href="#进程运行最小页框数和指令系统有关" class="headerlink" title="进程运行最小页框数和指令系统有关"></a>进程运行最小页框数和指令系统有关</h5><h6 id="1、单地址-直接寻址"><a href="#1、单地址-直接寻址" class="headerlink" title="1、单地址+直接寻址"></a>1、单地址+直接寻址</h6><p>2个页面</p>
<h6 id="2、间接寻址"><a href="#2、间接寻址" class="headerlink" title="2、间接寻址"></a>2、间接寻址</h6><p>3个页面</p>
<h6 id="3、如swap-A，B"><a href="#3、如swap-A，B" class="headerlink" title="3、如swap A，B"></a>3、如swap A，B</h6><p>至少6个</p>
<h4 id="2、物理块的分配策略"><a href="#2、物理块的分配策略" class="headerlink" title="2、物理块的分配策略"></a>2、物理块的分配策略</h4><h5 id="1、固定分配局部置换"><a href="#1、固定分配局部置换" class="headerlink" title="1、固定分配局部置换"></a>1、固定分配局部置换</h5><h6 id="每个进程分配固定页框"><a href="#每个进程分配固定页框" class="headerlink" title="每个进程分配固定页框"></a>每个进程分配固定页框</h6><h6 id="缺页从该进程所属页框调出旧页面，换出新页面"><a href="#缺页从该进程所属页框调出旧页面，换出新页面" class="headerlink" title="缺页从该进程所属页框调出旧页面，换出新页面"></a>缺页从该进程所属页框调出旧页面，换出新页面</h6><h6 id="困难点："><a href="#困难点：" class="headerlink" title="困难点："></a>困难点：</h6><p>分配多少页框合适</p>
<p>多了内存可装入进程减少</p>
<p>少了缺页中断频繁</p>
<h5 id="2、可变分配全局置换（最易实现）"><a href="#2、可变分配全局置换（最易实现）" class="headerlink" title="2、可变分配全局置换（最易实现）"></a>2、可变分配全局置换（最易实现）</h5><h6 id="每个进程分配固定页框，OS控制一定数量的空闲页框"><a href="#每个进程分配固定页框，OS控制一定数量的空闲页框" class="headerlink" title="每个进程分配固定页框，OS控制一定数量的空闲页框"></a>每个进程分配固定页框，OS控制一定数量的空闲页框</h6><h6 id="缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框"><a href="#缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框" class="headerlink" title="缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框"></a>缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框</h6><h6 id="困难点：-1"><a href="#困难点：-1" class="headerlink" title="困难点："></a>困难点：</h6><p>不公平</p>
<h5 id="2、可变分配局部置换"><a href="#2、可变分配局部置换" class="headerlink" title="2、可变分配局部置换"></a>2、可变分配局部置换</h5><h6 id="每个进程分配固定页框，OS控制一定数量空闲页框"><a href="#每个进程分配固定页框，OS控制一定数量空闲页框" class="headerlink" title="每个进程分配固定页框，OS控制一定数量空闲页框"></a>每个进程分配固定页框，OS控制一定数量空闲页框</h6><h6 id="缺页先计算缺页中断率"><a href="#缺页先计算缺页中断率" class="headerlink" title="缺页先计算缺页中断率"></a>缺页先计算缺页中断率</h6><p>中断率低：从该进程所属页框调出旧页面，换出新页面</p>
<p>中断率高：OS给该进程分配空闲页框</p>
<h6 id="困难点：-2"><a href="#困难点：-2" class="headerlink" title="困难点："></a>困难点：</h6><p>统计缺页中断率增加系统开销</p>
<h4 id="3、物理块的分配算法"><a href="#3、物理块的分配算法" class="headerlink" title="3、物理块的分配算法"></a>3、物理块的分配算法</h4><h5 id="1、平均分配"><a href="#1、平均分配" class="headerlink" title="1、平均分配"></a>1、平均分配</h5><h5 id="2、按比例分配"><a href="#2、按比例分配" class="headerlink" title="2、按比例分配"></a>2、按比例分配</h5><h5 id="3、按优先权分配"><a href="#3、按优先权分配" class="headerlink" title="3、按优先权分配"></a>3、按优先权分配</h5><h2 id="5-3-页面调入"><a href="#5-3-页面调入" class="headerlink" title="5.3.     页面调入"></a>5.3.     页面调入</h2><h3 id="5-3-1-页面调入策略"><a href="#5-3-1-页面调入策略" class="headerlink" title="5.3.1.     页面调入策略"></a>5.3.1.     页面调入策略</h3><h4 id="OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入"><a href="#OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入" class="headerlink" title="OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入"></a>OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入</h4><h4 id="1、何时调入"><a href="#1、何时调入" class="headerlink" title="1、何时调入"></a>1、何时调入</h4><h5 id="1、预调页"><a href="#1、预调页" class="headerlink" title="1、预调页"></a>1、预调页</h5><h6 id="缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）"><a href="#缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）" class="headerlink" title="缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）"></a>缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）</h6><h5 id="2、请求调页"><a href="#2、请求调页" class="headerlink" title="2、请求调页"></a>2、请求调页</h5><h6 id="缺页只调缺的这一页"><a href="#缺页只调缺的这一页" class="headerlink" title="缺页只调缺的这一页"></a>缺页只调缺的这一页</h6><h4 id="2、何处调入"><a href="#2、何处调入" class="headerlink" title="2、何处调入"></a>2、何处调入</h4><h5 id="1、进程运行前"><a href="#1、进程运行前" class="headerlink" title="1、进程运行前"></a>1、进程运行前</h5><h6 id="全部页面从文件区调入交换区，以后都从交换区调"><a href="#全部页面从文件区调入交换区，以后都从交换区调" class="headerlink" title="全部页面从文件区调入交换区，以后都从交换区调"></a>全部页面从文件区调入交换区，以后都从交换区调</h6><h5 id="2、运行中"><a href="#2、运行中" class="headerlink" title="2、运行中"></a>2、运行中</h5><h6 id="未被修改的页面一直从文件区调"><a href="#未被修改的页面一直从文件区调" class="headerlink" title="未被修改的页面一直从文件区调"></a>未被修改的页面一直从文件区调</h6><h6 id="被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><a href="#被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区" class="headerlink" title="被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"></a>被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</h6><h5 id="3、UNIX方式"><a href="#3、UNIX方式" class="headerlink" title="3、UNIX方式"></a>3、UNIX方式</h5><h6 id="未运行的页面一直从文件区调"><a href="#未运行的页面一直从文件区调" class="headerlink" title="未运行的页面一直从文件区调"></a>未运行的页面一直从文件区调</h6><h6 id="运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><a href="#运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区" class="headerlink" title="运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"></a>运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</h6><h3 id="5-3-2-页面调入过程"><a href="#5-3-2-页面调入过程" class="headerlink" title="5.3.2.     页面调入过程"></a>5.3.2.     页面调入过程</h3><h4 id="PPT30"><a href="#PPT30" class="headerlink" title="PPT30"></a>PPT30</h4><h3 id="5-3-3-页面调入算法"><a href="#5-3-3-页面调入算法" class="headerlink" title="5.3.3.     页面调入算法"></a>5.3.3.     页面调入算法</h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><h5 id="内存满时，选择内存中哪个页面置换"><a href="#内存满时，选择内存中哪个页面置换" class="headerlink" title="内存满时，选择内存中哪个页面置换"></a>内存满时，选择内存中哪个页面置换</h5><h4 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h4><h5 id="降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”"><a href="#降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”" class="headerlink" title="降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”"></a>降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”</h5><h4 id="页面锁定"><a href="#页面锁定" class="headerlink" title="页面锁定"></a>页面锁定</h4><h5 id="OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志"><a href="#OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志" class="headerlink" title="OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志"></a>OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志</h5><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><h5 id="1、最佳置换算法（OPT）"><a href="#1、最佳置换算法（OPT）" class="headerlink" title="1、最佳置换算法（OPT）"></a>1、最佳置换算法（OPT）</h5><h6 id="选择“以后不用的”或”离当前位置最远的“页面置换"><a href="#选择“以后不用的”或”离当前位置最远的“页面置换" class="headerlink" title="选择“以后不用的”或”离当前位置最远的“页面置换"></a>选择“以后不用的”或”离当前位置最远的“页面置换</h6><h6 id="理想情况，不能实现，只作为评价依据"><a href="#理想情况，不能实现，只作为评价依据" class="headerlink" title="理想情况，不能实现，只作为评价依据"></a>理想情况，不能实现，只作为评价依据</h6><h5 id="2、先进先出置换算法（FIFO）"><a href="#2、先进先出置换算法（FIFO）" class="headerlink" title="2、先进先出置换算法（FIFO）"></a>2、先进先出置换算法（FIFO）</h5><h6 id="选择“建立最早”页面置换"><a href="#选择“建立最早”页面置换" class="headerlink" title="选择“建立最早”页面置换"></a>选择“建立最早”页面置换</h6><h6 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h6><p>链表表示建立时间先后</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>性能较差，较早进入的页一般也是经常访问的页</p>
<p>可能有Belady现象</p>
<h6 id="Belady现象："><a href="#Belady现象：" class="headerlink" title="Belady现象："></a>Belady现象：</h6><p>OS分配N个内存给进程，对一个访问序列S，N增大时，缺页次数PE（S，N）时而增大，时而减小</p>
<p>现象原因：FIFO置换特征与进程访问内存动态特征矛盾，即，置换页面并不是进程不会访问的</p>
<h5 id="3、最近最久未使用置换算法（LRU）"><a href="#3、最近最久未使用置换算法（LRU）" class="headerlink" title="3、最近最久未使用置换算法（LRU）"></a>3、最近最久未使用置换算法（LRU）</h5><h6 id="利用最近的过去预测最近的将来，选择“最久未使用”页面置换"><a href="#利用最近的过去预测最近的将来，选择“最久未使用”页面置换" class="headerlink" title="利用最近的过去预测最近的将来，选择“最久未使用”页面置换"></a>利用最近的过去预测最近的将来，选择“最久未使用”页面置换</h6><h6 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h6><p>记录首次访问以来过去的时间t</p>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><p>由于记录使用时间，增加系统硬件开销</p>
<h6 id="硬件机构"><a href="#硬件机构" class="headerlink" title="硬件机构"></a>硬件机构</h6><p>1、设立栈：被访问的页面挪到栈顶，于是栈底是最久未访问页面</p>
<p>2、页面设立移位寄存器：被访问时左边最高位置1，短期右移且最高位补0，寄存器值最小则为最久未访问页面</p>
<h5 id="4、Clock置换算法"><a href="#4、Clock置换算法" class="headerlink" title="4、Clock置换算法"></a>4、Clock置换算法</h5><h6 id="又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合"><a href="#又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合" class="headerlink" title="又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合"></a>又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合</h6><h6 id="一、简单Clock置换算法"><a href="#一、简单Clock置换算法" class="headerlink" title="一、简单Clock置换算法"></a>一、简单Clock置换算法</h6><p>方法：</p>
<p>每页设置访问标志位A，被访问过置1</p>
<p>步骤：</p>
<p>1、按照FIFO算法，寻找A=0做置换页，同时途中改A=1的页为A=0；</p>
<p>2、若所有页面都检查过，回到开头重新开始</p>
<p>3、最后指针停放在置换页的下一页</p>
<h6 id="二、改进Clock置换算法"><a href="#二、改进Clock置换算法" class="headerlink" title="二、改进Clock置换算法"></a>二、改进Clock置换算法</h6><p>方法：</p>
<p>每页设置访问标志位A和修改位M，被访问或修改过置1</p>
<p>步骤：</p>
<p>1、按照FIFO算法，寻找A=0，W=0做置换页，不改A=0；</p>
<p>2、按照FIFO算法，寻找A=0，W=1做置换页，更改A=0；</p>
<p>3、还没找到，回到1、2继续找，这回一定找得到</p>
<h5 id="ps：其他置换算法"><a href="#ps：其他置换算法" class="headerlink" title="ps：其他置换算法"></a>ps：其他置换算法</h5><h6 id="5、最少使用置换算法（LFU）"><a href="#5、最少使用置换算法（LFU）" class="headerlink" title="5、最少使用置换算法（LFU）"></a>5、最少使用置换算法（LFU）</h6><p>又称最不常用算法</p>
<p>选择“最少访问”页面置换</p>
<p>方法：</p>
<p>设置访问计数器，计算访问次数</p>
<p>缺页中断时调入值最小的页面并清空所有计数器</p>
<h6 id="6、页面缓冲算法（PB）"><a href="#6、页面缓冲算法（PB）" class="headerlink" title="6、页面缓冲算法（PB）"></a>6、页面缓冲算法（PB）</h6><p>FIFO的发展，有机会回收刚被置换的页面</p>
<p>方法：设置两个链表</p>
<p>空闲页面链表</p>
<p>已修改页面链表</p>
<p>步骤：</p>
<p>被置换页面未修改，直接归入空闲列表末尾；否则归入已修改链表</p>
<p>调入新页，新页内容读入空闲列表第一项，删除第一项</p>
<p>已修改页面在达到一定值时，一次性写回外存；此期间有被再次访问的页，可以直接在内存调入，减少I/O访问次数</p>
<h2 id="5-4-抖动与工作集"><a href="#5-4-抖动与工作集" class="headerlink" title="5.4.     抖动与工作集"></a>5.4.     抖动与工作集</h2><h3 id="5-4-1-缺页率与页框数"><a href="#5-4-1-缺页率与页框数" class="headerlink" title="5.4.1.     缺页率与页框数"></a>5.4.1.     缺页率与页框数</h3><h4 id="缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点"><a href="#缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点" class="headerlink" title="缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点"></a>缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点</h4><h3 id="5-4-2-工作集"><a href="#5-4-2-工作集" class="headerlink" title="5.4.2.     工作集"></a>5.4.2.     工作集</h3><h4 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h4><h5 id="w-△-t-某段时间间隔-t-△-，t-里-t是执行时刻），进程实际要访问的页面的集合"><a href="#w-△-t-某段时间间隔-t-△-，t-里-t是执行时刻），进程实际要访问的页面的集合" class="headerlink" title="w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合"></a>w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合</h5><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><h5 id="随△单调递增"><a href="#随△单调递增" class="headerlink" title="随△单调递增"></a>随△单调递增</h5><h5 id="局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值"><a href="#局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值" class="headerlink" title="局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值"></a>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</h5><h4 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h4><h5 id="依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来"><a href="#依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来" class="headerlink" title="依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来"></a>依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来</h5><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="OS跟着进程们，分配给进程大于工作集的帧数"><a href="#OS跟着进程们，分配给进程大于工作集的帧数" class="headerlink" title="OS跟着进程们，分配给进程大于工作集的帧数"></a>OS跟着进程们，分配给进程大于工作集的帧数</h5><h5 id="有空闲帧，启动另一个进程"><a href="#有空闲帧，启动另一个进程" class="headerlink" title="有空闲帧，启动另一个进程"></a>有空闲帧，启动另一个进程</h5><h5 id="如果所有工作集之和大于帧总数，OS选择挂起某个进程"><a href="#如果所有工作集之和大于帧总数，OS选择挂起某个进程" class="headerlink" title="如果所有工作集之和大于帧总数，OS选择挂起某个进程"></a>如果所有工作集之和大于帧总数，OS选择挂起某个进程</h5><h4 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h4><h5 id="工作集防止了抖动，提高了程序并发度"><a href="#工作集防止了抖动，提高了程序并发度" class="headerlink" title="工作集防止了抖动，提高了程序并发度"></a>工作集防止了抖动，提高了程序并发度</h5><h4 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h4><h5 id="过去预测未来可能不准确"><a href="#过去预测未来可能不准确" class="headerlink" title="过去预测未来可能不准确"></a>过去预测未来可能不准确</h5><h5 id="记录工作集变化增加了开销，开销大"><a href="#记录工作集变化增加了开销，开销大" class="headerlink" title="记录工作集变化增加了开销，开销大"></a>记录工作集变化增加了开销，开销大</h5><h5 id="△取值难以优化，而且通常该值不断改变"><a href="#△取值难以优化，而且通常该值不断改变" class="headerlink" title="△取值难以优化，而且通常该值不断改变"></a>△取值难以优化，而且通常该值不断改变</h5><h3 id="5-4-3-抖动"><a href="#5-4-3-抖动" class="headerlink" title="5.4.3.     抖动"></a>5.4.3.     抖动</h3><h4 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h4><h5 id="每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动"><a href="#每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动" class="headerlink" title="每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动"></a>每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动</h5><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><h5 id="随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）"><a href="#随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）" class="headerlink" title="随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）"></a>随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）</h5><h5 id="因此要选个合适的进程数目"><a href="#因此要选个合适的进程数目" class="headerlink" title="因此要选个合适的进程数目"></a>因此要选个合适的进程数目</h5><h4 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h4><h5 id="1、引入工作集算法"><a href="#1、引入工作集算法" class="headerlink" title="1、引入工作集算法"></a>1、引入工作集算法</h5><h5 id="2、挂起若干进程"><a href="#2、挂起若干进程" class="headerlink" title="2、挂起若干进程"></a>2、挂起若干进程</h5><h5 id="3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I-O等待队列中）"><a href="#3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I-O等待队列中）" class="headerlink" title="3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I/O等待队列中）"></a>3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I/O等待队列中）</h5><h5 id="4、L-S准则：产生缺页的时间L-系统处理缺页的平均时间S，此时CPU利用率最好"><a href="#4、L-S准则：产生缺页的时间L-系统处理缺页的平均时间S，此时CPU利用率最好" class="headerlink" title="4、L=S准则：产生缺页的时间L=系统处理缺页的平均时间S，此时CPU利用率最好"></a>4、L=S准则：产生缺页的时间L=系统处理缺页的平均时间S，此时CPU利用率最好</h5><h2 id="5-5-请求分段存储器管理方式"><a href="#5-5-请求分段存储器管理方式" class="headerlink" title="5.5.     请求分段存储器管理方式"></a>5.5.     请求分段存储器管理方式</h2><h3 id="5-5-1-概念"><a href="#5-5-1-概念" class="headerlink" title="5.5.1.     概念"></a>5.5.1.     概念</h3><h4 id="在基础分段存储管理基础上增加请求调段和段置换功能"><a href="#在基础分段存储管理基础上增加请求调段和段置换功能" class="headerlink" title="在基础分段存储管理基础上增加请求调段和段置换功能"></a>在基础分段存储管理基础上增加请求调段和段置换功能</h4><h4 id="基本单位：长度不固定的段"><a href="#基本单位：长度不固定的段" class="headerlink" title="基本单位：长度不固定的段"></a>基本单位：长度不固定的段</h4><h3 id="5-5-2-硬件支持"><a href="#5-5-2-硬件支持" class="headerlink" title="5.5.2.     硬件支持"></a>5.5.2.     硬件支持</h3><h4 id="1、进程页表：增加项-1"><a href="#1、进程页表：增加项-1" class="headerlink" title="1、进程页表：增加项"></a>1、进程页表：增加项</h4><h5 id="1、存取方式：只执行、只读、读-写"><a href="#1、存取方式：只执行、只读、读-写" class="headerlink" title="1、存取方式：只执行、只读、读/写"></a>1、存取方式：只执行、只读、读/写</h5><h5 id="2、增补位：是否动态增长"><a href="#2、增补位：是否动态增长" class="headerlink" title="2、增补位：是否动态增长"></a>2、增补位：是否动态增长</h5><h5 id="其他和请求分页一样"><a href="#其他和请求分页一样" class="headerlink" title="其他和请求分页一样"></a>其他和请求分页一样</h5><h4 id="2、缺段中断机构"><a href="#2、缺段中断机构" class="headerlink" title="2、缺段中断机构"></a>2、缺段中断机构</h4><h5 id="分段越界中断处理；分段保护中断处理；缺段中断处理"><a href="#分段越界中断处理；分段保护中断处理；缺段中断处理" class="headerlink" title="分段越界中断处理；分段保护中断处理；缺段中断处理"></a>分段越界中断处理；分段保护中断处理；缺段中断处理</h5><h4 id="3、地址变换机构-3"><a href="#3、地址变换机构-3" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h4><h5 id="在原基础上增加缺段中断，具体看PPT32"><a href="#在原基础上增加缺段中断，具体看PPT32" class="headerlink" title="在原基础上增加缺段中断，具体看PPT32"></a>在原基础上增加缺段中断，具体看PPT32</h5><h3 id="5-5-3-分段共享"><a href="#5-5-3-分段共享" class="headerlink" title="5.5.3.     分段共享"></a>5.5.3.     分段共享</h3><h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h5><h6 id="系统中配置一张，所有共享段在该表中都有一项PPT32"><a href="#系统中配置一张，所有共享段在该表中都有一项PPT32" class="headerlink" title="系统中配置一张，所有共享段在该表中都有一项PPT32"></a>系统中配置一张，所有共享段在该表中都有一项PPT32</h6><h4 id="共享段的分配与回收"><a href="#共享段的分配与回收" class="headerlink" title="共享段的分配与回收"></a>共享段的分配与回收</h4><h5 id="1、分配"><a href="#1、分配" class="headerlink" title="1、分配"></a>1、分配</h5><h6 id="首次用共享段，调入内存，填写共享段表项，置共享进程计数count-1"><a href="#首次用共享段，调入内存，填写共享段表项，置共享进程计数count-1" class="headerlink" title="首次用共享段，调入内存，填写共享段表项，置共享进程计数count=1"></a>首次用共享段，调入内存，填写共享段表项，置共享进程计数count=1</h6><h6 id="其他进程使用，count"><a href="#其他进程使用，count" class="headerlink" title="其他进程使用，count++"></a>其他进程使用，count++</h6><h5 id="2、回收"><a href="#2、回收" class="headerlink" title="2、回收"></a>2、回收</h5><h6 id="修改共享段表，count-0"><a href="#修改共享段表，count-0" class="headerlink" title="修改共享段表，count=0"></a>修改共享段表，count=0</h6><h6 id="将该段占用内存回收"><a href="#将该段占用内存回收" class="headerlink" title="将该段占用内存回收"></a>将该段占用内存回收</h6><h5 id="另外，共享段一般不放入外存"><a href="#另外，共享段一般不放入外存" class="headerlink" title="另外，共享段一般不放入外存"></a>另外，共享段一般不放入外存</h5><h3 id="5-5-4-分段保护"><a href="#5-5-4-分段保护" class="headerlink" title="5.5.4.     分段保护"></a>5.5.4.     分段保护</h3><h4 id="1、越界检查"><a href="#1、越界检查" class="headerlink" title="1、越界检查"></a>1、越界检查</h4><h4 id="2、存取控制检查"><a href="#2、存取控制检查" class="headerlink" title="2、存取控制检查"></a>2、存取控制检查</h4><h4 id="3、环保护机构"><a href="#3、环保护机构" class="headerlink" title="3、环保护机构"></a>3、环保护机构</h4><h5 id="低环有高优先权，OS在0环"><a href="#低环有高优先权，OS在0环" class="headerlink" title="低环有高优先权，OS在0环"></a>低环有高优先权，OS在0环</h5><h5 id="访问调用原则"><a href="#访问调用原则" class="headerlink" title="访问调用原则"></a>访问调用原则</h5><h6 id="一个程序可访问相同环或低优先权环的数据"><a href="#一个程序可访问相同环或低优先权环的数据" class="headerlink" title="一个程序可访问相同环或低优先权环的数据"></a>一个程序可访问相同环或低优先权环的数据</h6><h6 id="一个程序可调用相同环或高优先权环的数据"><a href="#一个程序可调用相同环或高优先权环的数据" class="headerlink" title="一个程序可调用相同环或高优先权环的数据"></a>一个程序可调用相同环或高优先权环的数据</h6><h1 id="6-六、设备管理"><a href="#6-六、设备管理" class="headerlink" title="6.    六、设备管理"></a>6.    六、设备管理</h1><h2 id="6-1-设备管理概述"><a href="#6-1-设备管理概述" class="headerlink" title="6.1.     设备管理概述"></a>6.1.     设备管理概述</h2><h3 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1.     概念"></a>6.1.1.     概念</h3><h4 id="OS中负责I-O设备管理的部分叫做I-O系统，完成设备管理功能，对OS影响非常大"><a href="#OS中负责I-O设备管理的部分叫做I-O系统，完成设备管理功能，对OS影响非常大" class="headerlink" title="OS中负责I/O设备管理的部分叫做I/O系统，完成设备管理功能，对OS影响非常大"></a>OS中负责I/O设备管理的部分叫做I/O系统，完成设备管理功能，对OS影响非常大</h4><h4 id="设备管理是最繁杂且与硬件关联最紧密的部分"><a href="#设备管理是最繁杂且与硬件关联最紧密的部分" class="headerlink" title="设备管理是最繁杂且与硬件关联最紧密的部分"></a>设备管理是最繁杂且与硬件关联最紧密的部分</h4><h3 id="6-1-2-主要对象"><a href="#6-1-2-主要对象" class="headerlink" title="6.1.2.     主要对象"></a>6.1.2.     主要对象</h3><h4 id="I-O设备，设备控制器，I-O通道"><a href="#I-O设备，设备控制器，I-O通道" class="headerlink" title="I/O设备，设备控制器，I/O通道"></a>I/O设备，设备控制器，I/O通道</h4><h3 id="6-1-3-基本任务"><a href="#6-1-3-基本任务" class="headerlink" title="6.1.3.     基本任务"></a>6.1.3.     基本任务</h3><h4 id="完成用户I-O请求，提高I-O效率，提高I-O设备利用率"><a href="#完成用户I-O请求，提高I-O效率，提高I-O设备利用率" class="headerlink" title="完成用户I/O请求，提高I/O效率，提高I/O设备利用率"></a>完成用户I/O请求，提高I/O效率，提高I/O设备利用率</h4><h3 id="6-1-4-主要功能"><a href="#6-1-4-主要功能" class="headerlink" title="6.1.4.     主要功能"></a>6.1.4.     主要功能</h3><h4 id="缓存区管理；设备分配-管理；虚拟存储；实现设备独立性"><a href="#缓存区管理；设备分配-管理；虚拟存储；实现设备独立性" class="headerlink" title="缓存区管理；设备分配/管理；虚拟存储；实现设备独立性"></a>缓存区管理；设备分配/管理；虚拟存储；实现设备独立性</h4><h2 id="6-2-I-O系统概述"><a href="#6-2-I-O系统概述" class="headerlink" title="6.2.     I/O系统概述"></a>6.2.     I/O系统概述</h2><h3 id="6-2-1-I-O系统组成"><a href="#6-2-1-I-O系统组成" class="headerlink" title="6.2.1.     I/O系统组成"></a>6.2.1.     I/O系统组成</h3><h4 id="I-O设备，设备控制器及接口，I-O通道，总线等"><a href="#I-O设备，设备控制器及接口，I-O通道，总线等" class="headerlink" title="I/O设备，设备控制器及接口，I/O通道，总线等"></a>I/O设备，设备控制器及接口，I/O通道，总线等</h4><h3 id="6-2-2-I-O设备类型"><a href="#6-2-2-I-O设备类型" class="headerlink" title="6.2.2.     I/O设备类型"></a>6.2.2.     I/O设备类型</h3><h4 id="1、按传输速率"><a href="#1、按传输速率" class="headerlink" title="1、按传输速率"></a>1、按传输速率</h4><h5 id="低-中-高速"><a href="#低-中-高速" class="headerlink" title="低/中/高速"></a>低/中/高速</h5><h4 id="2、按信息交换单位"><a href="#2、按信息交换单位" class="headerlink" title="2、按信息交换单位"></a>2、按信息交换单位</h4><h5 id="块设备——数据块为单位"><a href="#块设备——数据块为单位" class="headerlink" title="块设备——数据块为单位"></a>块设备——数据块为单位</h5><h5 id="字符设备——字符为单位"><a href="#字符设备——字符为单位" class="headerlink" title="字符设备——字符为单位"></a>字符设备——字符为单位</h5><h4 id="3、按设备共享属性"><a href="#3、按设备共享属性" class="headerlink" title="3、按设备共享属性"></a>3、按设备共享属性</h4><h5 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h5><h5 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h5><h5 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h5><h6 id="虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用"><a href="#虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用" class="headerlink" title="虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用"></a>虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用</h6><h3 id="6-2-3-设备与控制器之间的接口"><a href="#6-2-3-设备与控制器之间的接口" class="headerlink" title="6.2.3.     设备与控制器之间的接口"></a>6.2.3.     设备与控制器之间的接口</h3><h4 id="设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备"><a href="#设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备" class="headerlink" title="设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备"></a>设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备</h4><h4 id="控制器与设备传递的信号"><a href="#控制器与设备传递的信号" class="headerlink" title="控制器与设备传递的信号"></a>控制器与设备传递的信号</h4><h5 id="1、数据信号：控制器-gt-设备"><a href="#1、数据信号：控制器-gt-设备" class="headerlink" title="1、数据信号：控制器-&gt;设备"></a>1、数据信号：控制器-&gt;设备</h5><h5 id="2、控制信号：控制器-gt-设备"><a href="#2、控制信号：控制器-gt-设备" class="headerlink" title="2、控制信号：控制器-&gt;设备"></a>2、控制信号：控制器-&gt;设备</h5><h5 id="3、状态信号：设备-gt-控制器"><a href="#3、状态信号：设备-gt-控制器" class="headerlink" title="3、状态信号：设备-&gt;控制器"></a>3、状态信号：设备-&gt;控制器</h5><h2 id="6-3-设备管理目标"><a href="#6-3-设备管理目标" class="headerlink" title="6.3.     设备管理目标"></a>6.3.     设备管理目标</h2><h3 id="6-3-1-1、提供统一界面，方便用户使用"><a href="#6-3-1-1、提供统一界面，方便用户使用" class="headerlink" title="6.3.1.     1、提供统一界面，方便用户使用"></a>6.3.1.     1、提供统一界面，方便用户使用</h3><h3 id="6-3-2-2、发挥系统并行性，提高I-O使用效率"><a href="#6-3-2-2、发挥系统并行性，提高I-O使用效率" class="headerlink" title="6.3.2.     2、发挥系统并行性，提高I/O使用效率"></a>6.3.2.     2、发挥系统并行性，提高I/O使用效率</h3><h3 id="6-3-3-3、设备保护：实现设备的正确安全使用"><a href="#6-3-3-3、设备保护：实现设备的正确安全使用" class="headerlink" title="6.3.3.     3、设备保护：实现设备的正确安全使用"></a>6.3.3.     3、设备保护：实现设备的正确安全使用</h3><h2 id="6-4-缓冲管理"><a href="#6-4-缓冲管理" class="headerlink" title="6.4.     缓冲管理"></a>6.4.     缓冲管理</h2><h3 id="6-4-1-概念"><a href="#6-4-1-概念" class="headerlink" title="6.4.1.     概念"></a>6.4.1.     概念</h3><h4 id="缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域"><a href="#缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域" class="headerlink" title="缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域"></a>缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域</h4><h3 id="6-4-2-引入缓冲区原因"><a href="#6-4-2-引入缓冲区原因" class="headerlink" title="6.4.2.     引入缓冲区原因"></a>6.4.2.     引入缓冲区原因</h3><h4 id="1、处理数据的生产者和消费者速度不匹配"><a href="#1、处理数据的生产者和消费者速度不匹配" class="headerlink" title="1、处理数据的生产者和消费者速度不匹配"></a>1、处理数据的生产者和消费者速度不匹配</h4><h4 id="2、协调传输速度不一致的设备"><a href="#2、协调传输速度不一致的设备" class="headerlink" title="2、协调传输速度不一致的设备"></a>2、协调传输速度不一致的设备</h4><h4 id="3、减少CPU中断频率"><a href="#3、减少CPU中断频率" class="headerlink" title="3、减少CPU中断频率"></a>3、减少CPU中断频率</h4><h4 id="4、提高CPU和I-O设备之间的并行性"><a href="#4、提高CPU和I-O设备之间的并行性" class="headerlink" title="4、提高CPU和I/O设备之间的并行性"></a>4、提高CPU和I/O设备之间的并行性</h4><h3 id="6-4-3-缓冲区分类"><a href="#6-4-3-缓冲区分类" class="headerlink" title="6.4.3.     缓冲区分类"></a>6.4.3.     缓冲区分类</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><h5 id="一个缓冲区，CPU外设轮流使用"><a href="#一个缓冲区，CPU外设轮流使用" class="headerlink" title="一个缓冲区，CPU外设轮流使用"></a>一个缓冲区，CPU外设轮流使用</h5><h4 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h4><h5 id="两个缓冲区，CPU和外设处理速度相近，可以连续处理"><a href="#两个缓冲区，CPU和外设处理速度相近，可以连续处理" class="headerlink" title="两个缓冲区，CPU和外设处理速度相近，可以连续处理"></a>两个缓冲区，CPU和外设处理速度相近，可以连续处理</h5><h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><h5 id="环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大"><a href="#环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大" class="headerlink" title="环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大"></a>环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大</h5><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><h5 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h5><h6 id="1、空闲缓冲区队列emq"><a href="#1、空闲缓冲区队列emq" class="headerlink" title="1、空闲缓冲区队列emq"></a>1、空闲缓冲区队列emq</h6><h6 id="2、输入缓冲区队列inq"><a href="#2、输入缓冲区队列inq" class="headerlink" title="2、输入缓冲区队列inq"></a>2、输入缓冲区队列inq</h6><h6 id="3、输出缓冲区队列outq"><a href="#3、输出缓冲区队列outq" class="headerlink" title="3、输出缓冲区队列outq"></a>3、输出缓冲区队列outq</h6><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><h6 id="1、收容输入"><a href="#1、收容输入" class="headerlink" title="1、收容输入"></a>1、收容输入</h6><p>设备输入data</p>
<h6 id="2、提取输入"><a href="#2、提取输入" class="headerlink" title="2、提取输入"></a>2、提取输入</h6><p>计算机读入data</p>
<h6 id="3、收容输出"><a href="#3、收容输出" class="headerlink" title="3、收容输出"></a>3、收容输出</h6><p>计算机输出data</p>
<h6 id="4、提取输出"><a href="#4、提取输出" class="headerlink" title="4、提取输出"></a>4、提取输出</h6><p>向设备输出data</p>
<h2 id="6-5-I-O软件"><a href="#6-5-I-O软件" class="headerlink" title="6.5.     I/O软件"></a>6.5.     I/O软件</h2><h3 id="6-5-1-设计目标"><a href="#6-5-1-设计目标" class="headerlink" title="6.5.1.     设计目标"></a>6.5.1.     设计目标</h3><h4 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h4><h5 id="确保I-O设备与CPU并发性，提高资源利用率"><a href="#确保I-O设备与CPU并发性，提高资源利用率" class="headerlink" title="确保I/O设备与CPU并发性，提高资源利用率"></a>确保I/O设备与CPU并发性，提高资源利用率</h5><h4 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h4><h5 id="提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作"><a href="#提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作" class="headerlink" title="提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作"></a>提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作</h5><h3 id="6-5-2-采用方式"><a href="#6-5-2-采用方式" class="headerlink" title="6.5.2.     采用方式"></a>6.5.2.     采用方式</h3><h4 id="抽象、包装、软件分层"><a href="#抽象、包装、软件分层" class="headerlink" title="抽象、包装、软件分层"></a>抽象、包装、软件分层</h4><h3 id="6-5-3-应达到的目标"><a href="#6-5-3-应达到的目标" class="headerlink" title="6.5.3.     应达到的目标"></a>6.5.3.     应达到的目标</h3><h4 id="1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射"><a href="#1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射" class="headerlink" title="1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射"></a>1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射</h4><h4 id="2、统一命令"><a href="#2、统一命令" class="headerlink" title="2、统一命令"></a>2、统一命令</h4><h4 id="3、对错误的处理：尽可能低层处理，不涉及高层"><a href="#3、对错误的处理：尽可能低层处理，不涉及高层" class="headerlink" title="3、对错误的处理：尽可能低层处理，不涉及高层"></a>3、对错误的处理：尽可能低层处理，不涉及高层</h4><h4 id="4、缓冲技术"><a href="#4、缓冲技术" class="headerlink" title="4、缓冲技术"></a>4、缓冲技术</h4><h4 id="5、设备的分配和回收"><a href="#5、设备的分配和回收" class="headerlink" title="5、设备的分配和回收"></a>5、设备的分配和回收</h4><h4 id="6、I-O控制方式：不同设备的控制方式不同"><a href="#6、I-O控制方式：不同设备的控制方式不同" class="headerlink" title="6、I/O控制方式：不同设备的控制方式不同"></a>6、I/O控制方式：不同设备的控制方式不同</h4><h3 id="6-5-4-层次结构"><a href="#6-5-4-层次结构" class="headerlink" title="6.5.4.     层次结构"></a>6.5.4.     层次结构</h3><h4 id="1、用户空间软件"><a href="#1、用户空间软件" class="headerlink" title="1、用户空间软件"></a>1、用户空间软件</h4><h5 id="用户层软件必须通过一组系统调用获取OS服务"><a href="#用户层软件必须通过一组系统调用获取OS服务" class="headerlink" title="用户层软件必须通过一组系统调用获取OS服务"></a>用户层软件必须通过一组系统调用获取OS服务</h5><h4 id="2、与设备无关的OS软件（无关层）"><a href="#2、与设备无关的OS软件（无关层）" class="headerlink" title="2、与设备无关的OS软件（无关层）"></a>2、与设备无关的OS软件（无关层）</h4><h5 id="设备独立性概念"><a href="#设备独立性概念" class="headerlink" title="设备独立性概念"></a>设备独立性概念</h5><h6 id="基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件"><a href="#基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件" class="headerlink" title="基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件"></a>基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件</h6><h6 id="设备独立性软件设置在驱动程序之上，界限因OS的不同而不同"><a href="#设备独立性软件设置在驱动程序之上，界限因OS的不同而不同" class="headerlink" title="设备独立性软件设置在驱动程序之上，界限因OS的不同而不同"></a>设备独立性软件设置在驱动程序之上，界限因OS的不同而不同</h6><h6 id="使应用程序独立于物理设备"><a href="#使应用程序独立于物理设备" class="headerlink" title="使应用程序独立于物理设备"></a>使应用程序独立于物理设备</h6><h5 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="1、引入物理设备、逻辑设备"><a href="#1、引入物理设备、逻辑设备" class="headerlink" title="1、引入物理设备、逻辑设备"></a>1、引入物理设备、逻辑设备</h6><h6 id="2、应用程序通过逻辑设备名调用设备，OS负责转换"><a href="#2、应用程序通过逻辑设备名调用设备，OS负责转换" class="headerlink" title="2、应用程序通过逻辑设备名调用设备，OS负责转换"></a>2、应用程序通过逻辑设备名调用设备，OS负责转换</h6><h5 id="设备独立性好处"><a href="#设备独立性好处" class="headerlink" title="设备独立性好处"></a>设备独立性好处</h5><h6 id="1、设备分配的灵活性"><a href="#1、设备分配的灵活性" class="headerlink" title="1、设备分配的灵活性"></a>1、设备分配的灵活性</h6><h6 id="2、实现I-O重定向：实现I-O操作的设备可更换，而不用改变应用程序"><a href="#2、实现I-O重定向：实现I-O操作的设备可更换，而不用改变应用程序" class="headerlink" title="2、实现I/O重定向：实现I/O操作的设备可更换，而不用改变应用程序"></a>2、实现I/O重定向：实现I/O操作的设备可更换，而不用改变应用程序</h6><h5 id="设备独立性软件功能"><a href="#设备独立性软件功能" class="headerlink" title="设备独立性软件功能"></a>设备独立性软件功能</h5><h6 id="1、执行所有设备的公有操作"><a href="#1、执行所有设备的公有操作" class="headerlink" title="1、执行所有设备的公有操作"></a>1、执行所有设备的公有操作</h6><h6 id="2、向用户层软件提供统一接口"><a href="#2、向用户层软件提供统一接口" class="headerlink" title="2、向用户层软件提供统一接口"></a>2、向用户层软件提供统一接口</h6><h5 id="逻辑设备映射到物理设备的方式"><a href="#逻辑设备映射到物理设备的方式" class="headerlink" title="逻辑设备映射到物理设备的方式"></a>逻辑设备映射到物理设备的方式</h5><h6 id="1、逻辑设备表LUT"><a href="#1、逻辑设备表LUT" class="headerlink" title="1、逻辑设备表LUT"></a>1、逻辑设备表LUT</h6><p>逻辑设备名+物理设备名+驱动程序入口地址</p>
<h6 id="2、LUT的实现可以采用两种方式"><a href="#2、LUT的实现可以采用两种方式" class="headerlink" title="2、LUT的实现可以采用两种方式"></a>2、LUT的实现可以采用两种方式</h6><p>整个系统一张（逻辑设备名不能相同）；每个用户一张，放入PCB中</p>
<h4 id="3、设备驱动程序（驱动层）"><a href="#3、设备驱动程序（驱动层）" class="headerlink" title="3、设备驱动程序（驱动层）"></a>3、设备驱动程序（驱动层）</h4><h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><h6 id="1、抽象要求转具体要求"><a href="#1、抽象要求转具体要求" class="headerlink" title="1、抽象要求转具体要求"></a>1、抽象要求转具体要求</h6><h6 id="2、检查I-O请求合法性"><a href="#2、检查I-O请求合法性" class="headerlink" title="2、检查I/O请求合法性"></a>2、检查I/O请求合法性</h6><h6 id="3、读出和检查设备状态"><a href="#3、读出和检查设备状态" class="headerlink" title="3、读出和检查设备状态"></a>3、读出和检查设备状态</h6><h6 id="4、传送参数"><a href="#4、传送参数" class="headerlink" title="4、传送参数"></a>4、传送参数</h6><h6 id="5、设置工作方式"><a href="#5、设置工作方式" class="headerlink" title="5、设置工作方式"></a>5、设置工作方式</h6><h6 id="6、启动I-O设备"><a href="#6、启动I-O设备" class="headerlink" title="6、启动I/O设备"></a>6、启动I/O设备</h6><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><h6 id="1、I-O请求进程与设备控制器之间的桥梁，中转数据和控制"><a href="#1、I-O请求进程与设备控制器之间的桥梁，中转数据和控制" class="headerlink" title="1、I/O请求进程与设备控制器之间的桥梁，中转数据和控制"></a>1、I/O请求进程与设备控制器之间的桥梁，中转数据和控制</h6><h6 id="2、与I-O设备特性、控制方式、硬件密切相关"><a href="#2、与I-O设备特性、控制方式、硬件密切相关" class="headerlink" title="2、与I/O设备特性、控制方式、硬件密切相关"></a>2、与I/O设备特性、控制方式、硬件密切相关</h6><h6 id="3、向上屏蔽设备细节"><a href="#3、向上屏蔽设备细节" class="headerlink" title="3、向上屏蔽设备细节"></a>3、向上屏蔽设备细节</h6><h6 id="4、驱动程序允许可重入"><a href="#4、驱动程序允许可重入" class="headerlink" title="4、驱动程序允许可重入"></a>4、驱动程序允许可重入</h6><h4 id="4、中断处理程序"><a href="#4、中断处理程序" class="headerlink" title="4、中断处理程序"></a>4、中断处理程序</h4><h4 id="5、硬件"><a href="#5、硬件" class="headerlink" title="5、硬件"></a>5、硬件</h4><h4 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h4><h5 id="功能上看，无关层为I-O管理的主要部分"><a href="#功能上看，无关层为I-O管理的主要部分" class="headerlink" title="功能上看，无关层为I/O管理的主要部分"></a>功能上看，无关层为I/O管理的主要部分</h5><h5 id="代码量上看，驱动层为I-O管理的主要部分"><a href="#代码量上看，驱动层为I-O管理的主要部分" class="headerlink" title="代码量上看，驱动层为I/O管理的主要部分"></a>代码量上看，驱动层为I/O管理的主要部分</h5><h3 id="6-5-5-设备分配与回收"><a href="#6-5-5-设备分配与回收" class="headerlink" title="6.5.5.     设备分配与回收"></a>6.5.5.     设备分配与回收</h3><h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><h5 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="1、系统设备表SDT"><a href="#1、系统设备表SDT" class="headerlink" title="1、系统设备表SDT"></a>1、系统设备表SDT</h6><h6 id="2、设备控制表DCT"><a href="#2、设备控制表DCT" class="headerlink" title="2、设备控制表DCT"></a>2、设备控制表DCT</h6><h6 id="3、控制器控制表COCT"><a href="#3、控制器控制表COCT" class="headerlink" title="3、控制器控制表COCT"></a>3、控制器控制表COCT</h6><h6 id="4、通道控制表CHCT"><a href="#4、通道控制表CHCT" class="headerlink" title="4、通道控制表CHCT"></a>4、通道控制表CHCT</h6><h5 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h5><h6 id="1、设备固有属性"><a href="#1、设备固有属性" class="headerlink" title="1、设备固有属性"></a>1、设备固有属性</h6><p>独享；共享；虚拟设备</p>
<h6 id="2、设备分配算法"><a href="#2、设备分配算法" class="headerlink" title="2、设备分配算法"></a>2、设备分配算法</h6><p>先来先服务（FCFS）</p>
<p>基于优先级</p>
<h6 id="3、设备分配的安全性"><a href="#3、设备分配的安全性" class="headerlink" title="3、设备分配的安全性"></a>3、设备分配的安全性</h6><p>安全分配方式：进程发出I/O后阻塞，不占用OS资源</p>
<p>不安全分配方式：多个设备并行操作；可能造成死锁</p>
<h5 id="独占设备的分配程序"><a href="#独占设备的分配程序" class="headerlink" title="独占设备的分配程序"></a>独占设备的分配程序</h5><h6 id="1、分配设备"><a href="#1、分配设备" class="headerlink" title="1、分配设备"></a>1、分配设备</h6><h6 id="2、分配控制器"><a href="#2、分配控制器" class="headerlink" title="2、分配控制器"></a>2、分配控制器</h6><h6 id="3、分配通道"><a href="#3、分配通道" class="headerlink" title="3、分配通道"></a>3、分配通道</h6><h4 id="SPOOLing技术（假脱机）"><a href="#SPOOLing技术（假脱机）" class="headerlink" title="SPOOLing技术（假脱机）"></a>SPOOLing技术（假脱机）</h4><h5 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h5><h6 id="联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机"><a href="#联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机" class="headerlink" title="联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机"></a>联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机</h6><h6 id="联机I-O，主机直接控制I-O"><a href="#联机I-O，主机直接控制I-O" class="headerlink" title="联机I/O，主机直接控制I/O"></a>联机I/O，主机直接控制I/O</h6><h6 id="脱机I-O，一台外围机控制器代替主机控制I-O"><a href="#脱机I-O，一台外围机控制器代替主机控制I-O" class="headerlink" title="脱机I/O，一台外围机控制器代替主机控制I/O"></a>脱机I/O，一台外围机控制器代替主机控制I/O</h6><h6 id="SPOOLing用联机I-O模拟脱机I-O工作"><a href="#SPOOLing用联机I-O模拟脱机I-O工作" class="headerlink" title="SPOOLing用联机I/O模拟脱机I/O工作"></a>SPOOLing用联机I/O模拟脱机I/O工作</h6><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><h6 id="SPOOLing程序预先从外设输入data并缓冲，称为输入井-时机合适输入到应用程序"><a href="#SPOOLing程序预先从外设输入data并缓冲，称为输入井-时机合适输入到应用程序" class="headerlink" title="SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序"></a>SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序</h6><h6 id="SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设"><a href="#SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设" class="headerlink" title="SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设"></a>SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设</h6><h6 id="以上称为实际I-O"><a href="#以上称为实际I-O" class="headerlink" title="以上称为实际I/O"></a>以上称为实际I/O</h6><h6 id="缓冲池中读入和读出就不是实际I-O"><a href="#缓冲池中读入和读出就不是实际I-O" class="headerlink" title="缓冲池中读入和读出就不是实际I/O"></a>缓冲池中读入和读出就不是实际I/O</h6><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><h6 id="1、输入井和输出井：在磁盘"><a href="#1、输入井和输出井：在磁盘" class="headerlink" title="1、输入井和输出井：在磁盘"></a>1、输入井和输出井：在磁盘</h6><h6 id="2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾"><a href="#2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾" class="headerlink" title="2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾"></a>2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾</h6><h6 id="3、输入进程和输出进程：守护进程"><a href="#3、输入进程和输出进程：守护进程" class="headerlink" title="3、输入进程和输出进程：守护进程"></a>3、输入进程和输出进程：守护进程</h6><h5 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h5><h6 id="1、高速虚拟I-O操作"><a href="#1、高速虚拟I-O操作" class="headerlink" title="1、高速虚拟I/O操作"></a>1、高速虚拟I/O操作</h6><h6 id="2、实现独享设备的共享"><a href="#2、实现独享设备的共享" class="headerlink" title="2、实现独享设备的共享"></a>2、实现独享设备的共享</h6><h6 id="3、SPOOLing程序提供虚拟设备"><a href="#3、SPOOLing程序提供虚拟设备" class="headerlink" title="3、SPOOLing程序提供虚拟设备"></a>3、SPOOLing程序提供虚拟设备</h6><h2 id="6-6-磁盘调度"><a href="#6-6-磁盘调度" class="headerlink" title="6.6.     磁盘调度"></a>6.6.     磁盘调度</h2><h3 id="6-6-1-磁盘存储器管理"><a href="#6-6-1-磁盘存储器管理" class="headerlink" title="6.6.1.     磁盘存储器管理"></a>6.6.1.     磁盘存储器管理</h3><h4 id="磁盘存储器：随机读写、共享设备，可移动介质"><a href="#磁盘存储器：随机读写、共享设备，可移动介质" class="headerlink" title="磁盘存储器：随机读写、共享设备，可移动介质"></a>磁盘存储器：随机读写、共享设备，可移动介质</h4><h4 id="特点：容量大，速度快"><a href="#特点：容量大，速度快" class="headerlink" title="特点：容量大，速度快"></a>特点：容量大，速度快</h4><h4 id="管理要求：合理分配空间，访问效率高。容错强。"><a href="#管理要求：合理分配空间，访问效率高。容错强。" class="headerlink" title="管理要求：合理分配空间，访问效率高。容错强。"></a>管理要求：合理分配空间，访问效率高。容错强。</h4><h4 id="其性能直接影响文件系统的性能指标"><a href="#其性能直接影响文件系统的性能指标" class="headerlink" title="其性能直接影响文件系统的性能指标"></a>其性能直接影响文件系统的性能指标</h4><h3 id="6-6-2-磁盘性能"><a href="#6-6-2-磁盘性能" class="headerlink" title="6.6.2.     磁盘性能"></a>6.6.2.     磁盘性能</h3><h4 id="数据的组织"><a href="#数据的组织" class="headerlink" title="数据的组织"></a>数据的组织</h4><h5 id="地址格式：驱动器号-磁道号-磁头号-扇区号"><a href="#地址格式：驱动器号-磁道号-磁头号-扇区号" class="headerlink" title="地址格式：驱动器号+磁道号+磁头号+扇区号"></a>地址格式：驱动器号+磁道号+磁头号+扇区号</h5><h4 id="磁盘类型"><a href="#磁盘类型" class="headerlink" title="磁盘类型"></a>磁盘类型</h4><h5 id="固定头磁盘；移动头磁盘"><a href="#固定头磁盘；移动头磁盘" class="headerlink" title="固定头磁盘；移动头磁盘"></a>固定头磁盘；移动头磁盘</h5><h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><h5 id="寻道时间-旋转延迟时间-传输时间"><a href="#寻道时间-旋转延迟时间-传输时间" class="headerlink" title="寻道时间+旋转延迟时间+传输时间"></a>寻道时间+旋转延迟时间+传输时间</h5><h5 id="寻道时间是主要影响参数"><a href="#寻道时间是主要影响参数" class="headerlink" title="寻道时间是主要影响参数"></a>寻道时间是主要影响参数</h5><h4 id="提高速度的途径"><a href="#提高速度的途径" class="headerlink" title="提高速度的途径"></a>提高速度的途径</h4><h5 id="1、硬件解决"><a href="#1、硬件解决" class="headerlink" title="1、硬件解决"></a>1、硬件解决</h5><h5 id="2、好的调度算法"><a href="#2、好的调度算法" class="headerlink" title="2、好的调度算法"></a>2、好的调度算法</h5><h6 id="减少寻道时间"><a href="#减少寻道时间" class="headerlink" title="减少寻道时间"></a>减少寻道时间</h6><h5 id="3、缓冲区"><a href="#3、缓冲区" class="headerlink" title="3、缓冲区"></a>3、缓冲区</h5><h3 id="6-6-3-调度算法"><a href="#6-6-3-调度算法" class="headerlink" title="6.6.3.     调度算法"></a>6.6.3.     调度算法</h3><h4 id="1、先来先服务"><a href="#1、先来先服务" class="headerlink" title="1、先来先服务"></a>1、先来先服务</h4><h5 id="执行顺序为磁盘I-O请求先后顺序"><a href="#执行顺序为磁盘I-O请求先后顺序" class="headerlink" title="执行顺序为磁盘I/O请求先后顺序"></a>执行顺序为磁盘I/O请求先后顺序</h5><h4 id="2、最短寻道时间优先（SSTF）"><a href="#2、最短寻道时间优先（SSTF）" class="headerlink" title="2、最短寻道时间优先（SSTF）"></a>2、最短寻道时间优先（SSTF）</h4><h5 id="选择距当前磁头移动最少的磁盘I-O请求"><a href="#选择距当前磁头移动最少的磁盘I-O请求" class="headerlink" title="选择距当前磁头移动最少的磁盘I/O请求"></a>选择距当前磁头移动最少的磁盘I/O请求</h5><h5 id="不能保证平均寻道时间最短，进程可能饿死"><a href="#不能保证平均寻道时间最短，进程可能饿死" class="headerlink" title="不能保证平均寻道时间最短，进程可能饿死"></a>不能保证平均寻道时间最短，进程可能饿死</h5><h4 id="3、扫描算法（SCAN）"><a href="#3、扫描算法（SCAN）" class="headerlink" title="3、扫描算法（SCAN）"></a>3、扫描算法（SCAN）</h4><h5 id="（电梯调度算法）选择当前磁头前进方向上移动距离最少的I-O请求，没有前进方向的请求才改变方向"><a href="#（电梯调度算法）选择当前磁头前进方向上移动距离最少的I-O请求，没有前进方向的请求才改变方向" class="headerlink" title="（电梯调度算法）选择当前磁头前进方向上移动距离最少的I/O请求，没有前进方向的请求才改变方向"></a>（电梯调度算法）选择当前磁头前进方向上移动距离最少的I/O请求，没有前进方向的请求才改变方向</h5><h5 id="SSTF的改进，没有进程饿死"><a href="#SSTF的改进，没有进程饿死" class="headerlink" title="SSTF的改进，没有进程饿死"></a>SSTF的改进，没有进程饿死</h5><h4 id="4、循环扫描算法（CSCAN）"><a href="#4、循环扫描算法（CSCAN）" class="headerlink" title="4、循环扫描算法（CSCAN）"></a>4、循环扫描算法（CSCAN）</h4><h5 id="选定一个方向扫描，到末尾再返回最里欲访问的磁道"><a href="#选定一个方向扫描，到末尾再返回最里欲访问的磁道" class="headerlink" title="选定一个方向扫描，到末尾再返回最里欲访问的磁道"></a>选定一个方向扫描，到末尾再返回最里欲访问的磁道</h5><h5 id="负载或重负载时，磁盘I-O性能比扫描算法好"><a href="#负载或重负载时，磁盘I-O性能比扫描算法好" class="headerlink" title="负载或重负载时，磁盘I/O性能比扫描算法好"></a>负载或重负载时，磁盘I/O性能比扫描算法好</h5><h4 id="5、N-Step-SCAN算法"><a href="#5、N-Step-SCAN算法" class="headerlink" title="5、N-Step-SCAN算法"></a>5、N-Step-SCAN算法</h4><h5 id="磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法"><a href="#磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法" class="headerlink" title="磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法"></a>磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法</h5><h5 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h5><h6 id="解决磁臂黏着问题"><a href="#解决磁臂黏着问题" class="headerlink" title="解决磁臂黏着问题"></a>解决磁臂黏着问题</h6><h4 id="6、FSCAN调度算法"><a href="#6、FSCAN调度算法" class="headerlink" title="6、FSCAN调度算法"></a>6、FSCAN调度算法</h4><h5 id="磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法"><a href="#磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法" class="headerlink" title="磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法"></a>磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法</h5><h5 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h5><h6 id="解决磁臂黏着问题-1"><a href="#解决磁臂黏着问题-1" class="headerlink" title="解决磁臂黏着问题"></a>解决磁臂黏着问题</h6><h3 id="6-6-4-磁盘高速缓存"><a href="#6-6-4-磁盘高速缓存" class="headerlink" title="6.6.4.     磁盘高速缓存"></a>6.6.4.     磁盘高速缓存</h3><h4 id="概念-16"><a href="#概念-16" class="headerlink" title="概念"></a>概念</h4><h5 id="利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存"><a href="#利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存" class="headerlink" title="利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存"></a>利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存</h5><h4 id="1、磁盘高速缓存形式"><a href="#1、磁盘高速缓存形式" class="headerlink" title="1、磁盘高速缓存形式"></a>1、磁盘高速缓存形式</h4><h5 id="大小固定"><a href="#大小固定" class="headerlink" title="大小固定"></a>大小固定</h5><h5 id="未利用的内存空间组成缓冲池"><a href="#未利用的内存空间组成缓冲池" class="headerlink" title="未利用的内存空间组成缓冲池"></a>未利用的内存空间组成缓冲池</h5><h4 id="2、数据交付方式"><a href="#2、数据交付方式" class="headerlink" title="2、数据交付方式"></a>2、数据交付方式</h4><h5 id="1、磁盘高速缓存中的数据直接传送到请求进程的内存区"><a href="#1、磁盘高速缓存中的数据直接传送到请求进程的内存区" class="headerlink" title="1、磁盘高速缓存中的数据直接传送到请求进程的内存区"></a>1、磁盘高速缓存中的数据直接传送到请求进程的内存区</h5><h5 id="2、磁盘高速缓存中的数据指针传送到请求进程的内存区"><a href="#2、磁盘高速缓存中的数据指针传送到请求进程的内存区" class="headerlink" title="2、磁盘高速缓存中的数据指针传送到请求进程的内存区"></a>2、磁盘高速缓存中的数据指针传送到请求进程的内存区</h5><h4 id="3、置换算法"><a href="#3、置换算法" class="headerlink" title="3、置换算法"></a>3、置换算法</h4><h5 id="LRU-NRU-最少使用算法"><a href="#LRU-NRU-最少使用算法" class="headerlink" title="LRU/NRU/最少使用算法"></a>LRU/NRU/最少使用算法</h5><h4 id="如何保持数据的一致性"><a href="#如何保持数据的一致性" class="headerlink" title="如何保持数据的一致性"></a>如何保持数据的一致性</h4><h5 id="备用电源"><a href="#备用电源" class="headerlink" title="备用电源"></a>备用电源</h5><h5 id="OS定期回写"><a href="#OS定期回写" class="headerlink" title="OS定期回写"></a>OS定期回写</h5><h3 id="6-6-5-提高磁盘I-O速度的其他方法"><a href="#6-6-5-提高磁盘I-O速度的其他方法" class="headerlink" title="6.6.5.     提高磁盘I/O速度的其他方法"></a>6.6.5.     提高磁盘I/O速度的其他方法</h3><h4 id="1、提前读"><a href="#1、提前读" class="headerlink" title="1、提前读"></a>1、提前读</h4><h4 id="2、延迟写"><a href="#2、延迟写" class="headerlink" title="2、延迟写"></a>2、延迟写</h4><h4 id="3、优化物理块的分布"><a href="#3、优化物理块的分布" class="headerlink" title="3、优化物理块的分布"></a>3、优化物理块的分布</h4><h4 id="4、虚拟盘"><a href="#4、虚拟盘" class="headerlink" title="4、虚拟盘"></a>4、虚拟盘</h4><h1 id="7-七、文件管理"><a href="#7-七、文件管理" class="headerlink" title="7.    七、文件管理"></a>7.    七、文件管理</h1><h2 id="7-1-文件管理概述"><a href="#7-1-文件管理概述" class="headerlink" title="7.1.     文件管理概述"></a>7.1.     文件管理概述</h2><h3 id="7-1-1-负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能"><a href="#7-1-1-负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能" class="headerlink" title="7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能"></a>7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能</h3><h2 id="7-2-数据分类"><a href="#7-2-数据分类" class="headerlink" title="7.2.     数据分类"></a>7.2.     数据分类</h2><h3 id="7-2-1-数据项"><a href="#7-2-1-数据项" class="headerlink" title="7.2.1.     数据项"></a>7.2.1.     数据项</h3><h4 id="基本数据项"><a href="#基本数据项" class="headerlink" title="基本数据项"></a>基本数据项</h4><h4 id="组合数据项"><a href="#组合数据项" class="headerlink" title="组合数据项"></a>组合数据项</h4><h3 id="7-2-2-记录"><a href="#7-2-2-记录" class="headerlink" title="7.2.2.     记录"></a>7.2.2.     记录</h3><h4 id="一组相关数据项的集合，由于描述一个对象在某方面的属性"><a href="#一组相关数据项的集合，由于描述一个对象在某方面的属性" class="headerlink" title="一组相关数据项的集合，由于描述一个对象在某方面的属性"></a>一组相关数据项的集合，由于描述一个对象在某方面的属性</h4><h3 id="7-2-3-文件"><a href="#7-2-3-文件" class="headerlink" title="7.2.3.     文件"></a>7.2.3.     文件</h3><h4 id="创建者定义，具有文件名的一组相关元素的集合"><a href="#创建者定义，具有文件名的一组相关元素的集合" class="headerlink" title="创建者定义，具有文件名的一组相关元素的集合"></a>创建者定义，具有文件名的一组相关元素的集合</h4><h4 id="文件体（文件本身信息）-文件属性（文件存储和管理信息）"><a href="#文件体（文件本身信息）-文件属性（文件存储和管理信息）" class="headerlink" title="文件体（文件本身信息）+文件属性（文件存储和管理信息）"></a>文件体（文件本身信息）+文件属性（文件存储和管理信息）</h4><h4 id="文件属性：类型-长度-物理位置-建立时间"><a href="#文件属性：类型-长度-物理位置-建立时间" class="headerlink" title="文件属性：类型/长度/物理位置/建立时间"></a>文件属性：类型/长度/物理位置/建立时间</h4><h2 id="7-3-文件系统"><a href="#7-3-文件系统" class="headerlink" title="7.3.     文件系统"></a>7.3.     文件系统</h2><h3 id="7-3-1-文件类型"><a href="#7-3-1-文件类型" class="headerlink" title="7.3.1.     文件类型"></a>7.3.1.     文件类型</h3><h4 id="1、用途"><a href="#1、用途" class="headerlink" title="1、用途"></a>1、用途</h4><h5 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h5><h5 id="用户文件"><a href="#用户文件" class="headerlink" title="用户文件"></a>用户文件</h5><h5 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h5><h4 id="2、数据形式"><a href="#2、数据形式" class="headerlink" title="2、数据形式"></a>2、数据形式</h4><h5 id="源文件（ASCII-汉字）"><a href="#源文件（ASCII-汉字）" class="headerlink" title="源文件（ASCII/汉字）"></a>源文件（ASCII/汉字）</h5><h5 id="目标文件（obj）"><a href="#目标文件（obj）" class="headerlink" title="目标文件（obj）"></a>目标文件（obj）</h5><h5 id="可执行文件（exe）"><a href="#可执行文件（exe）" class="headerlink" title="可执行文件（exe）"></a>可执行文件（exe）</h5><h4 id="3、存取控制属性"><a href="#3、存取控制属性" class="headerlink" title="3、存取控制属性"></a>3、存取控制属性</h4><h5 id="只执行文件"><a href="#只执行文件" class="headerlink" title="只执行文件"></a>只执行文件</h5><h5 id="只读文件"><a href="#只读文件" class="headerlink" title="只读文件"></a>只读文件</h5><h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><h4 id="4、组织形式和处理方式"><a href="#4、组织形式和处理方式" class="headerlink" title="4、组织形式和处理方式"></a>4、组织形式和处理方式</h4><h5 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h5><h5 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h5><h5 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h5><h6 id="各类I-O设备"><a href="#各类I-O设备" class="headerlink" title="各类I/O设备"></a>各类I/O设备</h6><h3 id="7-3-2-文件系统层次结构"><a href="#7-3-2-文件系统层次结构" class="headerlink" title="7.3.2.     文件系统层次结构"></a>7.3.2.     文件系统层次结构</h3><h4 id="从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口"><a href="#从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口" class="headerlink" title="从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口"></a>从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口</h4><h4 id="对象及其属性"><a href="#对象及其属性" class="headerlink" title="对象及其属性"></a>对象及其属性</h4><h5 id="文件-目录-磁盘存储空间"><a href="#文件-目录-磁盘存储空间" class="headerlink" title="文件/目录/磁盘存储空间"></a>文件/目录/磁盘存储空间</h5><h4 id="对对象操纵和管理的软件集合-核心）"><a href="#对对象操纵和管理的软件集合-核心）" class="headerlink" title="对对象操纵和管理的软件集合(核心）"></a>对对象操纵和管理的软件集合(核心）</h4><h5 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h5><h6 id="1、文件存储空间管理-1"><a href="#1、文件存储空间管理-1" class="headerlink" title="1、文件存储空间管理"></a>1、文件存储空间管理</h6><h6 id="2、文件目录管理"><a href="#2、文件目录管理" class="headerlink" title="2、文件目录管理"></a>2、文件目录管理</h6><h6 id="3、文件逻辑地址和物理地址的转换"><a href="#3、文件逻辑地址和物理地址的转换" class="headerlink" title="3、文件逻辑地址和物理地址的转换"></a>3、文件逻辑地址和物理地址的转换</h6><h6 id="4、文件读和写管理"><a href="#4、文件读和写管理" class="headerlink" title="4、文件读和写管理"></a>4、文件读和写管理</h6><h6 id="5、文件共享和保护"><a href="#5、文件共享和保护" class="headerlink" title="5、文件共享和保护"></a>5、文件共享和保护</h6><h4 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h4><h5 id="1、命令接口-1"><a href="#1、命令接口-1" class="headerlink" title="1、命令接口"></a>1、命令接口</h5><h5 id="2、程序接口-1"><a href="#2、程序接口-1" class="headerlink" title="2、程序接口"></a>2、程序接口</h5><h3 id="7-3-3-文件操作"><a href="#7-3-3-文件操作" class="headerlink" title="7.3.3.     文件操作"></a>7.3.3.     文件操作</h3><h4 id="创建create"><a href="#创建create" class="headerlink" title="创建create"></a>创建create</h4><h4 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h4><h4 id="打开open"><a href="#打开open" class="headerlink" title="打开open"></a>打开open</h4><h4 id="关闭close"><a href="#关闭close" class="headerlink" title="关闭close"></a>关闭close</h4><h4 id="读写read-write"><a href="#读写read-write" class="headerlink" title="读写read/write"></a>读写read/write</h4><h4 id="截断：文件长度-0"><a href="#截断：文件长度-0" class="headerlink" title="截断：文件长度=0"></a>截断：文件长度=0</h4><h4 id="设置读写位置"><a href="#设置读写位置" class="headerlink" title="设置读写位置"></a>设置读写位置</h4><h4 id="其他（以系统调用方式提供）"><a href="#其他（以系统调用方式提供）" class="headerlink" title="其他（以系统调用方式提供）"></a>其他（以系统调用方式提供）</h4><h5 id="1、文件属性相关"><a href="#1、文件属性相关" class="headerlink" title="1、文件属性相关"></a>1、文件属性相关</h5><h5 id="2、有关目录操作"><a href="#2、有关目录操作" class="headerlink" title="2、有关目录操作"></a>2、有关目录操作</h5><h5 id="3、文件共享"><a href="#3、文件共享" class="headerlink" title="3、文件共享"></a>3、文件共享</h5><h3 id="7-3-4-文件逻辑结构"><a href="#7-3-4-文件逻辑结构" class="headerlink" title="7.3.4.     文件逻辑结构"></a>7.3.4.     文件逻辑结构</h3><h4 id="又称文件的组织，是指从用户观点出发观察到的文件组织形式"><a href="#又称文件的组织，是指从用户观点出发观察到的文件组织形式" class="headerlink" title="又称文件的组织，是指从用户观点出发观察到的文件组织形式"></a>又称文件的组织，是指从用户观点出发观察到的文件组织形式</h4><h4 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h4><h5 id="访问性能"><a href="#访问性能" class="headerlink" title="访问性能"></a>访问性能</h5><h6 id="便于检索，便于修改"><a href="#便于检索，便于修改" class="headerlink" title="便于检索，便于修改"></a>便于检索，便于修改</h6><h5 id="存储性能"><a href="#存储性能" class="headerlink" title="存储性能"></a>存储性能</h5><h6 id="转换方便，节省空间"><a href="#转换方便，节省空间" class="headerlink" title="转换方便，节省空间"></a>转换方便，节省空间</h6><h4 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h4><h5 id="是否有结构"><a href="#是否有结构" class="headerlink" title="是否有结构"></a>是否有结构</h5><h6 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h6><p>定长记录</p>
<p>记录长度相同</p>
<p>变长记录</p>
<p>各记录长度不同</p>
<h6 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h6><p>文件长度以字节为单位，读、写指针访问下一个字符</p>
<h5 id="组织形式划分"><a href="#组织形式划分" class="headerlink" title="组织形式划分"></a>组织形式划分</h5><h6 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h6><p>顺序排列，定长或变长都可</p>
<p>排列方式</p>
<p>1、串结构</p>
<p>存入时间决定顺序</p>
<p>2、顺序结构</p>
<p>按关键字排序，效率更高</p>
<p>读写方式</p>
<p>1、定长：ptr=ptr+L</p>
<p>2、变长：ptr=ptr+Li</p>
<p>优缺点</p>
<p>优点</p>
<p>批量处理数据</p>
<p>缺点</p>
<p>单个记录处理困难</p>
<h6 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h6><p>建立一张索引表，每个记录对应一个索引项</p>
<h6 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h6><p>建立一张索引表，将顺序文件中的·记录分为若干组，每组第一个记录对应一个索引项</p>
<h6 id="ps：直接文件："><a href="#ps：直接文件：" class="headerlink" title="ps：直接文件："></a>ps：直接文件：</h6><p>键值直接对应物理地址</p>
<h6 id="ps：哈希文件"><a href="#ps：哈希文件" class="headerlink" title="ps：哈希文件"></a>ps：哈希文件</h6><p>哈希函数根据键值计算相对位置，再根据相对位置得到内容</p>
<p>访问速度最快，但有空闲空间浪费</p>
<h3 id="7-3-5-文件物理结构"><a href="#7-3-5-文件物理结构" class="headerlink" title="7.3.5.     文件物理结构"></a>7.3.5.     文件物理结构</h3><h4 id="文件的存储结构，指文件在外存的组织形式"><a href="#文件的存储结构，指文件在外存的组织形式" class="headerlink" title="文件的存储结构，指文件在外存的组织形式"></a>文件的存储结构，指文件在外存的组织形式</h4><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><h5 id="1、提高存储空间的利用率"><a href="#1、提高存储空间的利用率" class="headerlink" title="1、提高存储空间的利用率"></a>1、提高存储空间的利用率</h5><h5 id="2、提高文件的访问速度"><a href="#2、提高文件的访问速度" class="headerlink" title="2、提高文件的访问速度"></a>2、提高文件的访问速度</h5><h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><h5 id="1、连续分配"><a href="#1、连续分配" class="headerlink" title="1、连续分配"></a>1、连续分配</h5><h6 id="每个文件分配一组相邻接的盘块"><a href="#每个文件分配一组相邻接的盘块" class="headerlink" title="每个文件分配一组相邻接的盘块"></a>每个文件分配一组相邻接的盘块</h6><h6 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h6><p>随着使用磁盘碎片增多，性能下降，需要整理</p>
<h6 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h6><p>访问速度快，定位容易，只需记录第一个簇的位置，可通过紧凑合并外存空闲空间</p>
<h6 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h6><p>需要连续空间，需要事先知道文件长度</p>
<h5 id="2、链接分配"><a href="#2、链接分配" class="headerlink" title="2、链接分配"></a>2、链接分配</h5><h6 id="隐式分配"><a href="#隐式分配" class="headerlink" title="隐式分配"></a>隐式分配</h6><p>不连续，每个簇中有指向下一个簇的指针，目录存放第一个簇和最后一个簇的指针</p>
<p>优点</p>
<p>解决了连续分配的问题</p>
<p>缺点</p>
<p>随机访问效率差，可靠性差</p>
<h6 id="显式分配"><a href="#显式分配" class="headerlink" title="显式分配"></a>显式分配</h6><p>不连续，指针单独存放在文件分配表（FAT）中与文件对应的目录项存放文件首块的地址</p>
<h5 id="3、索引分配"><a href="#3、索引分配" class="headerlink" title="3、索引分配"></a>3、索引分配</h5><h6 id="单级索引"><a href="#单级索引" class="headerlink" title="单级索引"></a>单级索引</h6><h6 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h6><h6 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h6><h2 id="7-4-目录管理"><a href="#7-4-目录管理" class="headerlink" title="7.4.     目录管理"></a>7.4.     目录管理</h2><h3 id="7-4-1-用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址"><a href="#7-4-1-用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址" class="headerlink" title="7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址"></a>7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址</h3><h3 id="7-4-2-实现目标"><a href="#7-4-2-实现目标" class="headerlink" title="7.4.2.     实现目标"></a>7.4.2.     实现目标</h3><h4 id="按名存取"><a href="#按名存取" class="headerlink" title="按名存取"></a>按名存取</h4><h4 id="快速检索"><a href="#快速检索" class="headerlink" title="快速检索"></a>快速检索</h4><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h4 id="文件重名的解决"><a href="#文件重名的解决" class="headerlink" title="文件重名的解决"></a>文件重名的解决</h4><h3 id="7-4-3-文件控制块FCB"><a href="#7-4-3-文件控制块FCB" class="headerlink" title="7.4.3.     文件控制块FCB"></a>7.4.3.     文件控制块FCB</h3><h4 id="文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项"><a href="#文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项" class="headerlink" title="文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项"></a>文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项</h4><h4 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h4><h5 id="1、基本信息类"><a href="#1、基本信息类" class="headerlink" title="1、基本信息类"></a>1、基本信息类</h5><h5 id="2、存取控制信息类"><a href="#2、存取控制信息类" class="headerlink" title="2、存取控制信息类"></a>2、存取控制信息类</h5><h5 id="3、使用信息类"><a href="#3、使用信息类" class="headerlink" title="3、使用信息类"></a>3、使用信息类</h5><h3 id="7-4-4-索引结点"><a href="#7-4-4-索引结点" class="headerlink" title="7.4.4.     索引结点"></a>7.4.4.     索引结点</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h5 id="文件名和文件描述信息分开存放，将FCB拆分为两部分"><a href="#文件名和文件描述信息分开存放，将FCB拆分为两部分" class="headerlink" title="文件名和文件描述信息分开存放，将FCB拆分为两部分"></a>文件名和文件描述信息分开存放，将FCB拆分为两部分</h5><h5 id="1、文件目录部分"><a href="#1、文件目录部分" class="headerlink" title="1、文件目录部分"></a>1、文件目录部分</h5><h6 id="文件名-索引结点编号（指针）"><a href="#文件名-索引结点编号（指针）" class="headerlink" title="文件名+索引结点编号（指针）"></a>文件名+索引结点编号（指针）</h6><h5 id="2、I结点"><a href="#2、I结点" class="headerlink" title="2、I结点"></a>2、I结点</h5><h6 id="除文件名以外的数据结构"><a href="#除文件名以外的数据结构" class="headerlink" title="除文件名以外的数据结构"></a>除文件名以外的数据结构</h6><h4 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h4><h5 id="指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node"><a href="#指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node" class="headerlink" title="指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node"></a>指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node</h5><h4 id="内存索引结点"><a href="#内存索引结点" class="headerlink" title="内存索引结点"></a>内存索引结点</h4><h5 id="文件打开后，磁盘上的I-node拷贝到内存，以便使用"><a href="#文件打开后，磁盘上的I-node拷贝到内存，以便使用" class="headerlink" title="文件打开后，磁盘上的I-node拷贝到内存，以便使用"></a>文件打开后，磁盘上的I-node拷贝到内存，以便使用</h5><h3 id="7-4-5-目录结构"><a href="#7-4-5-目录结构" class="headerlink" title="7.4.5.     目录结构"></a>7.4.5.     目录结构</h3><h4 id="1、单级目录"><a href="#1、单级目录" class="headerlink" title="1、单级目录"></a>1、单级目录</h4><h4 id="2、两级目录"><a href="#2、两级目录" class="headerlink" title="2、两级目录"></a>2、两级目录</h4><h4 id="3、多级目录（树）"><a href="#3、多级目录（树）" class="headerlink" title="3、多级目录（树）"></a>3、多级目录（树）</h4><h4 id="4、无环图目录"><a href="#4、无环图目录" class="headerlink" title="4、无环图目录"></a>4、无环图目录</h4><h4 id="4、通用图目录"><a href="#4、通用图目录" class="headerlink" title="4、通用图目录"></a>4、通用图目录</h4><h2 id="7-5-文件存储空间管理"><a href="#7-5-文件存储空间管理" class="headerlink" title="7.5.     文件存储空间管理"></a>7.5.     文件存储空间管理</h2><h3 id="7-5-1-要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况"><a href="#7-5-1-要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况" class="headerlink" title="7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况"></a>7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况</h3><h3 id="7-5-2-方式"><a href="#7-5-2-方式" class="headerlink" title="7.5.2.     方式"></a>7.5.2.     方式</h3><h4 id="1、空闲表法"><a href="#1、空闲表法" class="headerlink" title="1、空闲表法"></a>1、空闲表法</h4><h5 id="首次-下次适应，最佳-最坏"><a href="#首次-下次适应，最佳-最坏" class="headerlink" title="首次/下次适应，最佳/最坏"></a>首次/下次适应，最佳/最坏</h5><h5 id="连续分配（一般），首次适应（算法）"><a href="#连续分配（一般），首次适应（算法）" class="headerlink" title="连续分配（一般），首次适应（算法）"></a>连续分配（一般），首次适应（算法）</h5><h5 id="序号-第一空闲盘块号-空闲盘块数"><a href="#序号-第一空闲盘块号-空闲盘块数" class="headerlink" title="序号+第一空闲盘块号+空闲盘块数"></a>序号+第一空闲盘块号+空闲盘块数</h5><h4 id="2、空闲链表法"><a href="#2、空闲链表法" class="headerlink" title="2、空闲链表法"></a>2、空闲链表法</h4><h5 id="空闲簇有指向下一个空闲簇的指针"><a href="#空闲簇有指向下一个空闲簇的指针" class="headerlink" title="空闲簇有指向下一个空闲簇的指针"></a>空闲簇有指向下一个空闲簇的指针</h5><h5 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h5><h6 id="空闲簇链接"><a href="#空闲簇链接" class="headerlink" title="空闲簇链接"></a>空闲簇链接</h6><h6 id="空闲区链接"><a href="#空闲区链接" class="headerlink" title="空闲区链接"></a>空闲区链接</h6><p>除指向下一个指针，还指明本盘区大小</p>
<h4 id="3、位示图"><a href="#3、位示图" class="headerlink" title="3、位示图"></a>3、位示图</h4><h5 id="每一位表示一个簇，0和1表示空闲和占用"><a href="#每一位表示一个簇，0和1表示空闲和占用" class="headerlink" title="每一位表示一个簇，0和1表示空闲和占用"></a>每一位表示一个簇，0和1表示空闲和占用</h5><h4 id="4、成组链接法"><a href="#4、成组链接法" class="headerlink" title="4、成组链接法"></a>4、成组链接法</h4><h5 id="栈底放盘块数"><a href="#栈底放盘块数" class="headerlink" title="栈底放盘块数"></a>栈底放盘块数</h5><h5 id="栈底上面一个存放一组空闲盘块"><a href="#栈底上面一个存放一组空闲盘块" class="headerlink" title="栈底上面一个存放一组空闲盘块"></a>栈底上面一个存放一组空闲盘块</h5><h2 id="7-6-文件共享"><a href="#7-6-文件共享" class="headerlink" title="7.6.     文件共享"></a>7.6.     文件共享</h2><h3 id="7-6-1-1、硬链接"><a href="#7-6-1-1、硬链接" class="headerlink" title="7.6.1.     1、硬链接"></a>7.6.1.     1、硬链接</h3><h4 id="文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针"><a href="#文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针" class="headerlink" title="文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针"></a>文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针</h4><h3 id="7-6-2-2、符号链接"><a href="#7-6-2-2、符号链接" class="headerlink" title="7.6.2.     2、符号链接"></a>7.6.2.     2、符号链接</h3><h2 id="7-7-文件保护"><a href="#7-7-文件保护" class="headerlink" title="7.7.     文件保护"></a>7.7.     文件保护</h2><h3 id="7-7-1-1、文件不受物理损坏-2、避免文件被非法访问"><a href="#7-7-1-1、文件不受物理损坏-2、避免文件被非法访问" class="headerlink" title="7.7.1.     1、文件不受物理损坏/2、避免文件被非法访问"></a>7.7.1.     1、文件不受物理损坏/2、避免文件被非法访问</h3><h3 id="7-7-2-常用方法"><a href="#7-7-2-常用方法" class="headerlink" title="7.7.2.     常用方法:"></a>7.7.2.     常用方法:</h3><h4 id="根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问"><a href="#根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问" class="headerlink" title="根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问"></a>根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问</h4><h4 id="ACL方法的缺点"><a href="#ACL方法的缺点" class="headerlink" title="ACL方法的缺点"></a>ACL方法的缺点</h4><h5 id="每个文件ACL过长，事先无法知道系统用户的列表"><a href="#每个文件ACL过长，事先无法知道系统用户的列表" class="headerlink" title="每个文件ACL过长，事先无法知道系统用户的列表"></a>每个文件ACL过长，事先无法知道系统用户的列表</h5><h5 id="原来固定大小的文件目录条目，现在必须可变，空间管理复杂化"><a href="#原来固定大小的文件目录条目，现在必须可变，空间管理复杂化" class="headerlink" title="原来固定大小的文件目录条目，现在必须可变，空间管理复杂化"></a>原来固定大小的文件目录条目，现在必须可变，空间管理复杂化</h5><h4 id="精简ACL的方法"><a href="#精简ACL的方法" class="headerlink" title="精简ACL的方法"></a>精简ACL的方法</h4><h5 id="每个文件三种类型用户"><a href="#每个文件三种类型用户" class="headerlink" title="每个文件三种类型用户"></a>每个文件三种类型用户</h5><h6 id="拥有者：创建文件的用户"><a href="#拥有者：创建文件的用户" class="headerlink" title="拥有者：创建文件的用户"></a>拥有者：创建文件的用户</h6><h6 id="组：可访问者"><a href="#组：可访问者" class="headerlink" title="组：可访问者"></a>组：可访问者</h6><h6 id="其他用户"><a href="#其他用户" class="headerlink" title="其他用户"></a>其他用户</h6>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/" rel="next" title="算法笔记2">
                <i class="fa fa-chevron-left"></i> 算法笔记2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/26/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="prev" title="信息安全">
                信息安全 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="Lexie_W" />
            
              <p class="site-author-name" itemprop="name">Lexie_W</p>
              <p class="site-description motion-element" itemprop="description">誰かが消えても世界は破壊されない</p>
          </div>

          <nav class="site-state motion-element">

            
                          <div class="site-state-item site-state-posts">
                            <a href="/archives">
                              <span class="site-state-item-count">29</span>
                              <span class="site-state-item-name">日志</span>
                            </a>
                          </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          <!-- 添加近期文章 -->

    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
          <li>
            <a href="/2020/08/26/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" title="信息安全" target="_blank">信息安全</a>
          </li>
        
          <li>
            <a href="/2020/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统" target="_blank">操作系统</a>
          </li>
        
          <li>
            <a href="/2020/08/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/" title="算法笔记2" target="_blank">算法笔记2</a>
          </li>
        
          <li>
            <a href="/2020/08/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="时间复杂度" target="_blank">时间复杂度</a>
          </li>
        
          <li>
            <a href="/2020/07/10/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" title="Mybatis逆向工程" target="_blank">Mybatis逆向工程</a>
          </li>
        
      </ul>
    </div>


          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-一、操作系统引论"><span class="nav-text">1.    一、操作系统引论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-计算机层次结构"><span class="nav-text">1.1.     计算机层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-软件"><span class="nav-text">1.1.1.     软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用软件"><span class="nav-text">应用软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统软件"><span class="nav-text">系统软件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库系统、汇编器、编译软件"><span class="nav-text">数据库系统、汇编器、编译软件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作系统OS"><span class="nav-text">操作系统OS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-硬件"><span class="nav-text">1.1.2.     硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#裸机"><span class="nav-text">裸机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-操作系统定义"><span class="nav-text">1.2.     操作系统定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-1、配置在计算机硬件上的第一层软件，是对硬件系统的补充"><span class="nav-text">1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合"><span class="nav-text">1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-操作系统目标"><span class="nav-text">1.3.     操作系统目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别"><span class="nav-text">1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程"><span class="nav-text">1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作"><span class="nav-text">1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-操作系统作用"><span class="nav-text">1.4.     操作系统作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-1、用户与计算机硬件系统之间的接口"><span class="nav-text">1.4.1.     1、用户与计算机硬件系统之间的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-2、计算机资源的管理者"><span class="nav-text">1.4.2.     2、计算机资源的管理者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-3、实现对计算机资源的抽象（扩展机-虚拟机）"><span class="nav-text">1.4.3.     3、实现对计算机资源的抽象（扩展机&#x2F;虚拟机）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-操作系统分类"><span class="nav-text">1.5.     操作系统分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-人工操作"><span class="nav-text">1.5.1.     人工操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#利用率-执行时间-（执行时间-读卡时间）"><span class="nav-text">利用率&#x3D;执行时间&#x2F;（执行时间+读卡时间）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-批处理系统"><span class="nav-text">1.5.2.     批处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单道批处理系统"><span class="nav-text">单道批处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。"><span class="nav-text">若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、优点：改善了CPU和I-O设备的使用效率；提高了系统吞吐量"><span class="nav-text">1、优点：改善了CPU和I&#x2F;O设备的使用效率；提高了系统吞吐量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、缺点：系统资源得不到充分利用；CPU和I-O外设忙闲不均"><span class="nav-text">2、缺点：系统资源得不到充分利用；CPU和I&#x2F;O外设忙闲不均</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主要特征"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、自动性"><span class="nav-text">1、自动性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、顺序性"><span class="nav-text">2、顺序性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、单道性"><span class="nav-text">3、单道性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多道批处理系统"><span class="nav-text">多道批处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义-1"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。"><span class="nav-text">作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-1"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）"><span class="nav-text">1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、缺点："><span class="nav-text">2、缺点：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主要特征-1"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、多道：内存中同时存放多个作业"><span class="nav-text">1、多道：内存中同时存放多个作业</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、宏观：并行运行，都处于运行状态"><span class="nav-text">2、宏观：并行运行，都处于运行状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、微观：串行运行，各作业交替使用CPU"><span class="nav-text">3、微观：串行运行，各作业交替使用CPU</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#技术问题"><span class="nav-text">技术问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-分时系统"><span class="nav-text">1.5.3.     分时系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-2"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。"><span class="nav-text">是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要特征-2"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、交互性：用户与系统可以进行广泛的人机对话"><span class="nav-text">1、交互性：用户与系统可以进行广泛的人机对话</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、多路性：多用户在各自终端上使用同一CPU"><span class="nav-text">2、多路性：多用户在各自终端上使用同一CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、独立性：用户独立操作，互不干扰"><span class="nav-text">3、独立性：用户独立操作，互不干扰</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、及时性-用户短时间内得到系统地及时回答"><span class="nav-text">4、及时性:用户短时间内得到系统地及时回答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps：可靠性：较低"><span class="nav-text">ps：可靠性：较低</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#影响响应时间的因素"><span class="nav-text">影响响应时间的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#终端数目；时间片大小；信息交换量；信息交换速度"><span class="nav-text">终端数目；时间片大小；信息交换量；信息交换速度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4-实时系统"><span class="nav-text">1.5.4.     实时系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-3"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位"><span class="nav-text">能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要特征-3"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序"><span class="nav-text">1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构"><span class="nav-text">2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、独立性：独立操作互不干扰"><span class="nav-text">3、独立性：独立操作互不干扰</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级"><span class="nav-text">4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps-可靠性：高度可靠"><span class="nav-text">ps:可靠性：高度可靠</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时系统分类"><span class="nav-text">实时系统分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统"><span class="nav-text">实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答"><span class="nav-text">实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务类型分类"><span class="nav-text">任务类型分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#任务执行是否周期性"><span class="nav-text">任务执行是否周期性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#周期性实时任务：设备周期性发送信号"><span class="nav-text">周期性实时任务：设备周期性发送信号</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）"><span class="nav-text">非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#截止时间的要求"><span class="nav-text">截止时间的要求</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#硬实时任务：必须满足截止时间"><span class="nav-text">硬实时任务：必须满足截止时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#软实时任务：允许偶尔不满足截止时间"><span class="nav-text">软实时任务：允许偶尔不满足截止时间</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5-多处理机操作系统"><span class="nav-text">1.5.5.     多处理机操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）"><span class="nav-text">增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提高系统可靠性：故障时系统降级运行"><span class="nav-text">提高系统可靠性：故障时系统降级运行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连"><span class="nav-text">并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式"><span class="nav-text">对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#非对称式多重处理（主从模式-主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I-O处理。负载不匀，可靠性较低（通常要求硬件也非对称）"><span class="nav-text">非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I&#x2F;O处理。负载不匀，可靠性较低（通常要求硬件也非对称）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分布式系统（松散耦合）：各处理机有各自的存储器，OS和I-O设备，由通道或通信线路相连"><span class="nav-text">分布式系统（松散耦合）：各处理机有各自的存储器，OS和I&#x2F;O设备，由通道或通信线路相连</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-6-网络操作系统"><span class="nav-text">1.5.6.     网络操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-4"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提供网络通信和网络服务功能的操作系统"><span class="nav-text">提供网络通信和网络服务功能的操作系统</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要特征-4"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、耦合程度"><span class="nav-text">1、耦合程度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#松散耦合，允许异种OS互联，遵循“协议同质”"><span class="nav-text">松散耦合，允许异种OS互联，遵循“协议同质”</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、并行性"><span class="nav-text">2、并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#各机进程独立"><span class="nav-text">各机进程独立</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、透明性（用户是否知道或指定资源在哪个机器上）"><span class="nav-text">3、透明性（用户是否知道或指定资源在哪个机器上）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用户明确指定要使用的网络资源"><span class="nav-text">用户明确指定要使用的网络资源</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、健壮性"><span class="nav-text">4、健壮性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#要求不高"><span class="nav-text">要求不高</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-7-分布式操作系统"><span class="nav-text">1.5.7.     分布式操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义："><span class="nav-text">定义：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配"><span class="nav-text">以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要特征-5"><span class="nav-text">主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、耦合程度-1"><span class="nav-text">1、耦合程度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。"><span class="nav-text">紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、并行性-1"><span class="nav-text">2、并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#一个进程可以分散在各机上并行执行，“进程迁移”"><span class="nav-text">一个进程可以分散在各机上并行执行，“进程迁移”</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、透明性"><span class="nav-text">3、透明性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#网络资源调度对用户透明，用户不了解所占有资源所在位置"><span class="nav-text">网络资源调度对用户透明，用户不了解所占有资源所在位置</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、健壮性-1"><span class="nav-text">4、健壮性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#要求比网络OS更强的容错能力（工作时系统重构）"><span class="nav-text">要求比网络OS更强的容错能力（工作时系统重构）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-8-个人计算机操作系统"><span class="nav-text">1.5.8.     个人计算机操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单用户单任务"><span class="nav-text">单用户单任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只允许一个用户上机，只允许用户程序作为一个任务运行"><span class="nav-text">只允许一个用户上机，只允许用户程序作为一个任务运行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单用户多任务"><span class="nav-text">单用户多任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能"><span class="nav-text">只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多用户多任务"><span class="nav-text">多用户多任务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能"><span class="nav-text">允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-操作系统基本特征"><span class="nav-text">1.6.     操作系统基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-并发"><span class="nav-text">1.6.1.     并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多个事件同一时间段发生"><span class="nav-text">多个事件同一时间段发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行"><span class="nav-text">ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-共享"><span class="nav-text">1.6.2.     共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问"><span class="nav-text">计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-虚拟"><span class="nav-text">1.6.3.     虚拟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个物理实体映射为多个逻辑实体——分时或分空间"><span class="nav-text">一个物理实体映射为多个逻辑实体——分时或分空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-异步"><span class="nav-text">1.6.4.     异步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#又称不确定性；指进程的执行顺序和执行时间的不确定性。"><span class="nav-text">又称不确定性；指进程的执行顺序和执行时间的不确定性。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-操作系统组成"><span class="nav-text">1.7.     操作系统组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-管理模块"><span class="nav-text">1.7.1.     管理模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#针对不同管理对象模块的程序模块（通常被称为操作系统核心）"><span class="nav-text">针对不同管理对象模块的程序模块（通常被称为操作系统核心）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-用户接口"><span class="nav-text">1.7.2.     用户接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如外壳（shell）、窗口系统"><span class="nav-text">如外壳（shell）、窗口系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-操作系统主要功能"><span class="nav-text">1.8.     操作系统主要功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-1-存储管理"><span class="nav-text">1.8.1.     存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行"><span class="nav-text">提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、存储分配和回收"><span class="nav-text">1、存储分配和回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、存储保护"><span class="nav-text">2、存储保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#保证进程互不干扰"><span class="nav-text">保证进程互不干扰</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、地址映射"><span class="nav-text">3、地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程逻辑地址到内存物理地址的映射"><span class="nav-text">进程逻辑地址到内存物理地址的映射</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、内存扩充"><span class="nav-text">4、内存扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间"><span class="nav-text">覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-2-处理机管理"><span class="nav-text">1.8.2.     处理机管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标-1"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理机资源的分配调度"><span class="nav-text">处理机资源的分配调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能-1"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、进程控制"><span class="nav-text">1、进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建、撤销、挂起、改变优先级等"><span class="nav-text">创建、撤销、挂起、改变优先级等</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、进程同步"><span class="nav-text">2、进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#协调并发进程之间的推进步骤，以协调资源共享"><span class="nav-text">协调并发进程之间的推进步骤，以协调资源共享</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、进程通信"><span class="nav-text">3、进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程之间传输数据，协调合作"><span class="nav-text">进程之间传输数据，协调合作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、调度"><span class="nav-text">4、调度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#作业或进程的运行切换"><span class="nav-text">作业或进程的运行切换</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-3-设备管理"><span class="nav-text">1.8.3.     设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标-2"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方便用户使用设备、提高CPU和I-O利用率"><span class="nav-text">方便用户使用设备、提高CPU和I&#x2F;O利用率</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能-2"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、设备操作"><span class="nav-text">1、设备操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用设备驱动程序完成对设备的操作"><span class="nav-text">利用设备驱动程序完成对设备的操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、设备独立性"><span class="nav-text">2、设备独立性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#提供统一的I-O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容"><span class="nav-text">提供统一的I&#x2F;O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、设备分配与回收"><span class="nav-text">3、设备分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#多用户间共享I-O设备"><span class="nav-text">多用户间共享I&#x2F;O设备</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-4-文件管理"><span class="nav-text">1.8.4.     文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标-3"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#管理用户文件和系统文件方便用户使用，并保证文件安全性"><span class="nav-text">管理用户文件和系统文件方便用户使用，并保证文件安全性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能-3"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、文件存储空间管理"><span class="nav-text">1、文件存储空间管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、目录管理"><span class="nav-text">2、目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#解决文件检索问题"><span class="nav-text">解决文件检索问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、文件读写管理与存取控制"><span class="nav-text">3、文件读写管理与存取控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、软件管理"><span class="nav-text">4、软件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#软件版本、相互依赖关系、安装和卸载等"><span class="nav-text">软件版本、相互依赖关系、安装和卸载等</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-5-用户接口"><span class="nav-text">1.8.5.     用户接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标-4"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供"><span class="nav-text">提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能-4"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、命令接口"><span class="nav-text">1、命令接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#联机用户接口：为联机用户提供，由键盘操作命令-命令解释程序组成"><span class="nav-text">联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成"><span class="nav-text">脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、程序接口"><span class="nav-text">2、程序接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成"><span class="nav-text">用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、图形接口"><span class="nav-text">3、图形接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用鼠标通过菜单框来完成对应用程序和文件的操作"><span class="nav-text">用鼠标通过菜单框来完成对应用程序和文件的操作</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-双模式操作"><span class="nav-text">1.9.     双模式操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-1-分类"><span class="nav-text">1.9.1.     分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、用户模式（目态—模式位1）"><span class="nav-text">1、用户模式（目态—模式位1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、监控模式（管态—模式位0）"><span class="nav-text">2、监控模式（管态—模式位0）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-2-切换"><span class="nav-text">1.9.2.     切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态-gt-系统态"><span class="nav-text">用户态-&gt;系统态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中断、故障、系统调用（用户需要操作系统的服务）"><span class="nav-text">中断、故障、系统调用（用户需要操作系统的服务）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统态-gt-用户态"><span class="nav-text">系统态-&gt;用户态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS设置用户态"><span class="nav-text">OS设置用户态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-3-作用"><span class="nav-text">1.9.3.     作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#确保系统和用户程序不受错误的系统程序的影响"><span class="nav-text">确保系统和用户程序不受错误的系统程序的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现方法"><span class="nav-text">实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统"><span class="nav-text">将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-4-特权指令"><span class="nav-text">1.9.4.     特权指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、有关I-O设备的指令"><span class="nav-text">1、有关I&#x2F;O设备的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、访问程序状态的指令"><span class="nav-text">2、访问程序状态的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、存储特殊寄存器的指令"><span class="nav-text">3、存储特殊寄存器的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、其他指令"><span class="nav-text">4、其他指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-操作系统保护机制"><span class="nav-text">1.10.   操作系统保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-1-I-O保护"><span class="nav-text">1.10.1.   I&#x2F;O保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有的I-O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权"><span class="nav-text">所有的I&#x2F;O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-2-存储保护"><span class="nav-text">1.10.2.   存储保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区"><span class="nav-text">某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为了实现存储保护，增加两个寄存器"><span class="nav-text">为了实现存储保护，增加两个寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基地址寄存器：存放本进程最低的内存物理地址"><span class="nav-text">基地址寄存器：存放本进程最低的内存物理地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#界限寄存器：存放本进程的存储区域大小"><span class="nav-text">界限寄存器：存放本进程的存储区域大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件保护原则"><span class="nav-text">硬件保护原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#管态下OS可以无限制访问核心和所有用户程序的地址空间"><span class="nav-text">管态下OS可以无限制访问核心和所有用户程序的地址空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改基地址寄存器和界限寄存器的指令属于特权指令"><span class="nav-text">修改基地址寄存器和界限寄存器的指令属于特权指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-3-CPU保护"><span class="nav-text">1.10.3.   CPU保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断"><span class="nav-text">为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定时时钟是实现分时操作系统的基础"><span class="nav-text">定时时钟是实现分时操作系统的基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改定时时钟的指令为特权指令"><span class="nav-text">修改定时时钟的指令为特权指令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-二、进程的描述与控制"><span class="nav-text">2.    二、进程的描述与控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-进程描述"><span class="nav-text">2.1.     进程描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-进程定义"><span class="nav-text">2.1.1.     进程定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程"><span class="nav-text">一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#是资源分配和管理的基本单位"><span class="nav-text">是资源分配和管理的基本单位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-进程执行方式"><span class="nav-text">2.1.2.     进程执行方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序执行"><span class="nav-text">顺序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#特征"><span class="nav-text">特征</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、顺序性"><span class="nav-text">1、顺序性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、封闭性"><span class="nav-text">2、封闭性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、可再现性"><span class="nav-text">3、可再现性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发执行"><span class="nav-text">并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#目的"><span class="nav-text">目的</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#提高资源利用率"><span class="nav-text">提高资源利用率</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特征（不加入任何系统控制）"><span class="nav-text">特征（不加入任何系统控制）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、间断性"><span class="nav-text">1、间断性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、失去封闭性：共享资源"><span class="nav-text">2、失去封闭性：共享资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、失去可再现性"><span class="nav-text">3、失去可再现性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行条件"><span class="nav-text">执行条件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#达到封闭性和可再现性"><span class="nav-text">达到封闭性和可再现性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-与程序的关系"><span class="nav-text">2.1.3.     与程序的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个进程多个线程，一个线程对应一个进程"><span class="nav-text">一个进程多个线程，一个线程对应一个进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-进程特征"><span class="nav-text">2.1.4.     进程特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、动态性"><span class="nav-text">1、动态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、并发性"><span class="nav-text">2、并发性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、独立性"><span class="nav-text">3、独立性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#资源分配的基本单位"><span class="nav-text">资源分配的基本单位</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、异步性"><span class="nav-text">4、异步性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程各自独立，推进速度不可预知"><span class="nav-text">进程各自独立，推进速度不可预知</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、结构化"><span class="nav-text">5、结构化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码段-数据段-程序控制块（PCB）"><span class="nav-text">代码段+数据段+程序控制块（PCB）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PCB"><span class="nav-text">PCB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-进程基本状态及转换"><span class="nav-text">2.1.5.     进程基本状态及转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本状态"><span class="nav-text">基本状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#就绪（Ready）状态"><span class="nav-text">就绪（Ready）状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行（Running）状态"><span class="nav-text">执行（Running）状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞（Block）状态"><span class="nav-text">阻塞（Block）状态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换"><span class="nav-text">转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PPT-6"><span class="nav-text">PPT-6</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-进程控制"><span class="nav-text">2.2.     进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-程序控制块PCB"><span class="nav-text">2.2.1.     程序控制块PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、是描述进程的数据结构，保存与该进程有关的各种数据信息"><span class="nav-text">1、是描述进程的数据结构，保存与该进程有关的各种数据信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、进程描述信息：进程标识符"><span class="nav-text">1、进程描述信息：进程标识符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、处理机状态信息：保存进程运行现场信息"><span class="nav-text">2、处理机状态信息：保存进程运行现场信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、进程调度信息"><span class="nav-text">3、进程调度信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、进程控制信息"><span class="nav-text">4、进程控制信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、进程的唯一标识，每个进程在OS的登记表项"><span class="nav-text">2、进程的唯一标识，每个进程在OS的登记表项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、进程创建时生成，终止时回收"><span class="nav-text">3、进程创建时生成，终止时回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、在内存核心区，系统调用间接访问"><span class="nav-text">4、在内存核心区，系统调用间接访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表"><span class="nav-text">5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS怎么管理PCB进行进程调度？"><span class="nav-text">OS怎么管理PCB进行进程调度？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#作业队列：所有进程集合"><span class="nav-text">作业队列：所有进程集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#就绪队列：就绪进程集合"><span class="nav-text">就绪队列：就绪进程集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#设备队列：等待I-O设备的进程集合"><span class="nav-text">设备队列：等待I&#x2F;O设备的进程集合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#令进程在各种不同的队列中迁移"><span class="nav-text">令进程在各种不同的队列中迁移</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PCB组织方式"><span class="nav-text">PCB组织方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#同一状态进程的PCB构成一个链表"><span class="nav-text">同一状态进程的PCB构成一个链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#同一状态进程归入一个index表，由index指向PCB"><span class="nav-text">同一状态进程归入一个index表，由index指向PCB</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-进程管理"><span class="nav-text">2.2.2.     进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程生命周期"><span class="nav-text">进程生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建、运行、等待、唤醒、终止"><span class="nav-text">创建、运行、等待、唤醒、终止</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程控制任务"><span class="nav-text">进程控制任务</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程创建、终止、状态转变"><span class="nav-text">进程创建、终止、状态转变</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现方式"><span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#OS内核原语实现"><span class="nav-text">OS内核原语实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建"><span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起创建的事件"><span class="nav-text">引起创建的事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、用户登录"><span class="nav-text">1、用户登录</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、作业调度"><span class="nav-text">2、作业调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、提供服务"><span class="nav-text">3、提供服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、应用请求"><span class="nav-text">4、应用请求</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建步骤（原语CREATE（））"><span class="nav-text">创建步骤（原语CREATE（））</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、申请空白PCB"><span class="nav-text">1、申请空白PCB</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、为新进程分配资源"><span class="nav-text">2、为新进程分配资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、初始化PCB"><span class="nav-text">3、初始化PCB</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、将新进程插入就绪队列"><span class="nav-text">4、将新进程插入就绪队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程终止"><span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起终止的事件"><span class="nav-text">引起终止的事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、正常结束"><span class="nav-text">1、正常结束</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、异常结束"><span class="nav-text">2、异常结束</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、外界干预"><span class="nav-text">3、外界干预</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#终止步骤（原语EXIT（））"><span class="nav-text">终止步骤（原语EXIT（））</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态"><span class="nav-text">1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、若处于执行状态，终止该进程，置调度标志为1，重新调度"><span class="nav-text">2、若处于执行状态，终止该进程，置调度标志为1，重新调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、有子孙进程就终止"><span class="nav-text">3、有子孙进程就终止</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、进程资源归还给父进程或者系统"><span class="nav-text">4、进程资源归还给父进程或者系统</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5、进程PCB移出所在队列"><span class="nav-text">5、进程PCB移出所在队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程阻塞与唤醒"><span class="nav-text">进程阻塞与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引起阻塞与唤醒的事件"><span class="nav-text">引起阻塞与唤醒的事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、请求系统共享资源服务"><span class="nav-text">1、请求系统共享资源服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、启动某种操作（例如I-O）"><span class="nav-text">2、启动某种操作（例如I&#x2F;O）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、新数据尚未到达"><span class="nav-text">3、新数据尚未到达</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、等待新任务的到达"><span class="nav-text">4、等待新任务的到达</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞步骤（原语BLOCK（））"><span class="nav-text">阻塞步骤（原语BLOCK（））</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、保存当前进程的CPU现场"><span class="nav-text">1、保存当前进程的CPU现场</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、置该进程状态（变为阻塞态）"><span class="nav-text">2、置该进程状态（变为阻塞态）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、PCB进入等待队列"><span class="nav-text">3、PCB进入等待队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、转进程调度"><span class="nav-text">4、转进程调度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#唤醒步骤（原语WAKEUP（））"><span class="nav-text">唤醒步骤（原语WAKEUP（））</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、等待队列中摘下被唤醒进程"><span class="nav-text">1、等待队列中摘下被唤醒进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、置该进程状态（变为就绪态）"><span class="nav-text">2、置该进程状态（变为就绪态）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、进入就绪队列"><span class="nav-text">3、进入就绪队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、转进程调度或返回"><span class="nav-text">4、转进程调度或返回</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程挂起与激活"><span class="nav-text">进程挂起与激活</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#挂起"><span class="nav-text">挂起</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#挂起引入原因"><span class="nav-text">挂起引入原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#目的-1"><span class="nav-text">目的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#挂起步骤（原语SUSPEND（））"><span class="nav-text">挂起步骤（原语SUSPEND（））</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#激活"><span class="nav-text">激活</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#激活引入原因"><span class="nav-text">激活引入原因</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#激活步骤（原语ACTIVE（））"><span class="nav-text">激活步骤（原语ACTIVE（））</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-进程同步"><span class="nav-text">2.3.     进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-基本概念"><span class="nav-text">2.3.1.     基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#制约关系"><span class="nav-text">制约关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#间接制约"><span class="nav-text">间接制约</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程之间共享某种系统资源而形成的相互制约"><span class="nav-text">进程之间共享某种系统资源而形成的相互制约</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接制约"><span class="nav-text">直接制约</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程间由于合作形成的相互制约"><span class="nav-text">进程间由于合作形成的相互制约</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程两大关系"><span class="nav-text">进程两大关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#互斥"><span class="nav-text">互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权"><span class="nav-text">由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同步"><span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务"><span class="nav-text">多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界资源"><span class="nav-text">临界资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一段时间内只允许一个进程访问的资源"><span class="nav-text">一段时间内只允许一个进程访问的资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界区"><span class="nav-text">临界区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每个进程访问临界资源的那段代码被称为临界区"><span class="nav-text">每个进程访问临界资源的那段代码被称为临界区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-基本准则"><span class="nav-text">2.3.2.     基本准则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空闲则入"><span class="nav-text">空闲则入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忙则等待"><span class="nav-text">忙则等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有限等待：不能死等"><span class="nav-text">有限等待：不能死等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#让权等待：不能进入临界区的进程要释放CPU"><span class="nav-text">让权等待：不能进入临界区的进程要释放CPU</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-信号量机制"><span class="nav-text">2.3.3.     信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、整型信号量机制"><span class="nav-text">1、整型信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#表示资源数目的整型量s和原子操作wait-s-signal-s"><span class="nav-text">表示资源数目的整型量s和原子操作wait(s)+signal(s)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、记录型信号量机制"><span class="nav-text">2、记录型信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#信号量s"><span class="nav-text">信号量s</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#s-count-处置表示某类资源的数目"><span class="nav-text">s.count:处置表示某类资源的数目</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-queue-阻塞在该信号量的各个进程的PCB链成的队列"><span class="nav-text">s.queue:阻塞在该信号量的各个进程的PCB链成的队列</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原子操作"><span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait-–s-count-if-s-count-lt-0-block-s-queue"><span class="nav-text">wait():–s.count;if(s.count&lt;0) block(s.queue);</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#signal-s-count-if-s-count-lt-0-block-s-queue"><span class="nav-text">signal():++s,count;if(s.count&lt;&#x3D;0) block(s.queue);</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、AND型信号量"><span class="nav-text">3、AND型信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本思想"><span class="nav-text">基本思想</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放"><span class="nav-text">将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原子操作-1"><span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Swait"><span class="nav-text">Swait()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、二进制信号量"><span class="nav-text">4、二进制信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#信号量"><span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#S1-1；S2-0；C-代表共享资源的初始值"><span class="nav-text">S1&#x3D;1；S2&#x3D;0；C&#x3D;代表共享资源的初始值</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-信号量的应用"><span class="nav-text">2.3.4.     信号量的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、信号量实现互斥"><span class="nav-text">1、信号量实现互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设置互斥信号量mutex，初值为1"><span class="nav-text">设置互斥信号量mutex，初值为1</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#mutex-1，无进程进入临界区"><span class="nav-text">mutex&#x3D;1，无进程进入临界区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mutex-0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列"><span class="nav-text">mutex&#x3D;0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mutex-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒"><span class="nav-text">mutex&#x3D;-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流程"><span class="nav-text">流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait-mutex-；临界区；signal-mutex-；剩余区"><span class="nav-text">wait(mutex)；临界区；signal(mutex)；剩余区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、信号量实现同步"><span class="nav-text">2、信号量实现同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为每个前驱关系设置一个信号量"><span class="nav-text">为每个前驱关系设置一个信号量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-经典的进程同步问题"><span class="nav-text">2.3.5.     经典的进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、生产者消费者问题"><span class="nav-text">1、生产者消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、读者写者问题"><span class="nav-text">2、读者写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、哲学家进餐问题"><span class="nav-text">3、哲学家进餐问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-进程通信"><span class="nav-text">2.4.     进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-基本概念：进程之间的信息交换"><span class="nav-text">2.4.1.     基本概念：进程之间的信息交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#低级通信"><span class="nav-text">低级通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#效率低"><span class="nav-text">效率低</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通信对用户不透明"><span class="nav-text">通信对用户不透明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#包括信号量和管程机制"><span class="nav-text">包括信号量和管程机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级通信"><span class="nav-text">高级通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高"><span class="nav-text">指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用方便；高效地传送大量数据"><span class="nav-text">使用方便；高效地传送大量数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#包括下面三种系统"><span class="nav-text">包括下面三种系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-进程通信类型"><span class="nav-text">2.4.2.     进程通信类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、共享存储器系统"><span class="nav-text">1、共享存储器系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、共享数据结构"><span class="nav-text">1、共享数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#低级通信-1"><span class="nav-text">低级通信</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、共享存储区"><span class="nav-text">2、共享存储区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、消息传递系统"><span class="nav-text">2、消息传递系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#系统提供一组通信原语"><span class="nav-text">系统提供一组通信原语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现方式-1"><span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#直接通信"><span class="nav-text">直接通信</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#间接通信"><span class="nav-text">间接通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、管道通信系统"><span class="nav-text">3、管道通信系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#连接读写进程的一个共享文件，pipe文件"><span class="nav-text">连接读写进程的一个共享文件，pipe文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#必须提供的协调能力"><span class="nav-text">必须提供的协调能力</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#互斥-1"><span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#同步-1"><span class="nav-text">同步</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#确定对方是否存在，只有对方存在才能通信"><span class="nav-text">确定对方是否存在，只有对方存在才能通信</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-线程Thread简介"><span class="nav-text">2.5.     线程Thread简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-定义"><span class="nav-text">2.5.1.     定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程当中的一条执行流程"><span class="nav-text">进程当中的一条执行流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-属性"><span class="nav-text">2.5.2.     属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、共享进程资源"><span class="nav-text">1、共享进程资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、轻型实体：每个线程只拥有少量资源"><span class="nav-text">2、轻型实体：每个线程只拥有少量资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、处理机调度的单位"><span class="nav-text">3、处理机调度的单位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、可并发执行"><span class="nav-text">4、可并发执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-优缺点"><span class="nav-text">2.5.3.     优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-1"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、一个进程可对应多个线程"><span class="nav-text">1、一个进程可对应多个线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、可并发执行"><span class="nav-text">2、可并发执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、创建和终止时间比进程短"><span class="nav-text">3、创建和终止时间比进程短</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、各个线程资源共享，可直接通信不通过OS内核"><span class="nav-text">4、各个线程资源共享，可直接通信不通过OS内核</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个线程崩溃会导致所属进程的所有线程崩溃"><span class="nav-text">一个线程崩溃会导致所属进程的所有线程崩溃</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-OS支持线程的方法"><span class="nav-text">2.5.4.     OS支持线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、用户级线程"><span class="nav-text">1、用户级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、存在于用户空间，内核不了解"><span class="nav-text">1、存在于用户空间，内核不了解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、应用进程利用线程库函数来控制用户线程"><span class="nav-text">2、应用进程利用线程库函数来控制用户线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、一个线程阻塞，整个进程等待"><span class="nav-text">3、一个线程阻塞，整个进程等待</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、时间片分配给进程，线程多了每个线程执行时间相对就少"><span class="nav-text">4、时间片分配给进程，线程多了每个线程执行时间相对就少</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、内核线程"><span class="nav-text">2、内核线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、OS支持，负责线程的创建、切换等操作"><span class="nav-text">1、OS支持，负责线程的创建、切换等操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、线程的管理慢于用户级线程"><span class="nav-text">2、线程的管理慢于用户级线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、一个线程阻塞，整个进程不会阻塞"><span class="nav-text">3、一个线程阻塞，整个进程不会阻塞</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps：多线程模型"><span class="nav-text">ps：多线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一对多"><span class="nav-text">一对多</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一对一"><span class="nav-text">一对一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多对多"><span class="nav-text">多对多</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-三、处理机调度和死锁"><span class="nav-text">3.    三、处理机调度和死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-处理机调度算法的层次"><span class="nav-text">3.1.     处理机调度算法的层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-高级调度"><span class="nav-text">3.1.1.     高级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#又称：长程调度或作业调度"><span class="nav-text">又称：长程调度或作业调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度对象：作业（用户利用计算机进行一次运行所需工作的集合）"><span class="nav-text">调度对象：作业（用户利用计算机进行一次运行所需工作的集合）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列"><span class="nav-text">主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度"><span class="nav-text">相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-低级调度"><span class="nav-text">3.1.2.     低级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程调度或短程调度"><span class="nav-text">进程调度或短程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#非抢先式调度"><span class="nav-text">非抢先式调度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#拥有处理机的进程完成或阻塞时才把处理机分配给其他进程"><span class="nav-text">拥有处理机的进程完成或阻塞时才把处理机分配给其他进程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#抢先式调度"><span class="nav-text">抢先式调度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#允许暂停拥有处理机的进程，重新分配处理机给另一个进程"><span class="nav-text">允许暂停拥有处理机的进程，重新分配处理机给另一个进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#时间片原则；优先权原则"><span class="nav-text">时间片原则；优先权原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度对象：进程（或内核级线程）"><span class="nav-text">调度对象：进程（或内核级线程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）"><span class="nav-text">主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关系统：多道、分时、实时三种类型的OS中，都必须配置"><span class="nav-text">相关系统：多道、分时、实时三种类型的OS中，都必须配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-中级调度"><span class="nav-text">3.1.3.     中级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#又称：内存调度"><span class="nav-text">又称：内存调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用目的：提高内存利用率和系统吞吐量"><span class="nav-text">使用目的：提高内存利用率和系统吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态"><span class="nav-text">主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-选择处理机调度方式和算法的准则"><span class="nav-text">3.2.     选择处理机调度方式和算法的准则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-面向用户"><span class="nav-text">3.2.1.     面向用户</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#周转时间短"><span class="nav-text">周转时间短</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#批处理系统的重要指标：作业从提交到完成（得到结果）"><span class="nav-text">批处理系统的重要指标：作业从提交到完成（得到结果）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平均周转时间：完成时间-提交时间"><span class="nav-text">平均周转时间：完成时间-提交时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平均带权周转时间：平均周转时间-CPU执行时间"><span class="nav-text">平均带权周转时间：平均周转时间&#x2F;CPU执行时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应时间快"><span class="nav-text">响应时间快</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分时系统的重要指标：输入请求到系统给出首次响应的时间"><span class="nav-text">分时系统的重要指标：输入请求到系统给出首次响应的时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保证截止时间"><span class="nav-text">保证截止时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实时系统的重要指标：开始截止时间和完成截止时间"><span class="nav-text">实时系统的重要指标：开始截止时间和完成截止时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先权原则"><span class="nav-text">优先权原则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#批处理、分时、实时系统都可遵循"><span class="nav-text">批处理、分时、实时系统都可遵循</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#公平性：不因为作业或进程本身特性而使上述指标恶化。"><span class="nav-text">公平性：不因为作业或进程本身特性而使上述指标恶化。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-面向系统"><span class="nav-text">3.2.2.     面向系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统吞吐量高"><span class="nav-text">系统吞吐量高</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#批处理系统的重要指标"><span class="nav-text">批处理系统的重要指标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#吞吐量：单位时间内所完成的作业数"><span class="nav-text">吞吐量：单位时间内所完成的作业数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理机利用率高"><span class="nav-text">处理机利用率高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源的平衡利用"><span class="nav-text">资源的平衡利用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-调度算法本身的调度性能准则"><span class="nav-text">3.2.3.     调度算法本身的调度性能准则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#易于实现"><span class="nav-text">易于实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行开销比"><span class="nav-text">执行开销比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-调度算法"><span class="nav-text">3.3.     调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-定义"><span class="nav-text">3.3.1.     定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据系统的资源分配策略所规定的资源分配算法"><span class="nav-text">根据系统的资源分配策略所规定的资源分配算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-分类"><span class="nav-text">3.3.2.     分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先来先服务算法（FCFS）"><span class="nav-text">先来先服务算法（FCFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法描述"><span class="nav-text">算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。"><span class="nav-text">按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特点"><span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利于长作业而不利于短作业"><span class="nav-text">利于长作业而不利于短作业</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利于CPU繁忙的作业而不利于I-O繁忙的作业"><span class="nav-text">利于CPU繁忙的作业而不利于I&#x2F;O繁忙的作业</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#短作业（进程）优先调度算法（SJF-SPF）"><span class="nav-text">短作业（进程）优先调度算法（SJF&#x2F;SPF）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法描述-1"><span class="nav-text">算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式"><span class="nav-text">对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#对FCFS的改进，目标减少平均周转时间"><span class="nav-text">对FCFS的改进，目标减少平均周转时间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特点-1"><span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-2"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-1"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变型"><span class="nav-text">变型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#最短剩余时间优先（SRT）"><span class="nav-text">最短剩余时间优先（SRT）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最高响应比优先（HRRN）"><span class="nav-text">最高响应比优先（HRRN）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先权调度算法"><span class="nav-text">优先权调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法描述-2"><span class="nav-text">算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#作业调度"><span class="nav-text">作业调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#进程调度"><span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#类型"><span class="nav-text">类型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先权类型"><span class="nav-text">优先权类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#静态优先级"><span class="nav-text">静态优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#动态优先级"><span class="nav-text">动态优先级</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高响应比优先调度算法（HRRN）"><span class="nav-text">高响应比优先调度算法（HRRN）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#特征-1"><span class="nav-text">特征</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-2"><span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#响应比-（等待时间-要求执行时间）-要求执行时间"><span class="nav-text">响应比&#x3D;（等待时间+要求执行时间）&#x2F;要求执行时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间片轮转法（RR）"><span class="nav-text">时间片轮转法（RR）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法描述-3"><span class="nav-text">算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个"><span class="nav-text">就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#设计目标：提高资源利用率"><span class="nav-text">设计目标：提高资源利用率</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#时间片"><span class="nav-text">时间片</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#时间片长度的影响"><span class="nav-text">时间片长度的影响</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#就绪进程越多，时间片越小"><span class="nav-text">就绪进程越多，时间片越小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#系统的处理能力应当使用户输入通常在一个时间片内能处理完"><span class="nav-text">系统的处理能力应当使用户输入通常在一个时间片内能处理完</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多队列调度算法"><span class="nav-text">多队列调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法描述-4"><span class="nav-text">算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长"><span class="nav-text">设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降"><span class="nav-text">当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾"><span class="nav-text">较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法性能"><span class="nav-text">算法性能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#终端型进程（I-O）"><span class="nav-text">终端型进程（I&#x2F;O）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算型进程（长批处理作业）"><span class="nav-text">计算型进程（长批处理作业）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#短批处理作业"><span class="nav-text">短批处理作业</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-3"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#为提高I-O资源利用率和缩短响应时间照顾I-O型进程"><span class="nav-text">为提高I&#x2F;O资源利用率和缩短响应时间照顾I&#x2F;O型进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#为提高系统吞吐量和缩短平均周转时间而照顾短进程"><span class="nav-text">为提高系统吞吐量和缩短平均周转时间而照顾短进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#不用估计进程执行时间，动态调节"><span class="nav-text">不用估计进程执行时间，动态调节</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-实时调度"><span class="nav-text">3.4.     实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-基本条件"><span class="nav-text">3.4.1.     基本条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、提供必要信息"><span class="nav-text">1、提供必要信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#就绪时间"><span class="nav-text">就绪时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开始截止时间-结束截止时间"><span class="nav-text">开始截止时间+结束截止时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理时间"><span class="nav-text">处理时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#资源要求"><span class="nav-text">资源要求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先级"><span class="nav-text">优先级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、系统处理能力强"><span class="nav-text">2、系统处理能力强</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单处理机"><span class="nav-text">单处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#处理时间Ci-周期时间Pi之和-lt-1"><span class="nav-text">处理时间Ci&#x2F;周期时间Pi之和&lt;&#x3D;1</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多处理机"><span class="nav-text">多处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#处理时间Ci-周期时间Pi之和-lt-N"><span class="nav-text">处理时间Ci&#x2F;周期时间Pi之和&lt;&#x3D;N</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、抢占式调度机制"><span class="nav-text">3、抢占式调度机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、快速切换机制"><span class="nav-text">4、快速切换机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对外部中断快速响应"><span class="nav-text">对外部中断快速响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速任务分配"><span class="nav-text">快速任务分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-分类"><span class="nav-text">3.4.2.     分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、非抢占式调度算法"><span class="nav-text">1、非抢占式调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、非抢占式轮转调度算法：同RR"><span class="nav-text">1、非抢占式轮转调度算法：同RR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、非抢占式优先调度算法：严格按优先级"><span class="nav-text">2、非抢占式优先调度算法：严格按优先级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、抢占式调度算法"><span class="nav-text">2、抢占式调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、基于时钟中断的抢占式优先权调度算法"><span class="nav-text">1、基于时钟中断的抢占式优先权调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优先级低于当前任务就等待"><span class="nav-text">优先级低于当前任务就等待</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、立即抢占"><span class="nav-text">2、立即抢占</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#立即响应外部中断"><span class="nav-text">立即响应外部中断</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-常用实时调度算法"><span class="nav-text">3.4.3.     常用实时调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、最早截止时间优先（EDF）"><span class="nav-text">1、最早截止时间优先（EDF）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#抢占-非抢占都可"><span class="nav-text">抢占&#x2F;非抢占都可</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#子主题"><span class="nav-text">子主题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非抢占式调度方式-gt-非周期实时任务；抢占式调度方式-gt-周期实时任务"><span class="nav-text">非抢占式调度方式-&gt;非周期实时任务；抢占式调度方式-&gt;周期实时任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、最低松弛度优先算法（LLF）"><span class="nav-text">2、最低松弛度优先算法（LLF）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主要可抢占"><span class="nav-text">主要可抢占</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#松弛度越低（紧急度越高），优先级越高"><span class="nav-text">松弛度越低（紧急度越高），优先级越高</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#松弛度-必须完成时间-本身运行时间-当前时间"><span class="nav-text">松弛度&#x3D;必须完成时间-本身运行时间-当前时间</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-死锁"><span class="nav-text">3.5.     死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-概念"><span class="nav-text">3.5.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多个进程争夺资源造成的僵局"><span class="nav-text">多个进程争夺资源造成的僵局</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-死锁起因"><span class="nav-text">3.5.2.     死锁起因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#竞争资源"><span class="nav-text">竞争资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：资源数目不能满足进程需要"><span class="nav-text">概念：资源数目不能满足进程需要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#竞争不可抢占性资源-临时性资源"><span class="nav-text">竞争不可抢占性资源&#x2F;临时性资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序不当"><span class="nav-text">顺序不当</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程推进顺序不当"><span class="nav-text">进程推进顺序不当</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-产生死锁的必要条件（同时满足）"><span class="nav-text">3.5.3.     产生死锁的必要条件（同时满足）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、互斥：任一个时刻只允许一个进程使用资源"><span class="nav-text">1、互斥：任一个时刻只允许一个进程使用资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、请求和保持：进程保持了至少一个资源，但又请求新的资源"><span class="nav-text">2、请求和保持：进程保持了至少一个资源，但又请求新的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、不可抢占：已占用资源不可被抢占"><span class="nav-text">3、不可抢占：已占用资源不可被抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、环路等待"><span class="nav-text">4、环路等待</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-处理死锁方法"><span class="nav-text">3.5.4.     处理死锁方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、预防死锁"><span class="nav-text">1、预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：限制并发进程对资源的请求，使之不同时满足四个条件"><span class="nav-text">概念：限制并发进程对资源的请求，使之不同时满足四个条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分类-1"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、摒弃”请求保持“"><span class="nav-text">1、摒弃”请求保持“</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、摒弃”不可剥夺“"><span class="nav-text">2、摒弃”不可剥夺“</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、摒弃”环路等待“"><span class="nav-text">3、摒弃”环路等待“</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、避免死锁"><span class="nav-text">2、避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：资源动态分配过程中，防止系统进入不安全状态"><span class="nav-text">概念：资源动态分配过程中，防止系统进入不安全状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#系统安全状态"><span class="nav-text">系统安全状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#按照安全序列为进程分配资源使每个进程都可以顺利完成"><span class="nav-text">按照安全序列为进程分配资源使每个进程都可以顺利完成</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#银行家算法"><span class="nav-text">银行家算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#安全性算法"><span class="nav-text">安全性算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#特点："><span class="nav-text">特点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、检测死锁"><span class="nav-text">3、检测死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：允许系统进入死锁，但及时检测"><span class="nav-text">概念：允许系统进入死锁，但及时检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁定理："><span class="nav-text">死锁定理：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程"><span class="nav-text">S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤"><span class="nav-text">资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁检测算法"><span class="nav-text">死锁检测算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁检测算法的应用"><span class="nav-text">死锁检测算法的应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、解除死锁"><span class="nav-text">4、解除死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：检测到死锁，采取措施解除"><span class="nav-text">概念：检测到死锁，采取措施解除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#终止进程"><span class="nav-text">终止进程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#剥夺资源"><span class="nav-text">剥夺资源</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-四、存储器管理"><span class="nav-text">4.    四、存储器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-存储器的层次结构"><span class="nav-text">4.1.     存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-存储管理概念"><span class="nav-text">4.1.1.     存储管理概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存"><span class="nav-text">OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可执行存储器：寄存器-主存"><span class="nav-text">可执行存储器：寄存器+主存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-层次结构"><span class="nav-text">4.1.2.     层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU寄存器"><span class="nav-text">CPU寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#寄存器"><span class="nav-text">寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CPU访问速度最快"><span class="nav-text">CPU访问速度最快</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主存"><span class="nav-text">主存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#高速缓存"><span class="nav-text">高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#备份主存常用数据；减少对主存访问速度"><span class="nav-text">备份主存常用数据；减少对主存访问速度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主存储器"><span class="nav-text">主存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#保存进程运行时程序和数据，速度远低于处理机执行"><span class="nav-text">保存进程运行时程序和数据，速度远低于处理机执行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#磁盘缓存"><span class="nav-text">磁盘缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#备份磁盘常用数据，不是独立的存储器（是主存的部分空间）"><span class="nav-text">备份磁盘常用数据，不是独立的存储器（是主存的部分空间）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅存"><span class="nav-text">辅存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#固定磁盘"><span class="nav-text">固定磁盘</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可移动存储介质"><span class="nav-text">可移动存储介质</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-程序的装入和链接"><span class="nav-text">4.2.     程序的装入和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-程序的处理步骤"><span class="nav-text">4.2.1.     程序的处理步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译"><span class="nav-text">编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#由编译程序将源程序-cpp-asm-编译成目标模块-obj"><span class="nav-text">由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接"><span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#由链接程序把目标模块-obj-和它们所需要的库函数链接在一起形成装入模块-EXE-DLL"><span class="nav-text">由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE&#x2F;DLL)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装入"><span class="nav-text">装入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#由装入程序将装入模块-EXE-DLL-装入内存-成为进程"><span class="nav-text">由装入程序将装入模块(EXE&#x2F;DLL)装入内存,成为进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-程序的装入"><span class="nav-text">4.2.2.     程序的装入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、绝对装入"><span class="nav-text">1、绝对装入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码"><span class="nav-text">编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-2"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-4"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-3"><span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、可重定位装入"><span class="nav-text">2、可重定位装入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-1"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量"><span class="nav-text">装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#地址变换装入时一次完成，进程不再移动，故称为静态重定位"><span class="nav-text">地址变换装入时一次完成，进程不再移动，故称为静态重定位</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-3"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-5"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-4"><span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、动态运行时装入"><span class="nav-text">3、动态运行时装入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-2"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程开始执行时部分装入，运行时需要哪个装哪个"><span class="nav-text">进程开始执行时部分装入，运行时需要哪个装哪个</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-4"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-6"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-5"><span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-程序的链接"><span class="nav-text">4.2.3.     程序的链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态链接"><span class="nav-text">静态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-3"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#程序运行前把目标模块和库函数直接链接，以后不再拆开"><span class="nav-text">程序运行前把目标模块和库函数直接链接，以后不再拆开</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#解决的问题"><span class="nav-text">解决的问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-5"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-7"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-6"><span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装入时动态链接"><span class="nav-text">装入时动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-4"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址"><span class="nav-text">边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-6"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-8"><span class="nav-text">优点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时动态链接"><span class="nav-text">运行时动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-5"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上"><span class="nav-text">将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点-7"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-9"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-7"><span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-连续分配存储管理方式"><span class="nav-text">4.3.     连续分配存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-单一连续分配"><span class="nav-text">4.3.1.     单一连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-6"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间"><span class="nav-text">内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点-8"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-10"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#最简单，适用于单用户、单任务，易于管理"><span class="nav-text">最简单，适用于单用户、单任务，易于管理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-8"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#不常用的进程也占用内存"><span class="nav-text">不常用的进程也占用内存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#对要求内存空间少的进程，造成内存浪费"><span class="nav-text">对要求内存空间少的进程，造成内存浪费</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-固定分区分配"><span class="nav-text">4.3.2.     固定分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-7"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）"><span class="nav-text">划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点-9"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-11"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#易于实现，开销小"><span class="nav-text">易于实现，开销小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-9"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#内碎片浪费，分区总数固定，限制了并发执行的程序数目"><span class="nav-text">内碎片浪费，分区总数固定，限制了并发执行的程序数目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内碎片"><span class="nav-text">内碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分区之内未利用空间"><span class="nav-text">分区之内未利用空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外碎片"><span class="nav-text">外碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分区之间空闲分区（通常是小空闲分区）"><span class="nav-text">分区之间空闲分区（通常是小空闲分区）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-动态分区分配"><span class="nav-text">4.3.3.     动态分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-8"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS根据进程的实际需要为各进程分配连续的内存空间"><span class="nav-text">OS根据进程的实际需要为各进程分配连续的内存空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、空闲分区表"><span class="nav-text">1、空闲分区表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、空闲分区链表"><span class="nav-text">2、空闲分区链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分区算法分类"><span class="nav-text">动态分区算法分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、首次适应算法（first-fit）"><span class="nav-text">1、首次适应算法（first-fit）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念：按分区先后次序查找"><span class="nav-text">概念：按分区先后次序查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：分配和释放时间性能较好，空闲分区多分布在内存高端"><span class="nav-text">优点：分配和释放时间性能较好，空闲分区多分布在内存高端</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：查找时间会逐渐增大"><span class="nav-text">缺点：查找时间会逐渐增大</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、循环首次适应算法（next-fit）"><span class="nav-text">2、循环首次适应算法（next-fit）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针"><span class="nav-text">概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：分配和释放时间性能较好，空闲分区分布均匀"><span class="nav-text">优点：分配和释放时间性能较好，空闲分区分布均匀</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：较大的空闲分区不宜保留"><span class="nav-text">缺点：较大的空闲分区不宜保留</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、最佳适应算法（best-fit）"><span class="nav-text">3、最佳适应算法（best-fit）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区"><span class="nav-text">概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：速度较快，可以保留较大的空闲分区"><span class="nav-text">优点：速度较快，可以保留较大的空闲分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：会形成较多外碎片"><span class="nav-text">缺点：会形成较多外碎片</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、最坏适应法（worst-fit）"><span class="nav-text">4、最坏适应法（worst-fit）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念：空闲分区表按从大到小排序，找到最大的空闲分区"><span class="nav-text">概念：空闲分区表按从大到小排序，找到最大的空闲分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：基本不留下小空闲分区"><span class="nav-text">优点：基本不留下小空闲分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：较大的空闲分区不被保留"><span class="nav-text">缺点：较大的空闲分区不被保留</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、快速适应算法"><span class="nav-text">5、快速适应算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念："><span class="nav-text">概念：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点：查找效率高，能保留较大分区"><span class="nav-text">优点：查找效率高，能保留较大分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：回收分区时开销大；空闲分区划分越细，浪费越严重"><span class="nav-text">缺点：回收分区时开销大；空闲分区划分越细，浪费越严重</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、伙伴系统"><span class="nav-text">6、伙伴系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念-9"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点："><span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点："><span class="nav-text">缺点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区分配操作"><span class="nav-text">分区分配操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分配内存"><span class="nav-text">分配内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区"><span class="nav-text">利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回收内存"><span class="nav-text">回收内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、与前一个空闲分区相邻"><span class="nav-text">1、与前一个空闲分区相邻</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、与后一个空闲分区相邻"><span class="nav-text">2、与后一个空闲分区相邻</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、与前、后空闲分区相邻"><span class="nav-text">3、与前、后空闲分区相邻</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、不与空闲分区相邻"><span class="nav-text">4、不与空闲分区相邻</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-动态重定位分区分配"><span class="nav-text">4.3.4.     动态重定位分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、紧凑"><span class="nav-text">1、紧凑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#各个占用分区向内存一端移动，使空闲分区合并在另一端"><span class="nav-text">各个占用分区向内存一端移动，使空闲分区合并在另一端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#何时执行紧凑"><span class="nav-text">何时执行紧凑</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个分区释放后、或者内存分配找不到满足条件的空闲分区时"><span class="nav-text">每个分区释放后、或者内存分配找不到满足条件的空闲分区时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、动态重定位"><span class="nav-text">2、动态重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不用修改程序，用新起始地址置换原来的起始地址即可"><span class="nav-text">不用修改程序，用新起始地址置换原来的起始地址即可</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、动态重定位分区分配算法"><span class="nav-text">3、动态重定位分区分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#找得到按动态分区方式分配"><span class="nav-text">找得到按动态分区方式分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回"><span class="nav-text">找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-覆盖"><span class="nav-text">4.4.     覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-引入目标"><span class="nav-text">4.4.1.     引入目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在较小内存运行较大的程序，常与固定分区配合"><span class="nav-text">在较小内存运行较大的程序，常与固定分区配合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-原理"><span class="nav-text">4.4.2.     原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序的几个代码段和数据段按时间顺序先后占用同一内存空间"><span class="nav-text">程序的几个代码段和数据段按时间顺序先后占用同一内存空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、必要部分常驻内存"><span class="nav-text">1、必要部分常驻内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、不常用部分其他程序模块实现，平时在外存，要用调入内存"><span class="nav-text">2、不常用部分其他程序模块实现，平时在外存，要用调入内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、不存在调用关系的模块不提示调入内存，可以相互覆盖"><span class="nav-text">3、不存在调用关系的模块不提示调入内存，可以相互覆盖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-缺点"><span class="nav-text">4.4.3.     缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增加了编程复杂度：程序员必须了解程序模块之间的划分关系"><span class="nav-text">增加了编程复杂度：程序员必须了解程序模块之间的划分关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外存覆盖内存速度慢，时间换空间"><span class="nav-text">外存覆盖内存速度慢，时间换空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-对换"><span class="nav-text">4.5.     对换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-概念"><span class="nav-text">4.5.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进-滚出（roll-in-roll-out）"><span class="nav-text">将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进&#x2F;滚出（roll-in&#x2F;roll-out）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换单位"><span class="nav-text">交换单位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#整个进程的地址空间"><span class="nav-text">整个进程的地址空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-原理"><span class="nav-text">4.5.2.     原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#换入"><span class="nav-text">换入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入"><span class="nav-text">OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#换出"><span class="nav-text">换出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存"><span class="nav-text">内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-优缺点"><span class="nav-text">4.5.3.     优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-12"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率"><span class="nav-text">增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-10"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性"><span class="nav-text">对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-与覆盖对比"><span class="nav-text">4.5.4.     与覆盖对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、交换不要求程序员了解程序段之间的覆盖结构"><span class="nav-text">1、交换不要求程序员了解程序段之间的覆盖结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行"><span class="nav-text">2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、覆盖只能覆盖与覆盖程序段无关的程序段"><span class="nav-text">3、覆盖只能覆盖与覆盖程序段无关的程序段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-离散分配存储管理方式"><span class="nav-text">4.6.     离散分配存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-连续分配带来的问题：形成内外碎片；紧凑带来开销"><span class="nav-text">4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-分页存储管理方式"><span class="nav-text">4.6.2.     分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-10"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB"><span class="nav-text">将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存空间划分为和页对应大小的块，称为物理块或页框"><span class="nav-text">内存空间划分为和页对应大小的块，称为物理块或页框</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#页和块一一对应，由页面映像表记录"><span class="nav-text">页和块一一对应，由页面映像表记录</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程装载"><span class="nav-text">进程装载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。"><span class="nav-text">装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#要解决地址映像，需要硬件支持"><span class="nav-text">要解决地址映像，需要硬件支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-1"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程页表："><span class="nav-text">进程页表：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个进程一个进程页表，描述进程每个页对应的页框"><span class="nav-text">每个进程一个进程页表，描述进程每个页对应的页框</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#物理页面表"><span class="nav-text">物理页面表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#描述每个物理页框的分配使用情况；数据结构：位示图-空闲页面列表"><span class="nav-text">描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求表"><span class="nav-text">请求表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#描述系统内各个进程页表的位置和大小，用于地址转换"><span class="nav-text">描述系统内各个进程页表的位置和大小，用于地址转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号"><span class="nav-text">请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑地址结构"><span class="nav-text">逻辑地址结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑页号（m-n）-页内偏移量（n位）"><span class="nav-text">逻辑页号（m-n）+页内偏移量（n位）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑地址空间2的m次方，页框大小2的n次方"><span class="nav-text">逻辑地址空间2的m次方，页框大小2的n次方</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点-10"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-13"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#没有外碎片，内碎片大小不超过页大小"><span class="nav-text">没有外碎片，内碎片大小不超过页大小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#程序不必连续存放，便于改变程序占用空间的大小"><span class="nav-text">程序不必连续存放，便于改变程序占用空间的大小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-11"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#程序全部装入内存"><span class="nav-text">程序全部装入内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址变换机构"><span class="nav-text">地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本地址变换机构"><span class="nav-text">基本地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#逻辑地址-逻辑页号-页内偏移地址"><span class="nav-text">逻辑地址&#x3D;逻辑页号+页内偏移地址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#物理地址-页框号-页框内偏移地址"><span class="nav-text">物理地址&#x3D;页框号+页框内偏移地址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#根据页号查进程页表转换为页框号，页内偏移地址-页框内偏移地址"><span class="nav-text">根据页号查进程页表转换为页框号，页内偏移地址&#x3D;页框内偏移地址</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具有快表的地址变换机构"><span class="nav-text">具有快表的地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#大多数页表存储在内存中，需访问两次"><span class="nav-text">大多数页表存储在内存中，需访问两次</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#联想（关联）存储器（快表TLB）"><span class="nav-text">联想（关联）存储器（快表TLB）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#地址变换步骤"><span class="nav-text">地址变换步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两级和多级页表"><span class="nav-text">两级和多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引入原因"><span class="nav-text">引入原因</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法"><span class="nav-text">页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#分散存储"><span class="nav-text">分散存储</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两级页表"><span class="nav-text">两级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#定义-5"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#逻辑地址结构-1"><span class="nav-text">逻辑地址结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#访存次数"><span class="nav-text">访存次数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多级页表"><span class="nav-text">多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#定义-6"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#访存次数-1"><span class="nav-text">访存次数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算方法："><span class="nav-text">计算方法：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反置页表"><span class="nav-text">反置页表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#定义-7"><span class="nav-text">定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#检索方式"><span class="nav-text">检索方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#特点-2"><span class="nav-text">特点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-分段存储管理方式"><span class="nav-text">4.6.3.     分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-11"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始"><span class="nav-text">按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#程序划分为数据段、代码段、和共享段，可以分别编写编译"><span class="nav-text">程序划分为数据段、代码段、和共享段，可以分别编写编译</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特征-2"><span class="nav-text">特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方便编程"><span class="nav-text">方便编程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分段共享"><span class="nav-text">分段共享</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分段保护"><span class="nav-text">分段保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#根据不同类型的段采取不同的保护措施"><span class="nav-text">根据不同类型的段采取不同的保护措施</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态链接"><span class="nav-text">动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程开始时只装入主模块，运行时再根据需要装入其他模块"><span class="nav-text">进程开始时只装入主模块，运行时再根据需要装入其他模块</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态增长"><span class="nav-text">动态增长</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#比如数据段可能根据需要增大"><span class="nav-text">比如数据段可能根据需要增大</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-2"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程段表："><span class="nav-text">进程段表：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长"><span class="nav-text">每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#系统段表"><span class="nav-text">系统段表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#描述每个占用段的分配使用情况"><span class="nav-text">描述每个占用段的分配使用情况</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空闲段表"><span class="nav-text">空闲段表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#描述每个空闲段，可以结合到系统段表中"><span class="nav-text">描述每个空闲段，可以结合到系统段表中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑地址结构-2"><span class="nav-text">逻辑地址结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#段号（m-n）-段内地址（n位）"><span class="nav-text">段号（m-n）+段内地址（n位）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点-11"><span class="nav-text">优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-14"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#没有内碎片，外碎片可以紧凑来消除"><span class="nav-text">没有内碎片，外碎片可以紧凑来消除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#程序不必连续存放，便于改变程序占用空间的大小-1"><span class="nav-text">程序不必连续存放，便于改变程序占用空间的大小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-12"><span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#程序全部装入内存-1"><span class="nav-text">程序全部装入内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址变换机构-1"><span class="nav-text">地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本地址变换机构-1"><span class="nav-text">基本地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#逻辑地址-段号S-段内地址d"><span class="nav-text">逻辑地址&#x3D;段号S+段内地址d</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#段表寄存器-段表始地址f-段表长度TL"><span class="nav-text">段表寄存器&#x3D;段表始地址f+段表长度TL</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#段表-段长SL-段基址d"><span class="nav-text">段表&#x3D;段长SL+段基址d</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#步骤"><span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具有快表的地址变换机构-1"><span class="nav-text">具有快表的地址变换机构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页和分段的主要区别"><span class="nav-text">分页和分段的主要区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、单位：页是物理单位，段是逻辑单位。"><span class="nav-text">1、单位：页是物理单位，段是逻辑单位。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、目的：分页目的是系统管理，分段目的是用户需要"><span class="nav-text">2、目的：分页目的是系统管理，分段目的是用户需要</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、大小：页大小系统固定，段不固定"><span class="nav-text">3、大小：页大小系统固定，段不固定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、地址空间：分页一维（页号），分段二维（段号-段内地址）"><span class="nav-text">4、地址空间：分页一维（页号），分段二维（段号+段内地址）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度"><span class="nav-text">5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、共享：分段方便共享代码"><span class="nav-text">6、共享：分段方便共享代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信息共享"><span class="nav-text">信息共享</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#能共享的代码必须是可重入代码"><span class="nav-text">能共享的代码必须是可重入代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可重入代码："><span class="nav-text">可重入代码：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#允许多个进程同时访问，代码执行时不允许修改"><span class="nav-text">允许多个进程同时访问，代码执行时不允许修改</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量"><span class="nav-text">调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-4-段页式存储管理方式"><span class="nav-text">4.6.4.     段页式存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-12"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#段内分页，先将用户程序分为若干段，每个段再分为若干页"><span class="nav-text">段内分页，先将用户程序分为若干段，每个段再分为若干页</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-3"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每个进程一张段表，每个段一张页表。"><span class="nav-text">每个进程一张段表，每个段一张页表。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段表-段表大小-段表首地址"><span class="nav-text">段表&#x3D;段表大小+段表首地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#页表-段号-段内页号-页内偏移量"><span class="nav-text">页表&#x3D;段号+段内页号+页内偏移量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址变换机构-2"><span class="nav-text">地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#暂定"><span class="nav-text">暂定</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-五、虚拟存储器"><span class="nav-text">5.    五、虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-虚拟存储器概述"><span class="nav-text">5.1.     虚拟存储器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-问题"><span class="nav-text">5.1.1.     问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前面介绍的方式：1、进程一次性装入内存-2、有大量进程等待运行，但实际内存不足以全部装入"><span class="nav-text">前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-常规存储管理方式特征"><span class="nav-text">5.1.2.     常规存储管理方式特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、一次性"><span class="nav-text">1、一次性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、程序的驻留性"><span class="nav-text">2、程序的驻留性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用"><span class="nav-text">装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-定义"><span class="nav-text">5.1.3.     定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统"><span class="nav-text">是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#借助于外存空间，允许一个进程在其运行过程只部分装入"><span class="nav-text">借助于外存空间，允许一个进程在其运行过程只部分装入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和"><span class="nav-text">虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对用户透明，用户地址空间称为虚存空间或虚地址空间"><span class="nav-text">对用户透明，用户地址空间称为虚存空间或虚地址空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-工作过程"><span class="nav-text">5.1.4.     工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、进程部分装入"><span class="nav-text">1、进程部分装入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、执行时内容不在内存（缺页-缺段），请求调入"><span class="nav-text">2、执行时内容不在内存（缺页&#x2F;缺段），请求调入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、若此时内存已满，请求置换"><span class="nav-text">3、若此时内存已满，请求置换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-好处"><span class="nav-text">5.1.5.     好处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、较小的内存可以运行较大的进程"><span class="nav-text">1、较小的内存可以运行较大的进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、容纳更多进程并发执行"><span class="nav-text">2、容纳更多进程并发执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、不影响编程的程序结构（和覆盖不同）"><span class="nav-text">3、不影响编程的程序结构（和覆盖不同）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、提供的虚拟内存空间大于物理内存"><span class="nav-text">4、提供的虚拟内存空间大于物理内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-局部性原理"><span class="nav-text">5.1.6.     局部性原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域"><span class="nav-text">指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1、时间局部性"><span class="nav-text">1、时间局部性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#循环结构"><span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#指令-数据的执行-访问局限在较短时期"><span class="nav-text">指令&#x2F;数据的执行&#x2F;访问局限在较短时期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、空间局部性"><span class="nav-text">2、空间局部性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序执行-1"><span class="nav-text">顺序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#访问的地址局限在一定范围内（例如·数组）"><span class="nav-text">访问的地址局限在一定范围内（例如·数组）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体实现"><span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-7-实现方式"><span class="nav-text">5.1.7.     实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分页请求系统"><span class="nav-text">分页请求系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#纯分页系统-请求调页-页面置换——页面虚拟存储器"><span class="nav-text">纯分页系统+请求调页+页面置换——页面虚拟存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、硬件支持"><span class="nav-text">1、硬件支持</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、页表增加项"><span class="nav-text">1、页表增加项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、缺页中断"><span class="nav-text">2、缺页中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、地址变换机构"><span class="nav-text">3、地址变换机构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、实现请求分页的软件"><span class="nav-text">2、实现请求分页的软件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求分段系统"><span class="nav-text">请求分段系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#纯分段系统-请求调段-分段置换——段式虚拟存储器"><span class="nav-text">纯分段系统+请求调段+分段置换——段式虚拟存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、硬件支持-1"><span class="nav-text">1、硬件支持</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、段表增加项"><span class="nav-text">1、段表增加项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、缺段中断"><span class="nav-text">2、缺段中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、地址变换机构-1"><span class="nav-text">3、地址变换机构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#需要CPU、MMU支持，段页式"><span class="nav-text">需要CPU、MMU支持，段页式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-8-特征"><span class="nav-text">5.1.8.     特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、多次性"><span class="nav-text">1、多次性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程-作业多次调度"><span class="nav-text">进程&#x2F;作业多次调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、对换性"><span class="nav-text">2、对换性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、虚拟性"><span class="nav-text">3、虚拟性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑地址空间-gt-实际物理内存"><span class="nav-text">逻辑地址空间&gt;实际物理内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、离散性"><span class="nav-text">4、离散性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的物理空间不连续"><span class="nav-text">进程的物理空间不连续</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-请求分页存储器管理方式"><span class="nav-text">5.2.     请求分页存储器管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-概念"><span class="nav-text">5.2.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在基础分页存储管理基础上增加请求调页和页面置换功能"><span class="nav-text">在基础分页存储管理基础上增加请求调页和页面置换功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本单位：长度固定的页"><span class="nav-text">基本单位：长度固定的页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps-虚拟存储是最常用的实现方式"><span class="nav-text">ps:虚拟存储是最常用的实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-硬件支持"><span class="nav-text">5.2.2.     硬件支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、进程页表：增加项"><span class="nav-text">1、进程页表：增加项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、状态位：在内存还是外存"><span class="nav-text">1、状态位：在内存还是外存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、修改位：该页是否修改过"><span class="nav-text">2、修改位：该页是否修改过</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔"><span class="nav-text">3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、外存地址：磁盘地址"><span class="nav-text">4、外存地址：磁盘地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、缺页中断机构"><span class="nav-text">2、缺页中断机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序"><span class="nav-text">概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）"><span class="nav-text">缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、地址变换机构-2"><span class="nav-text">3、地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在原基础上增加缺页中断，具体看PPT29"><span class="nav-text">在原基础上增加缺页中断，具体看PPT29</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-内存分配"><span class="nav-text">5.2.3.     内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、最小物理块数的确定"><span class="nav-text">1、最小物理块数的确定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行"><span class="nav-text">OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程运行最小页框数和指令系统有关"><span class="nav-text">进程运行最小页框数和指令系统有关</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、单地址-直接寻址"><span class="nav-text">1、单地址+直接寻址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、间接寻址"><span class="nav-text">2、间接寻址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、如swap-A，B"><span class="nav-text">3、如swap A，B</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、物理块的分配策略"><span class="nav-text">2、物理块的分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、固定分配局部置换"><span class="nav-text">1、固定分配局部置换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个进程分配固定页框"><span class="nav-text">每个进程分配固定页框</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺页从该进程所属页框调出旧页面，换出新页面"><span class="nav-text">缺页从该进程所属页框调出旧页面，换出新页面</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#困难点："><span class="nav-text">困难点：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、可变分配全局置换（最易实现）"><span class="nav-text">2、可变分配全局置换（最易实现）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个进程分配固定页框，OS控制一定数量的空闲页框"><span class="nav-text">每个进程分配固定页框，OS控制一定数量的空闲页框</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框"><span class="nav-text">缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#困难点：-1"><span class="nav-text">困难点：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、可变分配局部置换"><span class="nav-text">2、可变分配局部置换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个进程分配固定页框，OS控制一定数量空闲页框"><span class="nav-text">每个进程分配固定页框，OS控制一定数量空闲页框</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺页先计算缺页中断率"><span class="nav-text">缺页先计算缺页中断率</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#困难点：-2"><span class="nav-text">困难点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、物理块的分配算法"><span class="nav-text">3、物理块的分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、平均分配"><span class="nav-text">1、平均分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、按比例分配"><span class="nav-text">2、按比例分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、按优先权分配"><span class="nav-text">3、按优先权分配</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-页面调入"><span class="nav-text">5.3.     页面调入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-页面调入策略"><span class="nav-text">5.3.1.     页面调入策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入"><span class="nav-text">OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1、何时调入"><span class="nav-text">1、何时调入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、预调页"><span class="nav-text">1、预调页</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）"><span class="nav-text">缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、请求调页"><span class="nav-text">2、请求调页</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#缺页只调缺的这一页"><span class="nav-text">缺页只调缺的这一页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、何处调入"><span class="nav-text">2、何处调入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、进程运行前"><span class="nav-text">1、进程运行前</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#全部页面从文件区调入交换区，以后都从交换区调"><span class="nav-text">全部页面从文件区调入交换区，以后都从交换区调</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、运行中"><span class="nav-text">2、运行中</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#未被修改的页面一直从文件区调"><span class="nav-text">未被修改的页面一直从文件区调</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><span class="nav-text">被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、UNIX方式"><span class="nav-text">3、UNIX方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#未运行的页面一直从文件区调"><span class="nav-text">未运行的页面一直从文件区调</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><span class="nav-text">运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-页面调入过程"><span class="nav-text">5.3.2.     页面调入过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PPT30"><span class="nav-text">PPT30</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-页面调入算法"><span class="nav-text">5.3.3.     页面调入算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#功能-5"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存满时，选择内存中哪个页面置换"><span class="nav-text">内存满时，选择内存中哪个页面置换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目标-5"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”"><span class="nav-text">降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面锁定"><span class="nav-text">页面锁定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志"><span class="nav-text">OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类-2"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、最佳置换算法（OPT）"><span class="nav-text">1、最佳置换算法（OPT）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#选择“以后不用的”或”离当前位置最远的“页面置换"><span class="nav-text">选择“以后不用的”或”离当前位置最远的“页面置换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#理想情况，不能实现，只作为评价依据"><span class="nav-text">理想情况，不能实现，只作为评价依据</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、先进先出置换算法（FIFO）"><span class="nav-text">2、先进先出置换算法（FIFO）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#选择“建立最早”页面置换"><span class="nav-text">选择“建立最早”页面置换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法-1"><span class="nav-text">方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：-1"><span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Belady现象："><span class="nav-text">Belady现象：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、最近最久未使用置换算法（LRU）"><span class="nav-text">3、最近最久未使用置换算法（LRU）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用最近的过去预测最近的将来，选择“最久未使用”页面置换"><span class="nav-text">利用最近的过去预测最近的将来，选择“最久未使用”页面置换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法："><span class="nav-text">方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点：-2"><span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#硬件机构"><span class="nav-text">硬件机构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Clock置换算法"><span class="nav-text">4、Clock置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合"><span class="nav-text">又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#一、简单Clock置换算法"><span class="nav-text">一、简单Clock置换算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#二、改进Clock置换算法"><span class="nav-text">二、改进Clock置换算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps：其他置换算法"><span class="nav-text">ps：其他置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5、最少使用置换算法（LFU）"><span class="nav-text">5、最少使用置换算法（LFU）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6、页面缓冲算法（PB）"><span class="nav-text">6、页面缓冲算法（PB）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-抖动与工作集"><span class="nav-text">5.4.     抖动与工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-缺页率与页框数"><span class="nav-text">5.4.1.     缺页率与页框数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点"><span class="nav-text">缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-工作集"><span class="nav-text">5.4.2.     工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-13"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#w-△-t-某段时间间隔-t-△-，t-里-t是执行时刻），进程实际要访问的页面的集合"><span class="nav-text">w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性质"><span class="nav-text">性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#随△单调递增"><span class="nav-text">随△单调递增</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值"><span class="nav-text">局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入目的"><span class="nav-text">引入目的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来"><span class="nav-text">依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤："><span class="nav-text">步骤：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OS跟着进程们，分配给进程大于工作集的帧数"><span class="nav-text">OS跟着进程们，分配给进程大于工作集的帧数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有空闲帧，启动另一个进程"><span class="nav-text">有空闲帧，启动另一个进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果所有工作集之和大于帧总数，OS选择挂起某个进程"><span class="nav-text">如果所有工作集之和大于帧总数，OS选择挂起某个进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-15"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作集防止了抖动，提高了程序并发度"><span class="nav-text">工作集防止了抖动，提高了程序并发度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#困难"><span class="nav-text">困难</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#过去预测未来可能不准确"><span class="nav-text">过去预测未来可能不准确</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#记录工作集变化增加了开销，开销大"><span class="nav-text">记录工作集变化增加了开销，开销大</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#△取值难以优化，而且通常该值不断改变"><span class="nav-text">△取值难以优化，而且通常该值不断改变</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-3-抖动"><span class="nav-text">5.4.3.     抖动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-14"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动"><span class="nav-text">每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生原因"><span class="nav-text">产生原因</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）"><span class="nav-text">随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#因此要选个合适的进程数目"><span class="nav-text">因此要选个合适的进程数目</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预防方法"><span class="nav-text">预防方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、引入工作集算法"><span class="nav-text">1、引入工作集算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、挂起若干进程"><span class="nav-text">2、挂起若干进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I-O等待队列中）"><span class="nav-text">3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I&#x2F;O等待队列中）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、L-S准则：产生缺页的时间L-系统处理缺页的平均时间S，此时CPU利用率最好"><span class="nav-text">4、L&#x3D;S准则：产生缺页的时间L&#x3D;系统处理缺页的平均时间S，此时CPU利用率最好</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-请求分段存储器管理方式"><span class="nav-text">5.5.     请求分段存储器管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-概念"><span class="nav-text">5.5.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在基础分段存储管理基础上增加请求调段和段置换功能"><span class="nav-text">在基础分段存储管理基础上增加请求调段和段置换功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本单位：长度不固定的段"><span class="nav-text">基本单位：长度不固定的段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-硬件支持"><span class="nav-text">5.5.2.     硬件支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、进程页表：增加项-1"><span class="nav-text">1、进程页表：增加项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、存取方式：只执行、只读、读-写"><span class="nav-text">1、存取方式：只执行、只读、读&#x2F;写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、增补位：是否动态增长"><span class="nav-text">2、增补位：是否动态增长</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他和请求分页一样"><span class="nav-text">其他和请求分页一样</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、缺段中断机构"><span class="nav-text">2、缺段中断机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分段越界中断处理；分段保护中断处理；缺段中断处理"><span class="nav-text">分段越界中断处理；分段保护中断处理；缺段中断处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、地址变换机构-3"><span class="nav-text">3、地址变换机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在原基础上增加缺段中断，具体看PPT32"><span class="nav-text">在原基础上增加缺段中断，具体看PPT32</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-分段共享"><span class="nav-text">5.5.3.     分段共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-4"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#共享段表"><span class="nav-text">共享段表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#系统中配置一张，所有共享段在该表中都有一项PPT32"><span class="nav-text">系统中配置一张，所有共享段在该表中都有一项PPT32</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享段的分配与回收"><span class="nav-text">共享段的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、分配"><span class="nav-text">1、分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#首次用共享段，调入内存，填写共享段表项，置共享进程计数count-1"><span class="nav-text">首次用共享段，调入内存，填写共享段表项，置共享进程计数count&#x3D;1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他进程使用，count"><span class="nav-text">其他进程使用，count++</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、回收"><span class="nav-text">2、回收</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#修改共享段表，count-0"><span class="nav-text">修改共享段表，count&#x3D;0</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#将该段占用内存回收"><span class="nav-text">将该段占用内存回收</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#另外，共享段一般不放入外存"><span class="nav-text">另外，共享段一般不放入外存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-4-分段保护"><span class="nav-text">5.5.4.     分段保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、越界检查"><span class="nav-text">1、越界检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、存取控制检查"><span class="nav-text">2、存取控制检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、环保护机构"><span class="nav-text">3、环保护机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#低环有高优先权，OS在0环"><span class="nav-text">低环有高优先权，OS在0环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#访问调用原则"><span class="nav-text">访问调用原则</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#一个程序可访问相同环或低优先权环的数据"><span class="nav-text">一个程序可访问相同环或低优先权环的数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#一个程序可调用相同环或高优先权环的数据"><span class="nav-text">一个程序可调用相同环或高优先权环的数据</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-六、设备管理"><span class="nav-text">6.    六、设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-设备管理概述"><span class="nav-text">6.1.     设备管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-概念"><span class="nav-text">6.1.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OS中负责I-O设备管理的部分叫做I-O系统，完成设备管理功能，对OS影响非常大"><span class="nav-text">OS中负责I&#x2F;O设备管理的部分叫做I&#x2F;O系统，完成设备管理功能，对OS影响非常大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备管理是最繁杂且与硬件关联最紧密的部分"><span class="nav-text">设备管理是最繁杂且与硬件关联最紧密的部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-主要对象"><span class="nav-text">6.1.2.     主要对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O设备，设备控制器，I-O通道"><span class="nav-text">I&#x2F;O设备，设备控制器，I&#x2F;O通道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-基本任务"><span class="nav-text">6.1.3.     基本任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#完成用户I-O请求，提高I-O效率，提高I-O设备利用率"><span class="nav-text">完成用户I&#x2F;O请求，提高I&#x2F;O效率，提高I&#x2F;O设备利用率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-主要功能"><span class="nav-text">6.1.4.     主要功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存区管理；设备分配-管理；虚拟存储；实现设备独立性"><span class="nav-text">缓存区管理；设备分配&#x2F;管理；虚拟存储；实现设备独立性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-I-O系统概述"><span class="nav-text">6.2.     I&#x2F;O系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-I-O系统组成"><span class="nav-text">6.2.1.     I&#x2F;O系统组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O设备，设备控制器及接口，I-O通道，总线等"><span class="nav-text">I&#x2F;O设备，设备控制器及接口，I&#x2F;O通道，总线等</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-I-O设备类型"><span class="nav-text">6.2.2.     I&#x2F;O设备类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、按传输速率"><span class="nav-text">1、按传输速率</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#低-中-高速"><span class="nav-text">低&#x2F;中&#x2F;高速</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、按信息交换单位"><span class="nav-text">2、按信息交换单位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#块设备——数据块为单位"><span class="nav-text">块设备——数据块为单位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符设备——字符为单位"><span class="nav-text">字符设备——字符为单位</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、按设备共享属性"><span class="nav-text">3、按设备共享属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#独占"><span class="nav-text">独占</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#共享"><span class="nav-text">共享</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟"><span class="nav-text">虚拟</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用"><span class="nav-text">虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-设备与控制器之间的接口"><span class="nav-text">6.2.3.     设备与控制器之间的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备"><span class="nav-text">设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制器与设备传递的信号"><span class="nav-text">控制器与设备传递的信号</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、数据信号：控制器-gt-设备"><span class="nav-text">1、数据信号：控制器-&gt;设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、控制信号：控制器-gt-设备"><span class="nav-text">2、控制信号：控制器-&gt;设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、状态信号：设备-gt-控制器"><span class="nav-text">3、状态信号：设备-&gt;控制器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-设备管理目标"><span class="nav-text">6.3.     设备管理目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-1、提供统一界面，方便用户使用"><span class="nav-text">6.3.1.     1、提供统一界面，方便用户使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-2、发挥系统并行性，提高I-O使用效率"><span class="nav-text">6.3.2.     2、发挥系统并行性，提高I&#x2F;O使用效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-3、设备保护：实现设备的正确安全使用"><span class="nav-text">6.3.3.     3、设备保护：实现设备的正确安全使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-缓冲管理"><span class="nav-text">6.4.     缓冲管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-概念"><span class="nav-text">6.4.1.     概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域"><span class="nav-text">缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-引入缓冲区原因"><span class="nav-text">6.4.2.     引入缓冲区原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、处理数据的生产者和消费者速度不匹配"><span class="nav-text">1、处理数据的生产者和消费者速度不匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、协调传输速度不一致的设备"><span class="nav-text">2、协调传输速度不一致的设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、减少CPU中断频率"><span class="nav-text">3、减少CPU中断频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、提高CPU和I-O设备之间的并行性"><span class="nav-text">4、提高CPU和I&#x2F;O设备之间的并行性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-缓冲区分类"><span class="nav-text">6.4.3.     缓冲区分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单缓冲"><span class="nav-text">单缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个缓冲区，CPU外设轮流使用"><span class="nav-text">一个缓冲区，CPU外设轮流使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双缓冲区"><span class="nav-text">双缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#两个缓冲区，CPU和外设处理速度相近，可以连续处理"><span class="nav-text">两个缓冲区，CPU和外设处理速度相近，可以连续处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环缓冲"><span class="nav-text">循环缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大"><span class="nav-text">环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池"><span class="nav-text">缓冲池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分类-3"><span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、空闲缓冲区队列emq"><span class="nav-text">1、空闲缓冲区队列emq</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、输入缓冲区队列inq"><span class="nav-text">2、输入缓冲区队列inq</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、输出缓冲区队列outq"><span class="nav-text">3、输出缓冲区队列outq</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作"><span class="nav-text">操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、收容输入"><span class="nav-text">1、收容输入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、提取输入"><span class="nav-text">2、提取输入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、收容输出"><span class="nav-text">3、收容输出</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、提取输出"><span class="nav-text">4、提取输出</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-I-O软件"><span class="nav-text">6.5.     I&#x2F;O软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-设计目标"><span class="nav-text">6.5.1.     设计目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高效性"><span class="nav-text">高效性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#确保I-O设备与CPU并发性，提高资源利用率"><span class="nav-text">确保I&#x2F;O设备与CPU并发性，提高资源利用率</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用性"><span class="nav-text">通用性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作"><span class="nav-text">提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-采用方式"><span class="nav-text">6.5.2.     采用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象、包装、软件分层"><span class="nav-text">抽象、包装、软件分层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-应达到的目标"><span class="nav-text">6.5.3.     应达到的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射"><span class="nav-text">1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、统一命令"><span class="nav-text">2、统一命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、对错误的处理：尽可能低层处理，不涉及高层"><span class="nav-text">3、对错误的处理：尽可能低层处理，不涉及高层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、缓冲技术"><span class="nav-text">4、缓冲技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、设备的分配和回收"><span class="nav-text">5、设备的分配和回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、I-O控制方式：不同设备的控制方式不同"><span class="nav-text">6、I&#x2F;O控制方式：不同设备的控制方式不同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-层次结构"><span class="nav-text">6.5.4.     层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、用户空间软件"><span class="nav-text">1、用户空间软件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用户层软件必须通过一组系统调用获取OS服务"><span class="nav-text">用户层软件必须通过一组系统调用获取OS服务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、与设备无关的OS软件（无关层）"><span class="nav-text">2、与设备无关的OS软件（无关层）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设备独立性概念"><span class="nav-text">设备独立性概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件"><span class="nav-text">基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#设备独立性软件设置在驱动程序之上，界限因OS的不同而不同"><span class="nav-text">设备独立性软件设置在驱动程序之上，界限因OS的不同而不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使应用程序独立于物理设备"><span class="nav-text">使应用程序独立于物理设备</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实现方式-2"><span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、引入物理设备、逻辑设备"><span class="nav-text">1、引入物理设备、逻辑设备</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、应用程序通过逻辑设备名调用设备，OS负责转换"><span class="nav-text">2、应用程序通过逻辑设备名调用设备，OS负责转换</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设备独立性好处"><span class="nav-text">设备独立性好处</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、设备分配的灵活性"><span class="nav-text">1、设备分配的灵活性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、实现I-O重定向：实现I-O操作的设备可更换，而不用改变应用程序"><span class="nav-text">2、实现I&#x2F;O重定向：实现I&#x2F;O操作的设备可更换，而不用改变应用程序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设备独立性软件功能"><span class="nav-text">设备独立性软件功能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、执行所有设备的公有操作"><span class="nav-text">1、执行所有设备的公有操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、向用户层软件提供统一接口"><span class="nav-text">2、向用户层软件提供统一接口</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑设备映射到物理设备的方式"><span class="nav-text">逻辑设备映射到物理设备的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、逻辑设备表LUT"><span class="nav-text">1、逻辑设备表LUT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、LUT的实现可以采用两种方式"><span class="nav-text">2、LUT的实现可以采用两种方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、设备驱动程序（驱动层）"><span class="nav-text">3、设备驱动程序（驱动层）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理过程"><span class="nav-text">处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、抽象要求转具体要求"><span class="nav-text">1、抽象要求转具体要求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、检查I-O请求合法性"><span class="nav-text">2、检查I&#x2F;O请求合法性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、读出和检查设备状态"><span class="nav-text">3、读出和检查设备状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、传送参数"><span class="nav-text">4、传送参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5、设置工作方式"><span class="nav-text">5、设置工作方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6、启动I-O设备"><span class="nav-text">6、启动I&#x2F;O设备</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特点-3"><span class="nav-text">特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、I-O请求进程与设备控制器之间的桥梁，中转数据和控制"><span class="nav-text">1、I&#x2F;O请求进程与设备控制器之间的桥梁，中转数据和控制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、与I-O设备特性、控制方式、硬件密切相关"><span class="nav-text">2、与I&#x2F;O设备特性、控制方式、硬件密切相关</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、向上屏蔽设备细节"><span class="nav-text">3、向上屏蔽设备细节</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、驱动程序允许可重入"><span class="nav-text">4、驱动程序允许可重入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、中断处理程序"><span class="nav-text">4、中断处理程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、硬件"><span class="nav-text">5、硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ps："><span class="nav-text">ps：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#功能上看，无关层为I-O管理的主要部分"><span class="nav-text">功能上看，无关层为I&#x2F;O管理的主要部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码量上看，驱动层为I-O管理的主要部分"><span class="nav-text">代码量上看，驱动层为I&#x2F;O管理的主要部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5-设备分配与回收"><span class="nav-text">6.5.5.     设备分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备分配"><span class="nav-text">设备分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据结构-5"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、系统设备表SDT"><span class="nav-text">1、系统设备表SDT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、设备控制表DCT"><span class="nav-text">2、设备控制表DCT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、控制器控制表COCT"><span class="nav-text">3、控制器控制表COCT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、通道控制表CHCT"><span class="nav-text">4、通道控制表CHCT</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#考虑因素"><span class="nav-text">考虑因素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、设备固有属性"><span class="nav-text">1、设备固有属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、设备分配算法"><span class="nav-text">2、设备分配算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、设备分配的安全性"><span class="nav-text">3、设备分配的安全性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#独占设备的分配程序"><span class="nav-text">独占设备的分配程序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、分配设备"><span class="nav-text">1、分配设备</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、分配控制器"><span class="nav-text">2、分配控制器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、分配通道"><span class="nav-text">3、分配通道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPOOLing技术（假脱机）"><span class="nav-text">SPOOLing技术（假脱机）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概念-15"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机"><span class="nav-text">联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#联机I-O，主机直接控制I-O"><span class="nav-text">联机I&#x2F;O，主机直接控制I&#x2F;O</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#脱机I-O，一台外围机控制器代替主机控制I-O"><span class="nav-text">脱机I&#x2F;O，一台外围机控制器代替主机控制I&#x2F;O</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SPOOLing用联机I-O模拟脱机I-O工作"><span class="nav-text">SPOOLing用联机I&#x2F;O模拟脱机I&#x2F;O工作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原理"><span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#SPOOLing程序预先从外设输入data并缓冲，称为输入井-时机合适输入到应用程序"><span class="nav-text">SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设"><span class="nav-text">SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#以上称为实际I-O"><span class="nav-text">以上称为实际I&#x2F;O</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缓冲池中读入和读出就不是实际I-O"><span class="nav-text">缓冲池中读入和读出就不是实际I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组成"><span class="nav-text">组成</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、输入井和输出井：在磁盘"><span class="nav-text">1、输入井和输出井：在磁盘</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾"><span class="nav-text">2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、输入进程和输出进程：守护进程"><span class="nav-text">3、输入进程和输出进程：守护进程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-16"><span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、高速虚拟I-O操作"><span class="nav-text">1、高速虚拟I&#x2F;O操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、实现独享设备的共享"><span class="nav-text">2、实现独享设备的共享</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、SPOOLing程序提供虚拟设备"><span class="nav-text">3、SPOOLing程序提供虚拟设备</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-磁盘调度"><span class="nav-text">6.6.     磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-磁盘存储器管理"><span class="nav-text">6.6.1.     磁盘存储器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘存储器：随机读写、共享设备，可移动介质"><span class="nav-text">磁盘存储器：随机读写、共享设备，可移动介质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点：容量大，速度快"><span class="nav-text">特点：容量大，速度快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理要求：合理分配空间，访问效率高。容错强。"><span class="nav-text">管理要求：合理分配空间，访问效率高。容错强。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其性能直接影响文件系统的性能指标"><span class="nav-text">其性能直接影响文件系统的性能指标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-磁盘性能"><span class="nav-text">6.6.2.     磁盘性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据的组织"><span class="nav-text">数据的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#地址格式：驱动器号-磁道号-磁头号-扇区号"><span class="nav-text">地址格式：驱动器号+磁道号+磁头号+扇区号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘类型"><span class="nav-text">磁盘类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#固定头磁盘；移动头磁盘"><span class="nav-text">固定头磁盘；移动头磁盘</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘访问时间"><span class="nav-text">磁盘访问时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#寻道时间-旋转延迟时间-传输时间"><span class="nav-text">寻道时间+旋转延迟时间+传输时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寻道时间是主要影响参数"><span class="nav-text">寻道时间是主要影响参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提高速度的途径"><span class="nav-text">提高速度的途径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、硬件解决"><span class="nav-text">1、硬件解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、好的调度算法"><span class="nav-text">2、好的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#减少寻道时间"><span class="nav-text">减少寻道时间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、缓冲区"><span class="nav-text">3、缓冲区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-调度算法"><span class="nav-text">6.6.3.     调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、先来先服务"><span class="nav-text">1、先来先服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#执行顺序为磁盘I-O请求先后顺序"><span class="nav-text">执行顺序为磁盘I&#x2F;O请求先后顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、最短寻道时间优先（SSTF）"><span class="nav-text">2、最短寻道时间优先（SSTF）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选择距当前磁头移动最少的磁盘I-O请求"><span class="nav-text">选择距当前磁头移动最少的磁盘I&#x2F;O请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不能保证平均寻道时间最短，进程可能饿死"><span class="nav-text">不能保证平均寻道时间最短，进程可能饿死</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、扫描算法（SCAN）"><span class="nav-text">3、扫描算法（SCAN）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（电梯调度算法）选择当前磁头前进方向上移动距离最少的I-O请求，没有前进方向的请求才改变方向"><span class="nav-text">（电梯调度算法）选择当前磁头前进方向上移动距离最少的I&#x2F;O请求，没有前进方向的请求才改变方向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SSTF的改进，没有进程饿死"><span class="nav-text">SSTF的改进，没有进程饿死</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、循环扫描算法（CSCAN）"><span class="nav-text">4、循环扫描算法（CSCAN）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选定一个方向扫描，到末尾再返回最里欲访问的磁道"><span class="nav-text">选定一个方向扫描，到末尾再返回最里欲访问的磁道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#负载或重负载时，磁盘I-O性能比扫描算法好"><span class="nav-text">负载或重负载时，磁盘I&#x2F;O性能比扫描算法好</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、N-Step-SCAN算法"><span class="nav-text">5、N-Step-SCAN算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法"><span class="nav-text">磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目标-6"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#解决磁臂黏着问题"><span class="nav-text">解决磁臂黏着问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、FSCAN调度算法"><span class="nav-text">6、FSCAN调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法"><span class="nav-text">磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目标-7"><span class="nav-text">目标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#解决磁臂黏着问题-1"><span class="nav-text">解决磁臂黏着问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-4-磁盘高速缓存"><span class="nav-text">6.6.4.     磁盘高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-16"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存"><span class="nav-text">利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1、磁盘高速缓存形式"><span class="nav-text">1、磁盘高速缓存形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#大小固定"><span class="nav-text">大小固定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#未利用的内存空间组成缓冲池"><span class="nav-text">未利用的内存空间组成缓冲池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、数据交付方式"><span class="nav-text">2、数据交付方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、磁盘高速缓存中的数据直接传送到请求进程的内存区"><span class="nav-text">1、磁盘高速缓存中的数据直接传送到请求进程的内存区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、磁盘高速缓存中的数据指针传送到请求进程的内存区"><span class="nav-text">2、磁盘高速缓存中的数据指针传送到请求进程的内存区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、置换算法"><span class="nav-text">3、置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU-NRU-最少使用算法"><span class="nav-text">LRU&#x2F;NRU&#x2F;最少使用算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保持数据的一致性"><span class="nav-text">如何保持数据的一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#备用电源"><span class="nav-text">备用电源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OS定期回写"><span class="nav-text">OS定期回写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-5-提高磁盘I-O速度的其他方法"><span class="nav-text">6.6.5.     提高磁盘I&#x2F;O速度的其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、提前读"><span class="nav-text">1、提前读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、延迟写"><span class="nav-text">2、延迟写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、优化物理块的分布"><span class="nav-text">3、优化物理块的分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、虚拟盘"><span class="nav-text">4、虚拟盘</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-七、文件管理"><span class="nav-text">7.    七、文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-文件管理概述"><span class="nav-text">7.1.     文件管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能"><span class="nav-text">7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-数据分类"><span class="nav-text">7.2.     数据分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-数据项"><span class="nav-text">7.2.1.     数据项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据项"><span class="nav-text">基本数据项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合数据项"><span class="nav-text">组合数据项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-记录"><span class="nav-text">7.2.2.     记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一组相关数据项的集合，由于描述一个对象在某方面的属性"><span class="nav-text">一组相关数据项的集合，由于描述一个对象在某方面的属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-文件"><span class="nav-text">7.2.3.     文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建者定义，具有文件名的一组相关元素的集合"><span class="nav-text">创建者定义，具有文件名的一组相关元素的集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件体（文件本身信息）-文件属性（文件存储和管理信息）"><span class="nav-text">文件体（文件本身信息）+文件属性（文件存储和管理信息）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件属性：类型-长度-物理位置-建立时间"><span class="nav-text">文件属性：类型&#x2F;长度&#x2F;物理位置&#x2F;建立时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-文件系统"><span class="nav-text">7.3.     文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-文件类型"><span class="nav-text">7.3.1.     文件类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、用途"><span class="nav-text">1、用途</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#系统文件"><span class="nav-text">系统文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用户文件"><span class="nav-text">用户文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#库文件"><span class="nav-text">库文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、数据形式"><span class="nav-text">2、数据形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源文件（ASCII-汉字）"><span class="nav-text">源文件（ASCII&#x2F;汉字）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目标文件（obj）"><span class="nav-text">目标文件（obj）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可执行文件（exe）"><span class="nav-text">可执行文件（exe）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、存取控制属性"><span class="nav-text">3、存取控制属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只执行文件"><span class="nav-text">只执行文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#只读文件"><span class="nav-text">只读文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读写文件"><span class="nav-text">读写文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、组织形式和处理方式"><span class="nav-text">4、组织形式和处理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#普通文件"><span class="nav-text">普通文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#目录文件"><span class="nav-text">目录文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特殊文件"><span class="nav-text">特殊文件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#各类I-O设备"><span class="nav-text">各类I&#x2F;O设备</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-文件系统层次结构"><span class="nav-text">7.3.2.     文件系统层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口"><span class="nav-text">从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象及其属性"><span class="nav-text">对象及其属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件-目录-磁盘存储空间"><span class="nav-text">文件&#x2F;目录&#x2F;磁盘存储空间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对对象操纵和管理的软件集合-核心）"><span class="nav-text">对对象操纵和管理的软件集合(核心）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#功能-6"><span class="nav-text">功能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、文件存储空间管理-1"><span class="nav-text">1、文件存储空间管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、文件目录管理"><span class="nav-text">2、文件目录管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、文件逻辑地址和物理地址的转换"><span class="nav-text">3、文件逻辑地址和物理地址的转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、文件读和写管理"><span class="nav-text">4、文件读和写管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5、文件共享和保护"><span class="nav-text">5、文件共享和保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统接口"><span class="nav-text">文件系统接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、命令接口-1"><span class="nav-text">1、命令接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、程序接口-1"><span class="nav-text">2、程序接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-文件操作"><span class="nav-text">7.3.3.     文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建create"><span class="nav-text">创建create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除delete"><span class="nav-text">删除delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打开open"><span class="nav-text">打开open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关闭close"><span class="nav-text">关闭close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写read-write"><span class="nav-text">读写read&#x2F;write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#截断：文件长度-0"><span class="nav-text">截断：文件长度&#x3D;0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置读写位置"><span class="nav-text">设置读写位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他（以系统调用方式提供）"><span class="nav-text">其他（以系统调用方式提供）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、文件属性相关"><span class="nav-text">1、文件属性相关</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、有关目录操作"><span class="nav-text">2、有关目录操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、文件共享"><span class="nav-text">3、文件共享</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-文件逻辑结构"><span class="nav-text">7.3.4.     文件逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#又称文件的组织，是指从用户观点出发观察到的文件组织形式"><span class="nav-text">又称文件的组织，是指从用户观点出发观察到的文件组织形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设计要求"><span class="nav-text">设计要求</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#访问性能"><span class="nav-text">访问性能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#便于检索，便于修改"><span class="nav-text">便于检索，便于修改</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存储性能"><span class="nav-text">存储性能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#转换方便，节省空间"><span class="nav-text">转换方便，节省空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型-1"><span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#是否有结构"><span class="nav-text">是否有结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#有结构文件"><span class="nav-text">有结构文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#无结构文件"><span class="nav-text">无结构文件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组织形式划分"><span class="nav-text">组织形式划分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#顺序文件"><span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#索引文件"><span class="nav-text">索引文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#索引顺序文件"><span class="nav-text">索引顺序文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ps：直接文件："><span class="nav-text">ps：直接文件：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ps：哈希文件"><span class="nav-text">ps：哈希文件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-文件物理结构"><span class="nav-text">7.3.5.     文件物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的存储结构，指文件在外存的组织形式"><span class="nav-text">文件的存储结构，指文件在外存的组织形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目的-2"><span class="nav-text">目的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、提高存储空间的利用率"><span class="nav-text">1、提高存储空间的利用率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、提高文件的访问速度"><span class="nav-text">2、提高文件的访问速度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分配方式"><span class="nav-text">分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、连续分配"><span class="nav-text">1、连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#每个文件分配一组相邻接的盘块"><span class="nav-text">每个文件分配一组相邻接的盘块</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#主要问题"><span class="nav-text">主要问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#优点-17"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点-13"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、链接分配"><span class="nav-text">2、链接分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#隐式分配"><span class="nav-text">隐式分配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#显式分配"><span class="nav-text">显式分配</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、索引分配"><span class="nav-text">3、索引分配</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#单级索引"><span class="nav-text">单级索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#多级索引"><span class="nav-text">多级索引</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#混合方式"><span class="nav-text">混合方式</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-目录管理"><span class="nav-text">7.4.     目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址"><span class="nav-text">7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-实现目标"><span class="nav-text">7.4.2.     实现目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按名存取"><span class="nav-text">按名存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速检索"><span class="nav-text">快速检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件共享"><span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件重名的解决"><span class="nav-text">文件重名的解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-文件控制块FCB"><span class="nav-text">7.4.3.     文件控制块FCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项"><span class="nav-text">文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含信息"><span class="nav-text">包含信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、基本信息类"><span class="nav-text">1、基本信息类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、存取控制信息类"><span class="nav-text">2、存取控制信息类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、使用信息类"><span class="nav-text">3、使用信息类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-索引结点"><span class="nav-text">7.4.4.     索引结点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引入"><span class="nav-text">引入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件名和文件描述信息分开存放，将FCB拆分为两部分"><span class="nav-text">文件名和文件描述信息分开存放，将FCB拆分为两部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、文件目录部分"><span class="nav-text">1、文件目录部分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#文件名-索引结点编号（指针）"><span class="nav-text">文件名+索引结点编号（指针）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、I结点"><span class="nav-text">2、I结点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#除文件名以外的数据结构"><span class="nav-text">除文件名以外的数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘索引节点"><span class="nav-text">磁盘索引节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node"><span class="nav-text">指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存索引结点"><span class="nav-text">内存索引结点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件打开后，磁盘上的I-node拷贝到内存，以便使用"><span class="nav-text">文件打开后，磁盘上的I-node拷贝到内存，以便使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-5-目录结构"><span class="nav-text">7.4.5.     目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、单级目录"><span class="nav-text">1、单级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、两级目录"><span class="nav-text">2、两级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、多级目录（树）"><span class="nav-text">3、多级目录（树）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、无环图目录"><span class="nav-text">4、无环图目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、通用图目录"><span class="nav-text">4、通用图目录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-文件存储空间管理"><span class="nav-text">7.5.     文件存储空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况"><span class="nav-text">7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-方式"><span class="nav-text">7.5.2.     方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、空闲表法"><span class="nav-text">1、空闲表法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#首次-下次适应，最佳-最坏"><span class="nav-text">首次&#x2F;下次适应，最佳&#x2F;最坏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连续分配（一般），首次适应（算法）"><span class="nav-text">连续分配（一般），首次适应（算法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#序号-第一空闲盘块号-空闲盘块数"><span class="nav-text">序号+第一空闲盘块号+空闲盘块数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、空闲链表法"><span class="nav-text">2、空闲链表法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#空闲簇有指向下一个空闲簇的指针"><span class="nav-text">空闲簇有指向下一个空闲簇的指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两种形式"><span class="nav-text">两种形式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#空闲簇链接"><span class="nav-text">空闲簇链接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#空闲区链接"><span class="nav-text">空闲区链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、位示图"><span class="nav-text">3、位示图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每一位表示一个簇，0和1表示空闲和占用"><span class="nav-text">每一位表示一个簇，0和1表示空闲和占用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、成组链接法"><span class="nav-text">4、成组链接法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#栈底放盘块数"><span class="nav-text">栈底放盘块数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈底上面一个存放一组空闲盘块"><span class="nav-text">栈底上面一个存放一组空闲盘块</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-文件共享"><span class="nav-text">7.6.     文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-1-1、硬链接"><span class="nav-text">7.6.1.     1、硬链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针"><span class="nav-text">文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-2-2、符号链接"><span class="nav-text">7.6.2.     2、符号链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-文件保护"><span class="nav-text">7.7.     文件保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-1-1、文件不受物理损坏-2、避免文件被非法访问"><span class="nav-text">7.7.1.     1、文件不受物理损坏&#x2F;2、避免文件被非法访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-2-常用方法"><span class="nav-text">7.7.2.     常用方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问"><span class="nav-text">根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACL方法的缺点"><span class="nav-text">ACL方法的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每个文件ACL过长，事先无法知道系统用户的列表"><span class="nav-text">每个文件ACL过长，事先无法知道系统用户的列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原来固定大小的文件目录条目，现在必须可变，空间管理复杂化"><span class="nav-text">原来固定大小的文件目录条目，现在必须可变，空间管理复杂化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精简ACL的方法"><span class="nav-text">精简ACL的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#每个文件三种类型用户"><span class="nav-text">每个文件三种类型用户</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#拥有者：创建文件的用户"><span class="nav-text">拥有者：创建文件的用户</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#组：可访问者"><span class="nav-text">组：可访问者</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他用户"><span class="nav-text">其他用户</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lexie_W</span>

  
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共99.1k字 |</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
  总访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>







        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
