<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Maven学习博客链接合集</title>
    <url>/2020/07/02/Maven%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="使用IntelliJ-IDEA-配置Maven（入门）"><a href="#使用IntelliJ-IDEA-配置Maven（入门）" class="headerlink" title="使用IntelliJ IDEA 配置Maven（入门）"></a>使用IntelliJ IDEA 配置Maven（入门）</h3><p><a href="https://blog.csdn.net/qq_32588349/article/details/51461182?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_32588349/article/details/51461182?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="idea-plugins红色波浪线报错"><a href="#idea-plugins红色波浪线报错" class="headerlink" title="idea plugins红色波浪线报错"></a>idea plugins红色波浪线报错</h3><p><a href="https://blog.csdn.net/m0_37735176/article/details/90695284?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/m0_37735176/article/details/90695284?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="Maven遇到插件下载不下来（Cannot-resolve-plugin-org-apache-maven-plugins-maven-clean-plugin-2-5）"><a href="#Maven遇到插件下载不下来（Cannot-resolve-plugin-org-apache-maven-plugins-maven-clean-plugin-2-5）" class="headerlink" title="Maven遇到插件下载不下来（Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5）"></a>Maven遇到插件下载不下来（Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5）</h3><p><a href="https://blog.csdn.net/weixin_39778417/article/details/103796452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39778417/article/details/103796452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="Maven使用详解，非常详细"><a href="#Maven使用详解，非常详细" class="headerlink" title="Maven使用详解，非常详细"></a>Maven使用详解，非常详细</h3><p>1、</p>
<p><a href="https://blog.csdn.net/quuqu/article/details/52458589" target="_blank" rel="noopener">https://blog.csdn.net/quuqu/article/details/52458589</a></p>
<p>2、</p>
<p><a href="https://blog.csdn.net/hcmony/article/details/56013655?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/hcmony/article/details/56013655?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase</a></p>
<h3 id="Maven创建工程步骤"><a href="#Maven创建工程步骤" class="headerlink" title="Maven创建工程步骤"></a>Maven创建工程步骤</h3><p>1、file——new——project</p>
<p>2、Maven——-Create from archetype——maven-archetype-webapp——next</p>
<p>3、Name+Location———next——Maven home diretory</p>
<p>4、<strong>+</strong>——–archetypeCatalog——internal</p>
]]></content>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/07/01/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><h3 id="搭建整合环境"><a href="#搭建整合环境" class="headerlink" title="搭建整合环境"></a>搭建整合环境</h3><p>原博客<a href="https://blog.csdn.net/qq_44543508/article/details/100192558" target="_blank" rel="noopener">https://blog.csdn.net/qq_44543508/article/details/100192558</a></p>
<h4 id="整合说明"><a href="#整合说明" class="headerlink" title="整合说明"></a>整合说明</h4><p>XML+注解</p>
<h4 id="整合的思路："><a href="#整合的思路：" class="headerlink" title="整合的思路："></a>整合的思路：</h4><p>1、搭建整合的环境</p>
<p>2、Spring的配置搭建完成</p>
<p>3、再使用Spring整合SpringMVC框架</p>
<p>4、之后使用Spring整合MyBatis框架</p>
<p>5、最后spring整合mybatis框架配置事务（Spring的声明式事务管理）</p>
<h4 id="创建数据库和表结构语句："><a href="#创建数据库和表结构语句：" class="headerlink" title="创建数据库和表结构语句："></a>创建数据库和表结构语句：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create database ssm;</span><br><span class="line">use ssm;</span><br><span class="line"><span class="function">create table <span class="title">account</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span> primary key auto_increment,</span></span></span><br><span class="line"><span class="function"><span class="params">name varchar(<span class="number">50</span>)</span>,</span></span><br><span class="line"><span class="function">money <span class="keyword">double</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建maven的工程"><a href="#创建maven的工程" class="headerlink" title="创建maven的工程"></a>创建maven的工程</h4><ol>
<li><p>创建Twossm父工程（打包方式选择pom，必须的）</p>
<p>不勾选模块，删除src,更改pom的<packaging>标签</p>
<p><font color="red"><strong><em>创建java jar、pom项目时创建maven-archetype-quickstart</em></strong></font></p>
<p><font color="red"><strong><em>创建java war项目时创建maven-archetype-webapp</em></strong></font></p>
</li>
<li><p>创建Twossm_web子模块（打包方式是war包）</p>
<p>父工程下new-&gt;module-&gt;选择webapp模块创建，更改pom的<packaging>标签</p>
</li>
<li><p>创建Twossm_service子模块（打包方式是jar包）</p>
<p>父工程下new-&gt;module-&gt;选择quickstart模块创建，更改pom的<packaging>标签</p>
</li>
<li><p>创建Twossm_dao子模块（打包方式是jar包）—-同上</p>
</li>
<li><p>创建Twossm_domain子模块（打包方式是jar包）</p>
<p><em>web依赖于service，service依赖于dao，dao依赖于domain</em></p>
</li>
<li><p>在Twossm_parent的pom.xml文件中引入坐标依赖<br>找到对应的&lt; properties &gt;标签，以及&lt; dependencies &gt;标签，复制粘贴即可<br>版本控制是在&lt; properties &gt;标签中控制，从坐标依赖中可以看出版本号：spring5X、MySQL5.1.44、mybatis3.4.5</p>
</li>
<li><p>部署Twossm_web的项目，只要把Twossm_web项目加入到tomcat服务器中即可</p>
<p>这一段后边都改了，直接创建一个工程就行，其他子模块改成包</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本控制--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--添加依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编写实体类：Twossm-domain项目"><a href="#编写实体类：Twossm-domain项目" class="headerlink" title="编写实体类：Twossm_domain项目"></a>编写实体类：Twossm_domain项目</h4><ol>
<li>首先介绍一些快捷键：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDEA查找接口的实现类： ctrl + alt +B </span><br><span class="line">IDEA快速实现接口： Alt + Shift + P （很常用，基本上一实现接口就得用）</span><br><span class="line">Get&#x2F;Set&#x2F;toString方法快捷键：Esc</span><br><span class="line">自动补全返回值类型的快捷键：Ctrl + Alt+ V</span><br><span class="line">快速生成语句快速生成Main()方法: psvm + 回车 （老铁，是不是更习惯main+Alt+&#x2F; ？）</span><br><span class="line">快速生成输出语句: sout + 回车 (其实我想说我也喜欢syso，Alt+&#x2F; )</span><br><span class="line">内容提示,代码补全键：Ctrl+Alt+空格</span><br><span class="line">格式化代码：Ctrl+Alt+L</span><br><span class="line">查找所有，你没看错是所有：Shift + Shift</span><br><span class="line">自由切换：Ctrl+Tab</span><br><span class="line">删除整行：Ctrl+X</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后编写数据表对应的实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写dao接口"><a href="#编写dao接口" class="headerlink" title="编写dao接口"></a>编写dao接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountdao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写service接口和实现类"><a href="#编写service接口和实现类" class="headerlink" title="编写service接口和实现类"></a>编写service接口和实现类</h4><p>例如：IAccountService 以及  AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有账户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存帐户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service业务层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service业务层：保存帐户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里整合环境就搭建好了，现在开始搭建Spring的配置</p>
<h2 id="Spring框架代码的编写"><a href="#Spring框架代码的编写" class="headerlink" title="Spring框架代码的编写"></a>Spring框架代码的编写</h2><h3 id="创建resources的资源文件目录管理XML配置文件"><a href="#创建resources的资源文件目录管理XML配置文件" class="headerlink" title="创建resources的资源文件目录管理XML配置文件"></a>创建resources的资源文件目录管理XML配置文件</h3><p>Mark Directory as—&gt;Resources Root</p>
<h3 id="编写applicationContext-xml的配置文件"><a href="#编写applicationContext-xml的配置文件" class="headerlink" title="编写applicationContext.xml的配置文件"></a>编写applicationContext.xml的配置文件</h3><p>resources—&gt;New—&gt;File—–&gt;applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gx"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>记得一起加个log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout, R</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pattern to output the caller's file name and line number.</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] (%F:%L) - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.R.File</span>=<span class="string">example.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R.MaxFileSize</span>=<span class="string">100KB</span></span><br><span class="line"><span class="comment"># Keep one backup file</span></span><br><span class="line"><span class="meta">log4j.appender.R.MaxBackupIndex</span>=<span class="string">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.R.layout.ConversionPattern</span>=<span class="string">%p %t %c - %m%n</span></span><br></pre></td></tr></table></figure>

<h3 id="在项目中编写测试方法，进行测试"><a href="#在项目中编写测试方法，进行测试" class="headerlink" title="在项目中编写测试方法，进行测试"></a>在项目中编写测试方法，进行测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        as.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC框架代码的编写"><a href="#SpringMVC框架代码的编写" class="headerlink" title="SpringMVC框架代码的编写"></a>SpringMVC框架代码的编写</h2><h3 id="在web-xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码"><a href="#在web-xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码" class="headerlink" title="在web.xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码"></a>在web.xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--加载springmvc.xml配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--启动服务器，创建该servlet--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--解决中文乱码的过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="resources文件夹下创建springmvc-xml的配置文件"><a href="#resources文件夹下创建springmvc-xml的配置文件" class="headerlink" title="resources文件夹下创建springmvc.xml的配置文件"></a>resources文件夹下创建springmvc.xml的配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描，只扫描Controller注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置的视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/css"</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/js/"</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启SpringMVC注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建jsp页面"><a href="#创建jsp页面" class="headerlink" title="创建jsp页面"></a>创建jsp页面</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href="account/findAll"&gt;测试SpringMVC查询&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写controller代码"><a href="#编写controller代码" class="headerlink" title="编写controller代码"></a>编写controller代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/account/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Controller表现层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;  <span class="comment">//在视图解析器中配置了前缀后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳转界面jsp"><a href="#跳转界面jsp" class="headerlink" title="跳转界面jsp"></a>跳转界面jsp</h3><p>WEB-INF—-&gt;pages—-&gt;list.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Bule</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">9</span>/<span class="number">2</span></span><br><span class="line">  Time: <span class="number">7</span>:<span class="number">32</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">            &lt;h2&gt;查询所有的账户&lt;/h2&gt;</span><br><span class="line">          </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="部署Tomcat进行测试"><a href="#部署Tomcat进行测试" class="headerlink" title="部署Tomcat进行测试"></a>部署Tomcat进行测试</h3><p>测试成功就说明搭建好了<del>~</del></p>
<h2 id="Spring整合SpringMVC的框架"><a href="#Spring整合SpringMVC的框架" class="headerlink" title="Spring整合SpringMVC的框架"></a>Spring整合SpringMVC的框架</h2><h3 id="Spring整合SpringMVC的框架原理分析"><a href="#Spring整合SpringMVC的框架原理分析" class="headerlink" title="Spring整合SpringMVC的框架原理分析"></a>Spring整合SpringMVC的框架原理分析</h3><p>整合成功的表现：</p>
<ol>
<li>在controller（SpringMVC）中能成功的调用service（Spring）对象中的方法。</li>
</ol>
<p>要想在controller中调用service方法，就要注入service到controller中来，有service对象才可以调用service方法，方法是这样没有错，但是有一个问题:</p>
<p>就是启动Tomcat之后试想一下，在web.xml中配置有前端控制器，web容器会帮我们加载springmvc.xml配置文件，在springmvc.xml配置文件中我们配置情况是只扫描controller，别的不扫，而spring.xml文件就从头到尾没有执行过，spring中的配置扫描自然也不会去扫描，就相当于没有将spring交到IOC容器当中去。</p>
<p>所以，现在的解决方案就是，在启动服务器时就加载spring配置文件,怎么实现呢？这时候监听器listener就派上用场了，具体实现如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190902171005382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="在web-xml中配置ContextLoaderListener监听器"><a href="#在web-xml中配置ContextLoaderListener监听器" class="headerlink" title="在web.xml中配置ContextLoaderListener监听器"></a>在web.xml中配置ContextLoaderListener监听器</h3><p>在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文件）。要想加载applicationContext.xml的配置文件有两种方法</p>
<p>第一种（不建议）：把applicationContext.xm配置文件配置到WEB-INF目录下</p>
<p>第二种（强烈建议）：在web.xml中配置加载路径(方便管理和维护)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="controller中注入service对象，调用service对象方法并测试"><a href="#controller中注入service对象，调用service对象方法并测试" class="headerlink" title="controller中注入service对象，调用service对象方法并测试"></a>controller中注入service对象，调用service对象方法并测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>   <span class="comment">//按类型注入</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/account/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Controller表现层：查询所有账户..."</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; list = accountService.findAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，总算是整合完了spring、springmvc，同学你还能看到这里，我也挺欣慰的哈哈，手动再给你点个赞，接下来编写MyBatis环境惹！</p>
<h2 id="MyBatis框架代码的编写"><a href="#MyBatis框架代码的编写" class="headerlink" title="MyBatis框架代码的编写"></a>MyBatis框架代码的编写</h2><p>一看到Mybatis，就要想到dao，没错，MyBatis环境搭建首先是dao，搭建mybatis，之前要编写mapper映射的配置文件，其实挺麻烦的，所以选择使用注解！</p>
<h3 id="在IAccountdao接口方法上添加注解，编写SQL语句"><a href="#在IAccountdao接口方法上添加注解，编写SQL语句" class="headerlink" title="在IAccountdao接口方法上添加注解，编写SQL语句"></a>在IAccountdao接口方法上添加注解，编写SQL语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>  <span class="comment">//此注解代表这是一个持久层，用法类似@controller、@service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountdao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into account (name,money) value(#&#123;name&#125;,#&#123;money&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建SqlMapConfig-xml的配置文件并编写"><a href="#创建SqlMapConfig-xml的配置文件并编写" class="headerlink" title="创建SqlMapConfig.xml的配置文件并编写"></a>创建SqlMapConfig.xml的配置文件并编写</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///ssm?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用的是注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper class="com.gx.dao.IAccountdao"/&gt; --&gt;</span> <span class="comment">&lt;!-- 该包下所有的dao接口都可以使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.gx.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190902181214119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="创建并编写Mybatis测试方法"><a href="#创建并编写Mybatis测试方法" class="headerlink" title="创建并编写Mybatis测试方法"></a>创建并编写Mybatis测试方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.dao.IAccountdao;</span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyBatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Account account =<span class="keyword">new</span> Account();</span><br><span class="line">        account.setName(<span class="string">"杜永蓝"</span>);</span><br><span class="line">        account.setMoney(<span class="number">200</span>d);</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        <span class="comment">// 创建SqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">// 获取到代理对象</span></span><br><span class="line">        IAccountdao dao = session.getMapper(IAccountdao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存</span></span><br><span class="line">        dao.saveAccount(account);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line"></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line"></span><br><span class="line">        IAccountdao dao = session.getMapper(IAccountdao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; list = dao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account: list ) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这Mybatis框架搭建完成；</p>
<h2 id="Spring整合MyBatis框架"><a href="#Spring整合MyBatis框架" class="headerlink" title="Spring整合MyBatis框架"></a>Spring整合MyBatis框架</h2><h3 id="Spring整合MyBatis的框架原理分析"><a href="#Spring整合MyBatis的框架原理分析" class="headerlink" title="Spring整合MyBatis的框架原理分析"></a>Spring整合MyBatis的框架原理分析</h3><p>Spring整合MyBatis框架之前，先想一想，怎样才算整合成功呢？</p>
<p>其实，这和之前的spring整合springMVC的套路差不多，其实就是，Service能成功调用dao对象，能够做查询操作或者新增数据能存进数据库。</p>
<p>现在spring已经是在IOC容器中了，dao是一个接口，可以通过程序帮这个接口生成代理对象，我们要是可以把这个代理对象也放进IOC容器，那么service就可以拿到这个对象，之后在service中做一个注入，service从而调用dao代理对象的方法，那么我们怎么去实现dao接口生成的代理对象放入IOC容器呢？其实很简单，只需要如下操作！</p>
<p><strong>整合目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中</strong></p>
<h3 id="在applicationContext-xml中配置数据库连接池"><a href="#在applicationContext-xml中配置数据库连接池" class="headerlink" title="在applicationContext.xml中配置数据库连接池"></a>在applicationContext.xml中配置数据库连接池</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring整合MyBatis框架--&gt;</span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql:///ssm?useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"user"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在applicationContext-xml中配置SqlSessionFactory工厂"><a href="#在applicationContext-xml中配置SqlSessionFactory工厂" class="headerlink" title="在applicationContext.xml中配置SqlSessionFactory工厂"></a>在applicationContext.xml中配置SqlSessionFactory工厂</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--配置SqlSessionFactory工厂--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"sqlSessonFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在applicationContext-xml中配置IAccountdao接口所在包"><a href="#在applicationContext-xml中配置IAccountdao接口所在包" class="headerlink" title="在applicationContext.xml中配置IAccountdao接口所在包"></a>在applicationContext.xml中配置IAccountdao接口所在包</h3><p>因为工厂有了，SqlSession也有了，那代理谁呢，所以我们要配置IAccountdao接口所在包，告诉SqlSession去代理接口所在包中的代理，从而存到IOC容器中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--配置IAccountdao接口所在包--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"mapperScanner"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.gx.dao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小结上面的三个配置"><a href="#小结上面的三个配置" class="headerlink" title="小结上面的三个配置"></a>小结上面的三个配置</h3><p>其实，上面的操作就是<strong>把mybatis中的配置（SqlMapConfig.xml）转移到spring中去，让它产生代理并存到IOC容器中</strong>！</p>
<h3 id="完善Service-Controller层代码，完善list-jsp页面"><a href="#完善Service-Controller层代码，完善list-jsp页面" class="headerlink" title="完善Service/Controller层代码，完善list.jsp页面"></a>完善Service/Controller层代码，完善list.jsp页面</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Bule</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">9</span>/<span class="number">2</span></span><br><span class="line">  Time: <span class="number">7</span>:<span class="number">32</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;查询所有的账户&lt;/h2&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"account"</span>&gt;</span><br><span class="line">    $&#123;account.name&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>界面跳转成功就说明ssm框架整合成功啦！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>快犒劳一下自己！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>最后一步！！！！！！！！！</p>
<h2 id="spring整合mybatis框架配置事务（Spring声明式事务管理）"><a href="#spring整合mybatis框架配置事务（Spring声明式事务管理）" class="headerlink" title="spring整合mybatis框架配置事务（Spring声明式事务管理）"></a>spring整合mybatis框架配置事务（Spring声明式事务管理）</h2><p>在整合spring、mybatis测试的时候（TestMybatis中），新增数据保存的时候会手动的提交过事务session.commit()，如果不写这一句，就会出现数据没提交的情况，因此为了完美的整合ssm，我们必须配置Spring的声明式事务管理！</p>
<h3 id="在applicationContext-xml中配置Spring框架声明式事务管理"><a href="#在applicationContext-xml中配置Spring框架声明式事务管理" class="headerlink" title="在applicationContext.xml中配置Spring框架声明式事务管理"></a>在applicationContext.xml中配置Spring框架声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring框架声明式事务管理--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置AOP增强--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.gx.service.Impl.*ServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="完善index-jsp页面"><a href="#完善index-jsp页面" class="headerlink" title="完善index.jsp页面"></a>完善index.jsp页面</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/save"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;&lt;br/&gt;</span><br><span class="line">    金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> /&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="完善Service层、Controller层代码"><a href="#完善Service层、Controller层代码" class="headerlink" title="完善Service层、Controller层代码"></a>完善Service层、Controller层代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Service业务层：保存帐户..."</span>);</span><br><span class="line">    iaccountdao.saveAccount(account);  <span class="comment">//调用service中的saveAccount(account)方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/account/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account, HttpServletRequest request, HttpServletResponse response)</span> throws IOException </span>&#123;</span><br><span class="line">    accountService.saveAccount(account);</span><br><span class="line">    response.sendRzedirect(request.getContextPath()+<span class="string">"/account/findAll"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p>完lalalalalala！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<h3 id="源码、源码、源码"><a href="#源码、源码、源码" class="headerlink" title="源码、源码、源码~"></a>源码、源码、源码~</h3><p>链接：<a href="https://pan.baidu.com/s/1rJ5zy1cMuiHYvFHz1wFuOg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rJ5zy1cMuiHYvFHz1wFuOg</a><br>提取码：yjx3 </p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/07/02/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC第一天"><a href="#SpringMVC第一天" class="headerlink" title="SpringMVC第一天"></a>SpringMVC第一天</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1三层架构和MVC"><a href="#1-1三层架构和MVC" class="headerlink" title="1.1三层架构和MVC"></a>1.1三层架构和MVC</h3><p>咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序</p>
<p>使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构</p>
<h4 id="1-1-1-三层架构"><a href="#1-1-1-三层架构" class="headerlink" title="1.1.1 三层架构"></a>1.1.1 三层架构</h4><p>表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型</p>
<p>业务层：处理公司具体的业务逻辑的</p>
<p>持久层：用来操作数据库的</p>
<h4 id="1-1-2-MVC模型"><a href="#1-1-2-MVC模型" class="headerlink" title="1.1.2 MVC模型"></a>1.1.2 MVC模型</h4><p>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。</p>
<p>Model：数据模型，JavaBean的类，用来进行数据封装。</p>
<p>View：指JSP、HTML用来展示数据给用户</p>
<p>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623144308989.png" alt="image-20200623144308989"></p>
<h3 id="1-2-SpringMVC的基本概念"><a href="#1-2-SpringMVC的基本概念" class="headerlink" title="1.2 SpringMVC的基本概念"></a>1.2 SpringMVC的基本概念</h3><h4 id="1-2-1-SpringMVC的概述"><a href="#1-2-1-SpringMVC的概述" class="headerlink" title="1.2.1 SpringMVC的概述"></a>1.2.1 SpringMVC的概述</h4><p>是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。</p>
<p>使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的<br>SpringMVC框架或集成其他MVC开发框架.</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-SpringMVC的入门程序步骤"><a href="#2-1-SpringMVC的入门程序步骤" class="headerlink" title="2.1 SpringMVC的入门程序步骤"></a>2.1 SpringMVC的入门程序步骤</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623145414511.png" alt="image-20200623145414511">.</p>
<h4 id="2-1-1环境搭建"><a href="#2-1-1环境搭建" class="headerlink" title="2.1.1环境搭建"></a>2.1.1环境搭建</h4><ol>
<li>创建webapp程序</li>
<li>加入键值对：archetypeCatalog——intenal</li>
<li>创建java和resource文件夹</li>
<li>复制pom.xml文件导入依赖</li>
<li>web.xml配置Servlet前端控制器</li>
<li>resource-&gt;new-&gt;xml配置文件-&gt;spring config（文件名springmvc-&gt;是spring框架的配置文件）</li>
</ol>
<h4 id="2-1-2项目服务器部署"><a href="#2-1-2项目服务器部署" class="headerlink" title="2.1.2项目服务器部署"></a>2.1.2项目服务器部署</h4><ol>
<li>tomcat配置server</li>
<li>Deployment-&gt;(+)-&gt;Artifact(exploded文件)-&gt;context路径配置（可以选择不配）-&gt;Apply</li>
</ol>
<h4 id="2-1-3程序编写"><a href="#2-1-3程序编写" class="headerlink" title="2.1.3程序编写"></a>2.1.3程序编写</h4><ol>
<li>index.jsp </li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href="hello"&gt;入门程序&lt;/a&gt;//超链接</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>控制器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类：<span class="meta">@Controller</span></span><br><span class="line">方法：<span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置web.xml和springmvc.xml</li>
</ol>
<h4 id="2-1-4流程图解"><a href="#2-1-4流程图解" class="headerlink" title="2.1.4流程图解"></a>2.1.4流程图解</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623162417585.png" alt="image-20200623162417585"></p>
<h3 id="2-2入门案例的分析执行流程"><a href="#2-2入门案例的分析执行流程" class="headerlink" title="2.2入门案例的分析执行流程"></a>2.2入门案例的分析执行流程</h3><h4 id="2-2-1入门案例的分析执行流程"><a href="#2-2-1入门案例的分析执行流程" class="headerlink" title="2.2.1入门案例的分析执行流程"></a>2.2.1入门案例的分析执行流程</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623163304595.png" alt="image-20200623163304595"></p>
<ol>
<li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件.</li>
<li>开启了注解扫描，那么HelloController对象就会被创建</li>
<li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法</li>
<li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件</li>
<li>Tomcat服务器渲染页面，做出响应</li>
<li>SpringMVC官方提供图形</li>
</ol>
<h4 id="2-2-2-入门案例中的组件分析"><a href="#2-2-2-入门案例中的组件分析" class="headerlink" title="2.2.2 入门案例中的组件分析"></a>2.2.2 入门案例中的组件分析</h4><ol>
<li>前端控制器（DispatcherServlet）</li>
<li>处理器映射器（HandlerMapping）</li>
<li>处理器（Handler）</li>
<li>处理器适配器（HandlAdapter）</li>
<li>视图解析器（View Resolver）</li>
<li>视图（View）</li>
</ol>
<h3 id="2-3-RequestMapping注解"><a href="#2-3-RequestMapping注解" class="headerlink" title="2.3 RequestMapping注解"></a>2.3 RequestMapping注解</h3><ol>
<li><p>RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系</p>
</li>
<li><p>RequestMapping注解可以作用在方法和类上</p>
</li>
</ol>
<ul>
<li>作用在类上：第一级的访问目录</li>
<li>作用在方法上：第二级的访问目录</li>
<li>细节：路径可以不编写 / 表示应用的根目录开始</li>
<li>细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 /</li>
</ul>
<ol start="3">
<li>RequestMapping的属性</li>
</ol>
<ul>
<li>path 指定请求路径的url</li>
<li>value value属性和path属性是一样的</li>
<li>mthod 指定该方法的请求方式</li>
<li>params 指定限制请求参数的条件</li>
<li>headers 发送的请求中必须包含的请求头</li>
</ul>
<h2 id="第三章：请求参数的绑定"><a href="#第三章：请求参数的绑定" class="headerlink" title="第三章：请求参数的绑定"></a>第三章：请求参数的绑定</h2><h3 id="3-1绑定说明"><a href="#3-1绑定说明" class="headerlink" title="3.1绑定说明"></a>3.1绑定说明</h3><h4 id="3-1-1-请求参数的绑定说明"><a href="#3-1-1-请求参数的绑定说明" class="headerlink" title="3.1.1 请求参数的绑定说明"></a>3.1.1 请求参数的绑定说明</h4><ol>
<li>绑定机制</li>
</ol>
<ul>
<li>表单提交的数据都是k=v格式的 username=haha&amp;password=123</li>
<li>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</li>
<li>要求：提交表单的name和参数的名称是相同的</li>
</ul>
<ol start="2">
<li>支持的数据类型</li>
</ol>
<ul>
<li>基本数据类型和字符串类型</li>
<li>实体类型（JavaBean）</li>
<li>集合数据类型（List、map集合等）</li>
</ul>
<h4 id="3-1-2-基本数据类型和字符串类型"><a href="#3-1-2-基本数据类型和字符串类型" class="headerlink" title="3.1,2 基本数据类型和字符串类型"></a>3.1,2 基本数据类型和字符串类型</h4><ol>
<li>提交表单的name和参数的名称是相同的</li>
<li>区分大小写</li>
</ol>
<h4 id="3-1-3-实体类型（JavaBean）"><a href="#3-1-3-实体类型（JavaBean）" class="headerlink" title="3.1.3 实体类型（JavaBean）"></a>3.1.3 实体类型（JavaBean）</h4><ol>
<li>提交表单的name和JavaBean中的属性名称需要一致</li>
<li>如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：<br>address.name</li>
</ol>
<h4 id="3-1-4-给集合属性数据封装"><a href="#3-1-4-给集合属性数据封装" class="headerlink" title="3.1.4 给集合属性数据封装"></a>3.1.4 给集合属性数据封装</h4><p>JSP页面编写方式：list[0].属性</p>
<h4 id="3-1-5-请求参数中文乱码的解决"><a href="#3-1-5-请求参数中文乱码的解决" class="headerlink" title="3.1.5 请求参数中文乱码的解决"></a>3.1.5 请求参数中文乱码的解决</h4><p>在web.xml中配置Spring提供的过滤器类</p>
<h3 id="3-2-特殊情况"><a href="#3-2-特殊情况" class="headerlink" title="3.2 特殊情况"></a>3.2 特殊情况</h3><p>3.2.1 自定义类型转换器</p>
<ol>
<li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p>
</li>
<li><p>如果想自定义数据类型转换，可以实现Converter的接口</p>
<ol>
<li>注册自定义类型转换器</li>
<li>在springmvc.xml配置文件中编写配置 </li>
</ol>
</li>
</ol>
<h2 id="第四章-注解"><a href="#第四章-注解" class="headerlink" title="第四章 注解"></a>第四章 注解</h2><h3 id="4-1-RequestParam注解"><a href="#4-1-RequestParam注解" class="headerlink" title="4.1 RequestParam注解"></a>4.1 RequestParam注解</h3><h4 id="4-1-1-作用"><a href="#4-1-1-作用" class="headerlink" title="4.1.1 作用"></a>4.1.1 作用</h4><p>把请求中的指定名称的参数传递给控制器中的形参赋值</p>
<h4 id="4-1-2-属性"><a href="#4-1-2-属性" class="headerlink" title="4.1.2 属性"></a>4.1.2 属性</h4><p>value：请求参数中的名称</p>
<p>required：请求参数中是否必须提供此参数，默认值是true，必须提供4.2 RequestBody注解</p>
<h3 id="4-2-RequestBody注解"><a href="#4-2-RequestBody注解" class="headerlink" title="4.2 RequestBody注解"></a>4.2 RequestBody注解</h3><h4 id="4-2-1-作用"><a href="#4-2-1-作用" class="headerlink" title="4.2.1 作用"></a>4.2.1 作用</h4><p>用于获取请求体的内容（注意：get方法不可以）</p>
<h4 id="4-2-2-属性"><a href="#4-2-2-属性" class="headerlink" title="4.2.2 属性"></a>4.2.2 属性</h4><h3 id="4-3-PathVaribale注解"><a href="#4-3-PathVaribale注解" class="headerlink" title="4.3 PathVaribale注解"></a>4.3 PathVaribale注解</h3><h4 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1 作用"></a>4.3.1 作用</h4><p> 用于绑定url中的占位符。例如：请求url中 /delete/<strong>{id}</strong>，这个{id}就是url占位符。 url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。 </p>
<h4 id="4-3-2-属性"><a href="#4-3-2-属性" class="headerlink" title="4.3.2 属性"></a>4.3.2 属性</h4><p> value：用于指定url中占位符名称。</p>
<p> required：是否必须提供占位符。</p>
<h4 id="4-3-3-REST风格URL"><a href="#4-3-3-REST风格URL" class="headerlink" title="4.3.3 REST风格URL"></a>4.3.3 REST风格URL</h4><ol>
<li><p>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</p>
</li>
<li><p>restful风格的URL优点：结构清晰\符合标准\易于理解\扩展方便</p>
</li>
<li><p>HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</strong></p>
</li>
<li><p>restful的示例： </p>
<table>
<thead>
<tr>
<th>/account/1 HTTP GET ：</th>
<th>得到 id = 1 的 account</th>
</tr>
</thead>
<tbody><tr>
<td>/account/1 HTTP DELETE：</td>
<td>删除 id = 1的 account</td>
</tr>
<tr>
<td>/account/1 HTTP PUT：</td>
<td>更新id = 1的 account</td>
</tr>
<tr>
<td>/account HTTP POST：</td>
<td>新增id = 1 account</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200625203159721.png" alt="image-20200625203159721"></p>
<h4 id="4-3-4-基于HiddentHttpMethodFilter的示例"><a href="#4-3-4-基于HiddentHttpMethodFilter的示例" class="headerlink" title="4.3.4 基于HiddentHttpMethodFilter的示例"></a>4.3.4 基于HiddentHttpMethodFilter的示例</h4><p><strong>作用：</strong> 由于浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与DELETE 请求。</p>
<p> <strong>使用方法：</strong> 第一步：在web.xml中配置该过滤器。 第二步：请求方式必须使用post请求。 第三步：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。</p>
<h3 id="4-4-RequestHeader注解"><a href="#4-4-RequestHeader注解" class="headerlink" title="4.4 RequestHeader注解"></a>4.4 RequestHeader注解</h3><h4 id="4-4-1-作用"><a href="#4-4-1-作用" class="headerlink" title="4.4.1 作用"></a>4.4.1 作用</h4><p>获取指定请求头的值</p>
<h4 id="4-4-2-属性"><a href="#4-4-2-属性" class="headerlink" title="4.4.2 属性"></a>4.4.2 属性</h4><p>value：请求头的名称</p>
<h3 id="4-5-CookieValue注解"><a href="#4-5-CookieValue注解" class="headerlink" title="4.5 CookieValue注解"></a>4.5 CookieValue注解</h3><h4 id="4-5-1-作用"><a href="#4-5-1-作用" class="headerlink" title="4.5.1 作用"></a>4.5.1 作用</h4><p>用于获取指定cookie的名称的值</p>
<h4 id="4-5-2-属性"><a href="#4-5-2-属性" class="headerlink" title="4.5.2 属性"></a>4.5.2 属性</h4><p>value：cookie的名称</p>
<h3 id="4-6-ModelAttribute注解"><a href="#4-6-ModelAttribute注解" class="headerlink" title="4.6 ModelAttribute注解"></a>4.6 ModelAttribute注解</h3><h4 id="4-6-1-作用"><a href="#4-6-1-作用" class="headerlink" title="4.6.1 作用"></a>4.6.1 作用</h4><p>出现在方法上：表示当前方法会在控制器方法执行前线执行。</p>
<p>出现在参数上：获取指定的数据给参数赋值。</p>
<h4 id="4-6-2-应用场景"><a href="#4-6-2-应用场景" class="headerlink" title="4.6.2 应用场景"></a>4.6.2 应用场景</h4><p>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据</p>
<h4 id="4-6-3-应用方式"><a href="#4-6-3-应用方式" class="headerlink" title="4.6.3 应用方式"></a>4.6.3 应用方式</h4><p>根据方法是否有返回值来确定两种方式，代码在笔记上</p>
<h3 id="4-7-SessionAttribute注解"><a href="#4-7-SessionAttribute注解" class="headerlink" title="4.7 SessionAttribute注解"></a>4.7 SessionAttribute注解</h3><h4 id="4-7-1作用"><a href="#4-7-1作用" class="headerlink" title="4.7.1作用"></a>4.7.1作用</h4><p>用于多次执行控制器方法间的参数共享(存入session域或者request中)</p>
<h4 id="4-7-2-属性"><a href="#4-7-2-属性" class="headerlink" title="4.7.2 属性"></a>4.7.2 属性</h4><p>value：指定存入属性的名称</p>
<h1 id="SpringMVC第二天"><a href="#SpringMVC第二天" class="headerlink" title="SpringMVC第二天"></a>SpringMVC第二天</h1><p>看随堂笔记吧</p>
<h2 id="异常抛出流程"><a href="#异常抛出流程" class="headerlink" title="异常抛出流程"></a>异常抛出流程</h2><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200626164325476.png" alt="image-20200626164325476"></p>
<h2 id="第四章：SpringMVC框架中的拦截器"><a href="#第四章：SpringMVC框架中的拦截器" class="headerlink" title="第四章：SpringMVC框架中的拦截器"></a>第四章：SpringMVC框架中的拦截器</h2><h2 id="4-1拦截器的概述"><a href="#4-1拦截器的概述" class="headerlink" title="4.1拦截器的概述"></a>4.1拦截器的概述</h2><ol>
<li><p>SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。</p>
</li>
<li><p>可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。</p>
</li>
<li><p>拦截器和过滤器的功能比较类似，有区别</p>
<p>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</p>
<p>拦截器是SpringMVC框架独有的。</p>
<p>过滤器配置了/*，可以拦截任何资源。</p>
<p>拦截器只会对控制器中的方法进行拦截。</p>
</li>
<li><p>拦截器也是AOP思想的一种实现方式</p>
</li>
<li><p>想要自定义拦截器，需要实现HandlerInterceptor接口。</p>
</li>
</ol>
<h2 id="4-2-HandlerInterceptor接口中的方法"><a href="#4-2-HandlerInterceptor接口中的方法" class="headerlink" title="4.2 HandlerInterceptor接口中的方法"></a>4.2 HandlerInterceptor接口中的方法</h2><ol>
<li>preHandle方法是controller方法执行前拦截的方法</li>
</ol>
<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>
<li>return false不放行，不会执行controller中的方法。</li>
</ul>
<ol start="2">
<li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。</li>
</ol>
<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>
</ul>
<ol start="3">
<li>postHandle方法是在JSP执行后执行</li>
</ol>
<ul>
<li>request或者response不能再跳转页面了</li>
</ul>
<h1 id="SpringMVC第三天"><a href="#SpringMVC第三天" class="headerlink" title="SpringMVC第三天"></a>SpringMVC第三天</h1><h2 id="第一章：搭建整合环境"><a href="#第一章：搭建整合环境" class="headerlink" title="第一章：搭建整合环境"></a>第一章：搭建整合环境</h2><ol>
<li>搭建整合环境</li>
<li>整合说明：SSM整合可以使用多种方式，咱们会选择XML + 注解的方式</li>
<li>整合的思路</li>
</ol>
<ul>
<li>先搭建整合的环境</li>
<li>先把Spring的配置搭建完成</li>
<li>再使用Spring整合SpringMVC框架</li>
<li>最后使用Spring整合MyBatis框架</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>TCP-IP</title>
    <url>/2020/07/02/TCP-IP/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>l 1-4：与因特网相关的机构IAB, IETF, IRTF, ISOC, InterNIC, ICANN, W3C的全称和主要职能是什么？</p>
<p>IAB: Internet Architecture Boar，因特网体系结构委员会。建立因特网标准，管理RFC文档的发布，建立因特网的策略性研究计划。</p>
<p>IETF：Internet Engineering Task Force，因特网工程任务组。负责因特网标准的制定。</p>
<p>IRTF：Internet Research Task Force，因特网研究任务组。负责与因特网发展相关的长远的理论研究。</p>
<p>ISOC：Internet Society，因特网协会。致力于确保全球因特网发展的有益性和开放性，负责管理所有与因特网相关的工作。</p>
<p>InterNIC：Internet Network Information Center，因特网网络信息中心。负责以.com、.org、.net和.edu等顶级域名的注册与管理。</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers，因特网名称与数字地址分配机构。负责IP地址的分配、协议标识符的指派、通用顶级域名以及国家和地区顶级域名系统的管理、根服务器的管理等。</p>
<p>W3C：World Wide Web Consortium，WWW协会。负责制定和颁布WWW有关的应用标准</p>
<p>l 1-5：RFC文档有哪几种可能的状态？各种状态的含义是什么？</p>
<p>RFC文档有8种状态，具体如下：</p>
<p>\1. 标准化轨迹的RFC</p>
<p>p 提案标准：需要进一步的试验证实其可行性。</p>
<p>p 草案标准：需要两个独立的、具有相互操作性的实例来验证其每一个方面。</p>
<p>p 因特网标准：同时赋予一个STD XXXX编号。</p>
<p>\2. 非标准化轨迹的RFC</p>
<p>p 实验性的RFC：反映一些研究成果。</p>
<p>p 信息性的RFC (同时赋予FYI XXXX编号) ：指南、手册、术语表等。</p>
<p>p 历史性的RFC：被新标准取代或者过时的RFC。</p>
<p>\3. 其他状态的RFC</p>
<p>p 最佳当前实现的RFC：同时赋予BCP XXXX编号。</p>
<p>p 未知性的RFC ：未被分类的文档，主要是因特网早期的RFC文档。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>l 2-2 协议分层有什么好处？</p>
<p>分层的优点：</p>
<p>p 有利于将复杂的问题分解成多个相对独立的简单问题，分而治之；越下面的层次越具体，越上面的层次越高级。上层调用下层功能；</p>
<p>p 新技术的引入，不会对所有层次产生影响；</p>
<p>p 网络互联时只需考虑底层某一个或几个异构的层次，而不是所有层次。</p>
<p>l 2-6 Wi-Fi和WiMAX的含义分别是什么？</p>
<p>WiMAX ：Worldwide Interoperability for Microwave Access</p>
<p>Wi-Fi：Wireless Fidelity，无线保真</p>
<p>l 2-7 简述OSI参考模型与TCP/IP模型的关系。</p>
<p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img"></p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>l 3-3 现有一个C类网络地址块199.5.6.0，需要支持至少7个子网，每个子网最多9台主机。请进行子网规划，给出各子网的地址、可以分配给主机的地址范围和子网广播地址。</p>
<p>题目要求至少7个子网，子网位m, 主机位n，m+n=8。2^m-2 &gt;= 7 因此m＞=4，又每个子网最多9台主机，则n选4</p>
<p>选m=4, n=4 </p>
<table>
<thead>
<tr>
<th>子网地址</th>
<th>开始地址</th>
<th>结束地址</th>
<th>广播地址</th>
</tr>
</thead>
<tbody><tr>
<td>199.5.6.16</td>
<td>199.5.6.17</td>
<td>199.5.6.30</td>
<td>199.5.6.31</td>
</tr>
<tr>
<td>199.5.6.32</td>
<td>199.5.6.33</td>
<td>199.5.6.46</td>
<td>199.5.6.47</td>
</tr>
<tr>
<td>199.5.6.48</td>
<td>199.5.6.49</td>
<td>199.5.6.62</td>
<td>199.5.6.63</td>
</tr>
<tr>
<td>199.5.6.64</td>
<td>199.5.6.65</td>
<td>199.5.6.78</td>
<td>199.5.6.79</td>
</tr>
<tr>
<td>199.5.6.80</td>
<td>199.5.6.81</td>
<td>199.5.6.94</td>
<td>199.5.6.95</td>
</tr>
<tr>
<td>199.5.6.96</td>
<td>199.5.6.97</td>
<td>199.5.6.110</td>
<td>199.5.6.111</td>
</tr>
<tr>
<td>199.5.6.112</td>
<td>199.5.6.113</td>
<td>199.5.6.126</td>
<td>199.5.6.127</td>
</tr>
</tbody></table>
<p>l 3-5 若IP地址为156.42.72.37，子网掩码为255.255.192.0，其子网地址是什么？</p>
<p>子网地址156.42.64.0</p>
<p>l 3-6 将以203.119.64.0开始的16个C类地址块构造一个超网，请给出该超网的超网地址和超网掩码。</p>
<p>超网地址203.199.64.0，超网掩码255.255.240.0</p>
<p>l 3-8 在下列地址块组中，哪个组可以构成超网？其超网掩码是什么？</p>
<p>   a. 199.87.136.0 199.87.137.0 199.87.138.0 199.87.139.0</p>
<p>   b. 199.87.130.0 199.87.131.0 199.87.132.0 199.87.133.0</p>
<p>   c. 199.87.16.0 199.87.17.0 199.87.18.0</p>
<p>   d. 199.87.64.0 199.87.68.0 199.87.72.0 199.87.76.0</p>
<p>a组可以 超网掩码：255.255.252.0</p>
<p>l 3-9 以斜线表示法（CIDR表示法）表示下列IP地址和掩码。</p>
<p>   a. IP地址：200.187.16.0，掩码：255.255.248.0</p>
<p>   b. IP地址：190.170.30.65，掩码：255.255.255.192</p>
<p>   c. IP地址：100.64.0.0，掩码：255.224.0.0</p>
<p>200.187.16.0/21</p>
<p>190.170.30.65/26</p>
<p>100.64.0.0/11</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>l 4-3 当ARP/RARP报文封装在以太网帧中进行发送时，为什么要添加PAD字段？</p>
<p>由于ARP和RARP报文较短（28个字节），后面必须增加18个字节的填充PAD，以达到以太网最小帧长度的要求。</p>
<p>l 4-6 简述目的主机为远程主机时的信息传输过程。</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>l 5-1 IP协议为什么不提供对IP数据报数据区的校验功能？IP协议为什么要对IP数据报首部进行校验？</p>
<p>IP不校验数据区，因为：</p>
<p>p IP数据来自高层协议，且在传输过程中一般不会变化，出于简单原则，IP对其不校验；</p>
<p>p 如需要，由高层（如传输层）端到端校验。</p>
<p>对IP数据报首部进行校验：</p>
<p>p IP首部属于网络层的控制信息，不应由其他层校验；</p>
<p>p 首部部分字段是不断变化的(例如TTL字段)，因此要由IP进行点到点的校验。</p>
<p>l 5-6 一个首部长度为20个字节、数据区长度为2000字节的IP数据报如何在MTU为820字节的网络中传输？</p>
<p>将IP数据报文分片成3块，在ip首部中设置好段标识符字段、DF字段、MF字段和段偏移字段。</p>
<p>数据长度分别为800字节，800字节，400字节</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>l 6-3 ICMP与IP协议是什么关系？</p>
<p>ICMP协议位于网络层，IP协议之上，所以ICMP报文使用IP数据报进行封装。ICMP是IP的补充，用于IP传输时的差错报告、拥塞控制、路径控制以及时间、掩码等信息的获取。 </p>
<p>l 6-4 在利用时间戳请求应答报文进行时钟同步时，主机A的初始时间戳为32530000，接收到主机B应答时的时间戳为32530246，主机B的接收时间戳和发送时间戳分别为32530100和32530130，主机A和主机B之间的时间差是多少？</p>
<p>往返时延=（32530246-32530000）- （32530130-32530100）=246-30=216</p>
<p>因此单程时延=216/2=108</p>
<p>AB之间的时间差=32530100-（32530000+108）= -8</p>
<p>因此B比A慢8毫秒，或者说A比B快8毫秒</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>l <strong>7-1.</strong> 直接传递和间接传递有什么不同？</p>
<p>直接传递：IP数据报在信宿网络中，直接传到信宿的过程</p>
<p>间接传递：IP数据报在非信宿网络中的传递过程</p>
<p>l <strong>7-2.</strong> 路由信息协议RIP和开放最短路优先协议OSPF有什么不同？</p>
<p>使用的基本算法不同，DV和LS……</p>
<p>l <strong>7-5.</strong> RIP、OSPF和BGP报文分别封装到什么协议中进行传送？</p>
<p>RIP协议使用UDP数据报分装</p>
<p>OSPF报文直接使用IP数据报封装</p>
<p>BGP报文使用TCP协议传输，因此用TCP协议分装</p>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>l 8-1 为什么常用的服务器的端口号都采用熟知端口号，而客户端一般采用临时端口号？</p>
<p>为了让客户机能够找到，服务器进程要先启动，并且必须公开IP地址，使用公认的传输层协议与熟知端口。</p>
<p>客户进程使用临时端口号，通信前向操作系统申请，通信后归还。</p>
<p>l 8-6 为了避免和消除拥塞，TCP采用了哪些策略来控制拥塞窗口？</p>
<p>包含慢启动，拥塞避免，拥塞解决等策略。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>l <strong>9-1</strong> 递归解析与反复解析有什么不同？</p>
<p>递归解析时，客户机请求所在区域的服务器解析，若不能给出结果，服务器将请求另一个服务器（通常是其父或子服务器）并等待响应。后续的服务器也是进行类似的处理。一直到找到能解析的服务器，然后原路返回解析结果。</p>
<p>反复解析时，客户机请求所在区域的域名服务器解析，若不能给出结果，则返回另一个服务器的IP地址，客户机再向第二个服务器发出解析请求。后续的服务器也是进行类似的处理，直到找到可以解析的服务器。</p>
<p>l <strong>9-3</strong> DNS是如何提高解析效率的？</p>
<p>为了提高DNS解析效率，通常DNS服务器的高速缓存中，存放最近解析过的本区域之外的信息及其授权服务器地址，下次可直接使用，无需重复进行麻烦的递归或反复解析。</p>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><p>l 10-1 简述BOOTP协议与RARP协议的异同。</p>
<p>BOOTP协议使计算机获得IP地址，所在网络的掩码，默认路由器的IP地址，默认DNS服务器的IP地址。</p>
<p>RARP使用链路层广播也能获取IP地址，但不能跨路由器。</p>
<p>l 10-5 DHCP/BOOTP中继代理的作用是什么？</p>
<p>中继代理运行于设备（一般是路由器）上的一个程序。客户机广播发送DHCP/BOOTP请求报文，由中继代理以单播方式转发给位于其它网络的服务器；服务器向中继代理单播返回应答，中继代理再单播给客户机。</p>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><p>l 11-2. 举例说明第2层组播地址(组播MAC地址)可以从IP组播地址中衍生实现。</p>
<p>例如：IP组播地址224.66.60.89 (11100000. 01000010. 00111100. 01011001) ，可得其以太网的物理组播地址为：00000001 00000000 01011110 01000010 00111100 01011001，也即其组播MAC地址为：01. 00. 5e. 42.3c.59</p>
<p>l 11-4. 比较组播路由协议的稀疏模式和密集模式。</p>
<p>密集模式用于较高带宽、组成员较为集中的网络，主要使用基于源的组播树；</p>
<p>稀疏模式用于网络带宽有限，组播组成员较少且分散的网络，主要使用组共享组播树。</p>
<p>##第二章</p>
<p>l 12-1 简述TFTP与FTP的不同点。</p>
<p>TFTP与FTP的不同点：</p>
<p>p FTP基于TCP，TFTP基于UDP；</p>
<p>p FTP需要客户机登录到服务器，TFTP不需要；</p>
<p>p TFTP功能简单，不允许读取服务器的文件目录等。</p>
<p>l 12-6 FTP中传输与控制为什么采用独立的连接？</p>
<p>FTP建立两条TCP连接：</p>
<p>p 一条传送控制信息(命令和响应) ；</p>
<p>p 另一条传送文件数据。</p>
<h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><p><strong>第**</strong>13<strong>**章</strong></p>
<p>l 13-3 试分析比较SMTP, MIME, IMAP, POP之间的主要区别。</p>
<p>SMTP只能传送ASCII码文本邮件，MIME可通过SMTP实现传送多种语言、多种数据类型(如文本、声音、图像、视频等)的邮件。</p>
<p>客户读取邮件使用邮件获取协议，POP3或IMAP。</p>
<p>l 13-5 简述电子邮件的工作过程。</p>
<h2 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h2><p>l 15-4 简述HTTP的3种通信方式。</p>
<p><strong>## 第**</strong>16<strong>**章</strong></p>
<p>l SNMP管理站与被管设备的通信方式？</p>
<p>l MIB和SMI分别是什么？</p>
<p>l SNMP的两种数据采集方法的特点是什么？</p>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理复习</title>
    <url>/2020/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="计算机组成原理复习"><a href="#计算机组成原理复习" class="headerlink" title="计算机组成原理复习"></a>计算机组成原理<strong>复</strong>习</h2><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>\1.   计算机系统的组成</p>
<p>软件系统</p>
<p>硬件系统：五大部件；总线</p>
<p>冯·诺依曼思想</p>
<p>现代计算机的结构</p>
<p>\2.   总线：概念、特点、分类、结构</p>
<p>\3.   计算机系统的层次结构</p>
<p>\4.   软件与硬件的关系</p>
<p>\5.   计算机系统在速度、容量、价格方面的主要性能指标（MIPS，Mflops，CPI，CPU时间）</p>
<p>\6.   计算机系统的分类</p>
<p><strong>重点：</strong></p>
<p>计算机系统的组成的概念；各部件的作用；冯·诺依曼思想；计算机系统的层次结构的概念；软件与硬件逻辑上等效的概念；计算机系统主要性能指标的计算。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、简答</p>
<h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><p>\1.   数制及数制转换</p>
<p>\2.   带符号数的表示：原码、反码、补码、移码以及各种码制与真值之间的转换</p>
<p>\3.   定点数的表示格式和数据表示范围</p>
<p>浮点数的表示格式和数据表示范围、浮点数的规格化数、原码／补码的规格化规则</p>
<p>\4.   IEEE 754标准浮点数的表示格式（32位单精度）、与真值之间的转换规则</p>
<p>\5.   非数值符号的表示：字符的ASCII码、字符串的存放方法；汉字编码的关系、汉字字库的容量计算</p>
<p>\6.   数据长度与存储方式；C语言简单数据类型的长度与存储</p>
<p>\7.   奇偶校验码、海明校验码、循环校验码的编码方法和校验方法；海明校验码码长的计算公式、各种校验码的检错和纠错能力；校验码的检错、纠错能力与码距的关系。</p>
<p><strong>重点：</strong></p>
<p>原码、反码、补码、移码以及各种码制与真值之间的转换方法；浮点数的规格化数、最大、最小数的表示；IEEE 754标准浮点数的表示规则、表示格式、IEEE 754标准浮点数与真值之间的转换；奇偶校验码、海明校验码（检一纠一、检二纠一）、循环校验码的编码方法；校验码的检错、纠错能力与码距的关系、海明校验码码长的计算公式、循环校验码的编码方法和校验方法、生成多项式的特点及对生成多项式的要求。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、计算★</p>
<h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><p>\1.   定点补码加减运算规则、溢出判断方法、定点补码加减运算的逻辑电路、算术逻辑运算部件的工作原理</p>
<p>\2.   一位原码/补码的乘法运算规则以及乘法运算的硬件逻辑电路的结构和工作原理</p>
<p>\3.   一位原码/补码不恢复余数除法运算规则、布斯除法运算规则以及除法运算的硬件逻辑电路的结构和工作原理</p>
<p>\4.   浮点四则运算的方法和步骤</p>
<p>加减运算：求阶差、对阶、尾数加减、结果规格化、尾数的舍入规则</p>
<p>乘除运算：阶码加减、尾数乘除、结果规格化、尾数的舍入规则</p>
<p>\5.    逻辑运算、各类移位的移位规则</p>
<p>\6.    AM2901A（4位ALU）芯片的功能及应用</p>
<p><strong>重点：</strong></p>
<p>定点补码加减运算、溢出判断方法；一位原码、补码的乘法运算及硬件逻辑电路的结构；一位布斯除法的运算规则及除法运算的硬件逻辑电路；浮点四则运算的方法和步骤；算术、逻辑、循环移位的移位方法。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、计算★（结合定点加减乘除算法，进行浮点四则运算）</p>
<h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><p>\1.    存储器的基本组成：存储体、读写控制、地址寄存及译码电路、数据寄存器，</p>
<p>\2.    存储系统的层次结构，程序局部性原理</p>
<p>\3.    主存与CPU之间数据传送的控制方式：同步控制、异步控制</p>
<p>\4.    主存的主要性能指标：容量、速度（存取时间TA、存取周期TM、带宽的计算方法）、价格</p>
<p>\5.    半导体存储器的存储原理</p>
<p>SRAM、DRAM的存储原理；DRAM的刷新方式、如何计算DRAM的刷新周期</p>
<p>\6.    存储器与CPU的连接：芯片数的计算、地址、数据、控制线的连接、片选信号的产生、地址范围的确定（字扩展、位扩展）；当需要多种字长访存时的各种地址和片选信号的实现，数据的整数边界存储问题。</p>
<p>\7.    Cache的工作原理：Cache的命中率的计算，Cache－主存系统的平均访问时间的计算， </p>
<p>\8.    主存与Cache之间的三种地址映射方式的实现原理和特点； Cache容量的计算（数据Cache和标识Cache的容量计算）；Cache－主存系统的平均访问时间的计算；Cache命中率的计算。</p>
<p>\9.    辅助存储器</p>
<p>磁表面存储器的存储原理、各种记录方式的特点、各种记录方式的评价标准（自同步能力、编码效率）</p>
<p>磁盘的常用技术指标：容量、平均存取时间、数据传输率的计算</p>
<p>\10.  存储体系中单体多字并行存储器、多体交叉存储器的概念</p>
<p>多端口存储器、单体多字存储系统、多体交叉存储系统</p>
<p><strong>重点：</strong></p>
<p>存储器的基本组成；DRAM的刷新；主存的主要性能指标的计算；存储器与CPU的连接及整数边界存储；Cache容量的计算；三种地址映射方式下主存块与Cache块的对应关系；多体交叉存储器带宽的计算。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算、设计★（存储器与CPU的连接，多种字长访存时的各种地址和片选信号的实现）</p>
<h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><p>1． 指令的格式、指令中地址的格式、操作码的编码方式</p>
<p>根据操作码和地址码计算指令的条数</p>
<p>2． 寻址方式</p>
<p>各种寻址方式中有效地址的计算方法</p>
<p>3． 指令类型</p>
<p>完备的指令系统应具有的基本指令类型，各种指令的实现过程。</p>
<p>4． CISC和RISC系统的设计风格的特点</p>
<p>5． MIPS系统指令的三种格式及特点</p>
<p><strong>重点：</strong></p>
<p>指令格式；寻址方式；各种指令的实现过程；CISC和RISC系统的设计风格的特点。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、设计★（指令格式设计；寻址方式分析；指令功能实现）</p>
<h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><p>1． 控制器的功能</p>
<p>2． 指令的执行步骤</p>
<p>3． 控制器组成部件：PC、IR、ID、操作信号形成部件等</p>
<p>4． 控制器的组成方式：组合逻辑方式、微程序方式</p>
<p>5． 控制器的控制方式：同步控制、异步控制、联合控制</p>
<p>控制器的时序：指令周期、机器周期、节拍、脉冲</p>
<p>6． CPU的结构、CPU中的基本寄存器</p>
<p>7． 数据通路及指令流程分析</p>
<p>根据指令功能和CPU的数据通路结构写出指令流程、控制信号序列及一个指令周期的的访存次数</p>
<p>8． 组合逻辑控制器的组成方式</p>
<p>9． 微程序控制器</p>
<p>微程序控制基本概念：微命令、微操作、微指令、微程序、微周期、控制存储器</p>
<p>微程序控制器的组成方式</p>
<p>微指令的编译方式（微指令格式的设计方法）：直接控制法、最短编码法、字段直接编码法</p>
<p>微程序的顺序控制方式：初始微地址的形成方式；后继微地址的形成方式：增量方式、断定方式</p>
<p>10．  指令的执行方式：顺序方式、重叠方式、流水方式</p>
<p>11．  流水线的分类：操作部件级、指令级和处理机级；单功能流水线和多功能流水线；静态流水线和动态流水线；线性流水线和非线性流水线</p>
<p>12．  线性流水线的性能：流水线时空图，线性流水线的吞吐率、效率和加速比的计算。</p>
<p>13．  线性流水线的三种相关及处理。</p>
<p>14．  MIPS系统的处理器：数据通路及多选器的作用，常用MIPS指令流程分析（指令流程、微控制信号序列等），ALU指令、Load/Store指令、分支指令特点及五个阶段的操作，流水线处理等</p>
<p><strong>重点：</strong></p>
<p>控制器组成及组成方式；CPU中各寄存器的作用；指令流程分析；程序功能分析；微指令的编译方式；微地址的形成方式；指令的执行方式；流水线的分类；线性流水线的性能计算、流水线的三种相关问题及分析。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、设计★（指令流程及程序功能分析与实现；微指令格式设计；微程序的实现；线性流水线的性能分析）</p>
<h4 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h4><p>\1.   总线的分类</p>
<p>\2.   总线的性能：带宽、宽度、时钟频率、负载能力</p>
<p>\3.   总线上的设备分类：总线主设备和总线从设备；总线源设备和总线目的设备；</p>
<p>\4.   总线仲裁的方法：集中仲裁和分布仲裁；并行仲裁和串行仲裁；集中式总线控制器的仲裁方式</p>
<p>\5.   总线的数据传输类型</p>
<p>\6.   PCI和USB总线的基本知识。</p>
<p><strong>重点：</strong></p>
<p>总线上的设备分类；总线仲裁的方法；总线带宽的计算；PCI和USB总线的基本知识。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算。</p>
<h4 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h4><p>\1.    主机对外设控制的四个层次</p>
<p>用户界面、驱动程序、控制程序、I/O操作</p>
<p>\2.    输入设备—键盘</p>
<p>键盘的字符键和控制功能键、软件扫描键盘原理</p>
<p>\3.    输出设备—显示器</p>
<p>显示缓存–VRAM、色彩数量</p>
<h4 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h4><p>1． 主机与外设的连接方式</p>
<p>2． 接口的功能、组成、分类</p>
<p>3． I/O的寻址方式</p>
<p>4． I/O信息的传送方式</p>
<p>5． 中断的功能和工作过程</p>
<p>中断请求、中断响应的条件，中断屏蔽、中断禁止、中断判优的条件，中断响应过程，向量中断的实现过程，中断嵌套的原则及处理过程</p>
<p>6． 中断对流水线的影响及处理</p>
<p>7． MIPS系统的中断流水处理方法</p>
<p>8． DMA的功能和工作过程</p>
<p>DMAC的组成</p>
<p>DMA传送方式：CPU暂停方式、周期挪用方式、交替访存方式</p>
<p>DMA的接口类型</p>
<p>DMA控制方式下的数据传送过程：DMA预处理、数据交换操作、DMA后处理</p>
<p>DMA与中断的比较</p>
<p>9． I/O通道控制方式的基本概念</p>
<p>10．      通道的类型：字节多路通道、选择通道、数组多路通道</p>
<p>11．  I/O通道的工作原理</p>
<p><strong>重点：</strong></p>
<p>接口的功能；中断的功能和工作过程；向量中断的实现过程；DMA的功能和工作过程。中断、DMA方式下数据传输的特点及性能计算；通道的类型。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算、设计★（中断及DMA的功能和实现）</p>
<p>主要参考资料</p>
<p>\1. 《计算机组成原理》（修订版，2016）—教材</p>
<p>\2. 《计算机组成与设计 硬件/软件接口》（原书第5版， MIPS系统） —pdf文件</p>
<p>​      （第2章、第4章）</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/01/hello-world/</url>
    <content><![CDATA[<p><strong>Welcome to Lexie’s World!!!</strong></p>
<a id="more"></a>]]></content>
      <categories>
        <category>主页</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式大作业</title>
    <url>/2020/06/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>某遥控器提供了一些按键，使用户可以自定义按键功能，如功能键FunctionButton可用于调出菜单（ShowMenu），也可用于打开帮助界面（DisplayHelp），也可用于打开机顶盒（OpenSTB）。用户可以通过修改配置文件来改变按键的用途。</p>
<p>请使用设计模式来设计该系统，画出类图，并在图中标出类的关键方法和属性，使得按键类与功能类之间解耦，相同的按键可以对应不同的功能。（15’)</p>
<h4 id="答：命令模式类图："><a href="#答：命令模式类图：" class="headerlink" title="答：命令模式类图："></a>答：命令模式类图：</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619211724978.png" alt="image-20200619211724978"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>现需要开发一个地震监测报警系统，如果接收到相关监测机构发来的预警数据，系统将作出反应，将信号传递给响应设备，如广播自动播放报警信息、逃生指示灯亮起、安全门锁打开、电梯自动停用等，每一种响应设备的行为由专门的程序来控制。</p>
<p>为支持将来引入新类型的响应设备，请采用设计模式来设计。画出类图，并在图中标出类的关键方法和属性。(15’)</p>
<h4 id="答：观察者模式类图："><a href="#答：观察者模式类图：" class="headerlink" title="答：观察者模式类图："></a>答：观察者模式类图：</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200619205140185.png" alt="image-20200619205140185"></p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>苹果与小米的手机都有短信（SendMessage）和通话（Call）的功能。有三种功能模块：蓝牙（Bluetooth）、GPS定位（GPS）与摄像头（Camera），可以任意的安装在手机上。蓝牙模块会给手机增加连接（Connect）功能；GPS给手机增加方位（Location）属性；摄像头可增加带视频的通话功能（CallWithVideo）。</p>
<p>请选择合适的设计模式解决该问题，画出类图，并在图中标出类的关键方法和属性。（15’）</p>
<h4 id="答：装饰者模式类图："><a href="#答：装饰者模式类图：" class="headerlink" title="答：装饰者模式类图："></a>答：装饰者模式类图：</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620210800044.png" alt="image-20200620210800044"></p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>在面向对象编程中往往提倡尽量不使用case语句和if语句等条件语句。有哪几种模式可以避免使用case等条件语句？选择其中一种设计模式举例说明，写出使用模式之前和使用模式之后的代码实现，并解释它是如何避免的。(20’)</p>
<h4 id="答："><a href="#答：" class="headerlink" title="答："></a><strong>答：</strong></h4><p>（1）策略模式<strong>、</strong>工厂模式、状态模式、命令模式</p>
<p>（2）举例说明&lt;策略模式&gt;</p>
<p>a.使用模式之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个贩卖各类书籍的电子商务网站的购物车（Shopping Cart）系统</span></span><br><span class="line"><span class="comment">对所有的教材类图书实行每本1元的折扣</span></span><br><span class="line"><span class="comment">对连环画类图书提供每本7%的促销折扣</span></span><br><span class="line"><span class="comment">对非教材类的计算机图书有3%的折扣</span></span><br><span class="line"><span class="comment">对其余的图书没有折扣*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Book text = <span class="keyword">new</span> Book();</span><br><span class="line">        text.setBookName(<span class="string">"TextBook"</span>);</span><br><span class="line">        text.setPrice(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">double</span> currentPrice=text.performDiscount();</span><br><span class="line">        System.out.println(currentPrice);</span><br><span class="line"></span><br><span class="line">        Book comic = <span class="keyword">new</span> Book();</span><br><span class="line">        comic.setBookName(<span class="string">"ComicBook"</span>);</span><br><span class="line">        comic.setPrice(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">double</span> currentPrice1=comic.performDiscount();</span><br><span class="line">        System.out.println(currentPrice1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>  price;</span><br><span class="line">        String bookName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setBookName</span><span class="params">(String bookName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">performDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(bookName.equalsIgnoreCase(<span class="string">"TextBook"</span>))&#123;</span><br><span class="line">                <span class="comment">//ComicBook ComputerBook OtherBook</span></span><br><span class="line">                <span class="keyword">this</span>.price=price-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bookName.equalsIgnoreCase((<span class="string">"Comicbook"</span>)))&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price*(<span class="number">1</span>-<span class="number">0.07</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bookName.equalsIgnoreCase((<span class="string">"ComputerBook"</span>)))&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price*(<span class="number">1</span>-<span class="number">0.03</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.使用模式之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComputerBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a ComputerBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ComicBook ComputerBook OtherBook</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComicBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComicBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a ComicBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Textbook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Textbook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a Textbook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OtherBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a OtherBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>  price;</span><br><span class="line">        Discount  discount;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">performDiscount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discount.calculate(<span class="keyword">this</span>.price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setDiscount</span><span class="params">(Discount discount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discount = discount;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount1</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price * (<span class="number">1</span>-<span class="number">0.03</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount2</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price * (<span class="number">1</span> - <span class="number">0.07</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount3</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount4</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        Book  mt = <span class="keyword">new</span>  Textbook();</span><br><span class="line">        mt.setPrice(<span class="number">50</span>);</span><br><span class="line">        currentPrice=mt.performDiscount();</span><br><span class="line">        system.out.println(“折后价：” + currentPrice);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.解释：</p>
<p>在使用策略模式之前，我在Book类里直接计算不同的书籍折扣后的价格，在计算过程中Book类为了分辨是哪种书籍而产生了很多的if-else语句。</p>
<p>使用策略模式之后，我把计算折扣的算法部分取出并“封装”起来，定义了折扣的算法族，让它们之间可以互相替换，让算法的变化独立于使用算法的客户，好让其他部分不会受到影响。Book类只需要根据相应的书籍对象要求计算折扣，不再需要理会计算的具体过程，实际计算折扣由具体的Discount类来实现，这就除去了原先Book类的if-else语句，并使代码变化引起的不经意后果变少，系统变得更有弹性。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>选一个你曾经做过的大作业，用一种或多种设计模式对其进行重新设计。首先，描述问题以及你原本的解决方案。然后，论述选择哪（几）个设计模式，为什么选择它（们）。最后，给出重设计后的解决方案。（解决方案可以画类图并写部分关键代码，如有必要，可加文字解释）（35’）</p>
<h4 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h4><p><strong>（1)</strong></p>
<h5 id="大作业题目介绍："><a href="#大作业题目介绍：" class="headerlink" title="大作业题目介绍："></a><strong>大作业题目介绍：</strong></h5><p>机票订购管理系统：主要实现用户信息维护、机票订购、航班查询、退票、改签及后台对用户信息、机票、航班、客机进行相关管理的功能。成员分为系统管理员和普通用户两种用户角色，系统管理员授予普通用户相应权限，用户根据需求自己订购机票。</p>
<p><strong>（2）</strong>在系统设计中，我主要遇到了2个问题，分别使用迭代器模式+工厂模式以及状态模式重构</p>
<h5 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a><strong>问题1</strong>：</h5><p>在机票订购管理系统中，管理员经常需要查询机票信息，检查是否有余票或增加当前起飞飞机的机票退票信息等，在对客户表进行增删查改时也经常需要进行遍历操作；用户自己在订购机票时也要查询机票信息，这样就会遇到很多次遍历的代码，需要我把这些代码汇集起来多次使用。</p>
<h5 id="原本的解决方案1："><a href="#原本的解决方案1：" class="headerlink" title="原本的解决方案1："></a>原本的解决方案1：</h5><p>为了复用遍历的代码，减少冗余，我设计了一个抽象的数据集合DatatList，把存储机票和用户等数据的类作为其子类：</p>
<p>DatatList类结构如图：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620212457778.png" alt="image-20200620212457778"></p>
<p>DataList原先关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> locate1; <span class="comment">//正向遍历的位置  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> locate2; <span class="comment">//逆向遍历的位置  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataList</span><span class="params">(List objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIt</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIt</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(locate1 &lt; list.size()) &#123;</span><br><span class="line">            locate1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (locate1 == list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locate2 &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            locate2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (locate2 == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(locate1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(locate2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述类图和DataList代码中可以看出这个类的职责过重，它既负责遍历数据,又负责存储和管理数据。这种庞大的聚合类也将给测试和维护增加难度。</p>
<h5 id="重设计方案1："><a href="#重设计方案1：" class="headerlink" title="重设计方案1："></a><strong>重设计方案1：</strong></h5><p>（1）选择迭代器模式和工厂模式：</p>
<p>（2）选择原因：</p>
<p>我使用聚合对象来存储各个数据，聚合对象拥有两个职责：一是存储数据；二是遍历数据。如果我将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，就可以实现数据存储和数据遍历分离。所以，很明显迭代器模式可以解决问题一。</p>
<p>同时，因为在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式，这样的话，如果我之后需要增加一个新的具体聚合类，比如实现客户数据集合类相应的操纵，我就只用增加一个新的聚合子类和一个新的具体迭代器类即可，不用去修改原来已经设计好的类。</p>
<p>其模式结构如图所示：<br><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620214554880.png" alt="image-20200620214554880"></p>
<p>部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//移至下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span></span>; <span class="comment">//判断是否为最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span></span>; <span class="comment">//移至上一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span></span>; <span class="comment">//判断是否为第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNextItem</span><span class="params">()</span></span>; <span class="comment">//获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPreviousItem</span><span class="params">()</span></span>; <span class="comment">//获取上一个元素</span></span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象聚合类  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AObjectList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AObjectList</span><span class="params">(List objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objects;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">    <span class="comment">//声明创建迭代器对象的抽象工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//机票迭代器：具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketIterator</span> <span class="keyword">implements</span> <span class="title">AIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketList ticketList;</span><br><span class="line">    <span class="keyword">private</span> List tickets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor1; <span class="comment">//定义一个游标，用于记录正向遍历的位置  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor2; <span class="comment">//定义一个游标，用于记录逆向遍历的位置  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketIterator</span><span class="params">(TicketList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ticketList = list;</span><br><span class="line">        <span class="keyword">this</span>.tickets = list.getObjects(); <span class="comment">//获取集合对象  </span></span><br><span class="line">        cursor1 = <span class="number">0</span>; <span class="comment">//设置正向遍历游标的初始值  </span></span><br><span class="line">        cursor2 = products.size() -<span class="number">1</span>; <span class="comment">//设置逆向遍历游标的初始值  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...实现抽象迭代器的抽象方法</span></span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//机票信息数据类：具体聚合类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketList</span> <span class="keyword">extends</span> <span class="title">AObjectList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketList</span><span class="params">(List tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tickets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现创建迭代器对象的具体工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TicketIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h5><p>在我的机票订购管理系统中，机票（Ticket)是系统的一个核心类，机票存在三种状态，且在不同状态下机票存在不同的行为</p>
<p>(1) 如果机票中余量大于等于0，为正常状态(RegularState)，此时用户既可以订票也可以退票；</p>
<p> (2) 如果机票中余量小于0，为SoldOutState售罄状态，但之后可能仍有票卖出，此时用户可以选择排队买票（等待），也可以退票。</p>
<p> (3) 如果账户中余量=-100，那么机票状态为锁定限制状态LimitiedState，此时用户只能退票，排队已经不允许了。这三种状态的转换需要一个专门的类来实现</p>
<h5 id="原本的解决方案2："><a href="#原本的解决方案2：" class="headerlink" title="原本的解决方案2："></a>原本的解决方案2：</h5><p>RegularState表示正常状态，SoldOutState表示售罄状态，LimitiedState表示受限状态，在这三种状态下账户对象拥有不同的行为，方法buy()订票，return()退票，queue()排队，stateCheck()用于在每一次操作后根据机票余量来判断是否要进行状态转换并实现状态转换。为了实现不同状态下对象的各种行为以及对象状态之间的相互转换，我设计了一个账户类Ticket</p>
<p>Ticket类结构如图：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620223542510.png" alt="image-20200620223542510"></p>
<p>Ticket原先关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state; <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rest; <span class="comment">//余量</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退票操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取票操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state.equalsIgnoreCase(<span class="string">"ApproveState"</span>)) &#123;</span><br><span class="line">            stateCheck();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state.equalsIgnoreCase(<span class="string">"SoldOutState "</span>))&#123;</span><br><span class="line">            queue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//取款受限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态检查和转换操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="string">"ApproveState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest &gt; -<span class="number">100</span> &amp;&amp; rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="string">"SoldOutState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest == -<span class="number">100</span>) &#123;</span><br><span class="line">            state = <span class="string">"LimitState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest &lt; -<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">//操作受限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重设计方案2："><a href="#重设计方案2：" class="headerlink" title="重设计方案2："></a>重设计方案2：</h5><p>（1）问题二选择状态模式：</p>
<p>（2）选择原因：</p>
<p>上述代码问题很多，首先几乎每个方法中都包含状态判断语句，导致代码非常冗余；系统扩展性差，如果我要增加一种新的状态，比如飞机遇见预先检查出故障而导致的机票冻结状态，将要改大量代码，会很麻烦；最后stateCheck()方法包含大量的if…else if…else…语句用于进行状态转换，会导致后期代码测试难度大。</p>
<p>在状态模式中，我们将对象在每一个状态下的行为和状态转移语句封装在一个个状态类中，通过这些状态类来分散冗长的条件转移语句，让系统具有更好的灵活性和可扩展性。如果之后增加状态，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。所以很明显，使用状态模式会可以帮我彻底解决问题二。</p>
<p>其模式结构如图所示：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200620232340828.png" alt="image-20200620232340828"></p>
<p>部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//银行机票：环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketState state; <span class="comment">//维持一个对抽象状态对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> String user; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rest = <span class="number">0</span>; <span class="comment">//机票余量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ticket</span><span class="params">(String user,<span class="keyword">double</span> init)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> RegularState(<span class="keyword">this</span>); <span class="comment">//设置初始状态</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"机票初始数量为"</span> + init);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRest</span><span class="params">(<span class="keyword">double</span> rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"机票数量"</span> + amount);</span><br><span class="line">        state.<span class="keyword">return</span>(amount); <span class="comment">//调用状态对象的return()方法</span></span><br><span class="line">        System.out.println(<span class="string">"现在余量为"</span>+ <span class="keyword">this</span>.rest);</span><br><span class="line">        System.out.println(<span class="string">"现在机票状态为"</span>+ <span class="keyword">this</span>.state.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"取款"</span> + amount);</span><br><span class="line">        state.buy(amount); <span class="comment">//调用状态对象的buy()方法</span></span><br><span class="line">        System.out.println(<span class="string">"现在余量为"</span>+ <span class="keyword">this</span>.rest);</span><br><span class="line">        System.out.println(<span class="string">"现在机票状态为"</span>+ <span class="keyword">this</span>. state.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Ticket acc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">computeInterest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//售罄状态:具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldOutState</span> <span class="keyword">extends</span> <span class="title">TicketState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() + amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() - amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.getRest() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> RegularState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (acc.getRest() == -<span class="number">100</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> LimitiedState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (acc.getRest() &lt; -<span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"操作受限！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正常状态：具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularState</span> <span class="keyword">extends</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegularState</span><span class="params">(Ticket acc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegularState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() - amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//受限状态：具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LimitiedState</span> <span class="keyword">extends</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitiedState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"受限，买票失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(acc.getRest() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> RegularState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(acc.getRest() &gt; -<span class="number">100</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/07/02/Servlet/</url>
    <content><![CDATA[<hr>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="原博客链接"><a href="#原博客链接" class="headerlink" title="原博客链接"></a>原博客链接</h2><p><a href="https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase</a></p>
<h2 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a>1. 什么是Servlet</h2><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的<strong>服务器端程序</strong>。其<strong>主要功能</strong>在于<font color="red"> <strong>交互式地浏览和修改数据，生成动态Web内容。</strong></font></p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
<p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<h2 id="2-Servlet的工作模式"><a href="#2-Servlet的工作模式" class="headerlink" title="2. Servlet的工作模式"></a>2. Servlet的工作模式</h2><ol>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ol>
<h2 id="3-Servlet-API-概览"><a href="#3-Servlet-API-概览" class="headerlink" title="3.Servlet API 概览"></a>3.Servlet API 概览</h2><p>Servlet API 包含以下4个Java包：</p>
<ul>
<li>1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。</li>
<li>2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。</li>
<li>3.javax.servlet.annotation   其中包含标注servlet,Filter,Listener的标注。它还为被标注元件定义元数据。</li>
<li>4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。</li>
</ul>
<h2 id="4-Servlet的主要类型"><a href="#4-Servlet的主要类型" class="headerlink" title="4.Servlet的主要类型"></a>4.Servlet的主要类型</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jhzPdpRL-1593665732617)(../images/Servlet/image-20200625232800398.png)]</p>
<h2 id="4-Servlet-的使用方法"><a href="#4-Servlet-的使用方法" class="headerlink" title="4.Servlet 的使用方法"></a>4.Servlet 的使用方法</h2><p>Servlet技术的核心是Servlet，<strong><em>\</em>它是所有Servlet类必须直接或者间接实现的一个接口**</strong>。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。</p>
<h2 id="5-Servlet-的工作原理"><a href="#5-Servlet-的工作原理" class="headerlink" title="5.Servlet 的工作原理"></a>5.Servlet 的工作原理</h2><p>Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，<font color="red"><strong>在一个应用程序中，每种Servlet类型只能有一个实例。</strong></font></p>
<p>用户请求致使Servlet容器调用Servlet的Service()方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p>
<p>ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据</p>
<p>ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，<font color="red"><strong>Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</strong></font></p>
<h2 id="6-Servlet-接口中定义的方法"><a href="#6-Servlet-接口中定义的方法" class="headerlink" title="6.Servlet 接口中定义的方法"></a>6.Servlet 接口中定义的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Servlet-的生命周期"><a href="#7-Servlet-的生命周期" class="headerlink" title="7.Servlet 的生命周期"></a>7.Servlet 的生命周期</h2><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：</p>
<ul>
<li>1.init( )———-当Servlet第一次被请求时，我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。</li>
<li>2.service( )——每当请求Servlet时，Servlet容器就会调用这个方法。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。</li>
<li>3.destory——–当要销毁Servlet时，Servlet容器就会调用这个方法。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</li>
</ul>
<h2 id="8-Servlet-的其它两个方法"><a href="#8-Servlet-的其它两个方法" class="headerlink" title="8.Servlet 的其它两个方法"></a>8.Servlet 的其它两个方法</h2><ol>
<li>String  getServletInfo（ ），这个方法会返回Servlet的一段描述，可以返回一段字符串。</li>
<li>ServletConfig getServletConfig（ ），这个方法会返回由Servlet容器传给init（ ）方法的ServletConfig对象。</li>
</ol>
<h2 id="9-ServletRequset接口"><a href="#9-ServletRequset接口" class="headerlink" title="9.ServletRequset接口"></a>9.ServletRequset接口</h2><p>Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。</p>
<p>让我们来看一看ServletRequest接口的部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span></span>;<span class="comment">//返回请求主体的字节数</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;<span class="comment">//返回主体的MIME类型</span></span><br><span class="line">    <span class="function">String <span class="title">getParameter</span><span class="params">(String var1)</span></span>;<span class="comment">//返回请求参数的值.它是在ServletRequest中最常用的方法，可用于获取查询字符串的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-ServletResponse接口"><a href="#10-ServletResponse接口" class="headerlink" title="10.ServletResponse接口"></a>10.ServletResponse接口</h2><p>   javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p>
<p>让我们也来看看ServletResponse内部定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCharacterEncoding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//返回了一个可以向客户端发送文本的PrintWriter对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCommitted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(Locale var1)</span></span>;</span><br><span class="line"><span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的getWriter方法，它返回了一个可以向客户端发送文本的的Java.io.PrintWriter对象。默认情况下，<font color="red"><strong>PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。</strong></font></p>
<p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。</p>
<p> 还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送<strong>二进制数据</strong>的。</p>
<p>在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p>
<h2 id="11-ServletConfig接口"><a href="#11-ServletConfig接口" class="headerlink" title="11.ServletConfig接口"></a>11.ServletConfig接口</h2><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。</p>
<p>其中几个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletName</span><span class="params">()</span></span>;<span class="comment">//获得Servlet在web. xml中配置的name的值.</span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span> <span class="params">(String name)</span></span>;<span class="comment">//获得Servlet的初始化参数.</span></span><br><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span></span>;<span class="comment">//获得所有Servlet的初始化参数的名称.</span></span><br></pre></td></tr></table></figure>

<h2 id="12-ServletContext对象"><a href="#12-ServletContext对象" class="headerlink" title="12.ServletContext对象"></a>12.ServletContext对象</h2><p><font color="red"><strong>ServletContext对象表示Servlet应用程序。</strong></font>每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。</p>
<p>通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。</p>
<p>那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，<font color="red"><strong>因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</strong></font></p>
<p>ServletContext中的下列方法负责处理属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="13-GenericServlet抽象类"><a href="#13-GenericServlet抽象类" class="headerlink" title="13.GenericServlet抽象类"></a>13.GenericServlet抽象类</h2><pre><code>前面我们编写Servlet一直是通过实现Servlet接口来编写的，但是，使用这种方法，则必须要实现Servlet接口中定义的所有的方法，即使有一些方法中没有任何东西也要去实现，并且还需要自己手动的维护ServletConfig这个对象的引用。因此，这样去实现Servlet是比较麻烦的。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<pre><code>幸好，GenericServlet抽象类的出现很好的解决了这个问题。本着尽可能使代码简洁的原则，GenericServlet实现了Servlet和ServletConfig接口，下面是GenericServlet抽象类的具体代码：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE = <span class="string">"javax.servlet.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings = ResourceBundle.getBundle(<span class="string">"javax.servlet.LocalStrings"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameterNames();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>其中，GenericServlet抽象类相比于直接实现Servlet接口，有以下几个好处：</code></pre><ul>
<li>1.为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。</li>
<li>2.提供方法，包围ServletConfig对象中的方法。</li>
<li>3.将init( )方法中的ServletConfig参数赋给了一个内部的ServletConfig引用从而来保存ServletConfig对象，不需要程序员自己去维护ServletConfig了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们发现在GenericServlet抽象类中还存在着另一个没有任何参数的Init()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>设计者的初衷到底是为了什么呢？在第一个带参数的init（）方法中就已经把ServletConfig对象传入并且通过引用保存好了，完成了Servlet的初始化过程，那么为什么后面还要加上一个不带任何参数的init（）方法呢？</p>
<p>我们知道，抽象类是无法直接产生实例的，需要另一个类去继承这个抽象类，那么就会发生方法覆盖的问题，如果在类中覆盖了GenericServlet抽象类的init（）方法，那么程序员就必须手动的去维护ServletConfig对象了，还得调用super.init(servletConfig）方法去调用父类GenericServlet的初始化方法来保存ServletConfig对象，这样会给程序员带来很大的麻烦。GenericServlet提供的第二个不带参数的init( )方法，就是为了解决上述问题的。</p>
<p>这个不带参数的init（）方法，是在ServletConfig对象被赋给ServletConfig引用后，由第一个带参数的init(ServletConfig servletconfig)方法调用的，那么这意味着，当程序员如果需要覆盖这个GenericServlet的初始化方法，则只需要覆盖那个不带参数的init( )方法就好了，此时，servletConfig对象仍然有GenericServlet保存着。</p>
<p>说了这么多，通过扩展GenericServlet抽象类，就不需要覆盖没有计划改变的方法。因此，代码将会变得更加的简洁，程序员的工作也会减少很多。</p>
<p>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p>
<h2 id="14-javax-servlet-http包内容"><a href="#14-javax-servlet-http包内容" class="headerlink" title="14.javax.servlet.http包内容"></a>14.javax.servlet.http包内容</h2><p>之所以所HttpServlet要比GenericServlet强大，其实也是有道理的。HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http包是Servlet API中的第二个包，其中包含了用于编写Servlet应用程序的类和接口。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ex0EkvRl-1593665732619)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200626001542857.png)]</p>
<h2 id="15-HttpServlet抽象类"><a href="#15-HttpServlet抽象类" class="headerlink" title="15.HttpServlet抽象类"></a>15.HttpServlet抽象类</h2><pre><code>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</code></pre><p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletRequest</span> <span class="keyword">extends</span> <span class="title">ServletRequest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法:</p>
<p>首先来看GenericServlet抽象类中是如何定义service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure>

<p> 我们看到是一个抽象方法，也就是HttpServlet要自己去实现这个service方法，我们在看看HttpServlet是怎么覆盖这个service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request = (HttpServletRequest)req;</span><br><span class="line">        response = (HttpServletResponse)res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   我们发现，HttpServlet中的service方法把接收到的ServletRequsest类型的对象转换成了HttpServletRequest类型的对象，把ServletResponse类型的对象转换成了HttpServletResponse类型的对象。之所以能够这样强制的转换，<font color="red"><strong>是因为在调用Servlet的Service方法时，Servlet容器总会传入一个HttpServletRequest对象和HttpServletResponse对象，预备使用HTTP。</strong></font>因此，转换类型当然不会出错了。</p>
<p>转换之后，service方法把两个转换后的对象传入了另一个service方法，那么我们再来看看这个方法是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现，这个service方法的参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象。</p>
<p>接下来我们再看看service方法是如何工作的，我们会发现在service方法中还是没有任何的服务逻辑，但是却在解析HttpServletRequest中的方法参数，并调用以下方法之一：doGet,doPost,doHead,doPut,doTrace,doOptions和doDelete。这7种方法中，每一种方法都表示一个Http方法。doGet和doPost是最常用的。所以，如果我们需要实现具体的服务逻辑，不再需要覆盖service方法了，只需要覆盖doGet或者doPost就好了。</p>
<p><font color="red"><strong>总之，HttpServlet有两个特性是GenericServlet所不具备的：</strong></font></p>
<p>1.不用覆盖service方法，而是覆盖doGet或者doPost方法。少数情况下,还会覆盖其他的5个方法。</p>
<p>2.使用的是HttpServletRequest和HttpServletResponse对象。</p>
<h2 id="16-HttpServletRequest接口"><a href="#16-HttpServletRequest接口" class="headerlink" title="16.HttpServletRequest接口"></a>16.HttpServletRequest接口</h2><p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;<span class="comment">//返回请求上下文的请求URI部分</span></span><br><span class="line">Cookie[] getCookies();<span class="comment">//返回一个cookie对象数组</span></span><br><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String var1)</span></span>;<span class="comment">//返回指定HTTP标题的值</span></span><br><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>;<span class="comment">//返回生成这个请求HTTP的方法名称</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span></span>;<span class="comment">//返回请求URL中的查询字符串</span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//返回与这个请求相关的会话对象</span></span><br></pre></td></tr></table></figure>

<h2 id="17-HttpServletRequest内封装的请求"><a href="#17-HttpServletRequest内封装的请求" class="headerlink" title="17.HttpServletRequest内封装的请求"></a>17.HttpServletRequest内封装的请求</h2><pre><code>Request代表请求，所以我们可以通过该对象分别获得HTTP请求的请求行，请求头和请求体。</code></pre><p><img src="../images/Servlet/20180513130638615.png" alt="img"></p>
<h3 id="17-1通过request获得请求行"><a href="#17-1通过request获得请求行" class="headerlink" title="17.1通过request获得请求行"></a>17.1通过request获得请求行</h3><p>假设查询字符串为：username=zhangsan&amp;password=123</p>
<p>获得客户端的请求方式：String getMethod()</p>
<p>获得请求的资源：</p>
<p>String getRequestURI()</p>
<p>StringBuffer getRequestURL()</p>
<p>String getContextPath() —web应用的名称</p>
<p>String getQueryString() —- get提交url地址后的参数字符串</p>
<h3 id="17-2通过request获得请求头"><a href="#17-2通过request获得请求头" class="headerlink" title="17.2通过request获得请求头"></a>17.2通过request获得请求头</h3><p>long getDateHeader(String name)</p>
<p>String getHeader(String name)</p>
<p>Enumeration getHeaderNames()</p>
<p>Enumeration getHeaders(String name)</p>
<p>int getIntHeader(String name)</p>
<p>referer头的作用：执行该此访问的的来源，做防盗链</p>
<h3 id="17-3通过request获得请求体"><a href="#17-3通过request获得请求体" class="headerlink" title="17.3通过request获得请求体"></a>17.3通过request获得请求体</h3><p>请求体中的内容是通过post提交的请求参数，格式是：</p>
<p>username=zhangsan&amp;password=123&amp;hobby=football&amp;hobby=basketball</p>
<p>key ———————- value</p>
<p>username                              [zhangsan]</p>
<p>password                              [123]</p>
<p>hobby                                     [football，basketball]                                       </p>
<p>以上面参数为例，通过以下方法获得请求参数：</p>
<p>String getParameter(String name)</p>
<p>String[] getParameterValues(String name)</p>
<p>Enumeration getParameterNames()</p>
<p>Map&lt;String,String[]&gt; getParameterMap()</p>
<pre><code>注意：get请求方式的请求参数 上述的方法一样可以获得。</code></pre><h2 id="18-Request乱码问题的解决方法"><a href="#18-Request乱码问题的解决方法" class="headerlink" title="18.Request乱码问题的解决方法"></a>18.Request乱码问题的解决方法</h2><pre><code>在前面我们讲过，在service中使用的编码解码方式默认为：ISO-8859-1编码，但此编码并不支持中文，因此会出现乱码问题，所以我们需要手动修改编码方式为UTF-8编码，才能解决中文乱码问题:</code></pre><ol>
<li>解决post提交方式的乱码：request.setCharacterEncoding(“UTF-8”);</li>
<li>解决get提交的方式的乱码：parameter = newString(parameter.getbytes(“iso8859-1”),”utf-8”); </li>
</ol>
<h2 id="19-HttpServletResponse接口"><a href="#19-HttpServletResponse接口" class="headerlink" title="19.HttpServletResponse接口"></a>19.HttpServletResponse接口</h2><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。    由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<h3 id="19-1HttpServletResponse内封装的响应"><a href="#19-1HttpServletResponse内封装的响应" class="headerlink" title="19.1HttpServletResponse内封装的响应"></a>19.1HttpServletResponse内封装的响应</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nnfRxfxH-1593665732621)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200626003927082.png)]</p>
<h3 id="19-2通过Response设置响应"><a href="#19-2通过Response设置响应" class="headerlink" title="19.2通过Response设置响应"></a>19.2通过Response设置响应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie var1)</span></span>;<span class="comment">//给这个响应添加一个cookie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;<span class="comment">//给这个请求添加一个响应头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//发送一条响应码，讲浏览器跳转到指定的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;<span class="comment">//设置响应行的状态码</span></span><br><span class="line"></span><br><span class="line">addHeader(String name, String value)</span><br><span class="line">addIntHeader(String name, <span class="keyword">int</span> value)</span><br><span class="line">addDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setHeader(String name, String value)</span><br><span class="line">setDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setIntHeader(String name, <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<p>其中，add表示添加，而set表示设置</p>
<p>PrintWriter getWriter()</p>
<p>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>ServletOutputStream getOutputStream()</p>
<p>获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节(二进制数据)，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。</p>
<p><font color="red"><strong>注意：虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常.</strong></font></p>
<h3 id="19-3Response的乱码问题"><a href="#19-3Response的乱码问题" class="headerlink" title="19.3Response的乱码问题"></a>19.3Response的乱码问题</h3><p>原因：response缓冲区的默认编码是iso8859-1，此码表中没有中文。所以需要更改response的编码方式：</p>
<p><img src="../images/Servlet/20180513210927639.png" alt="img"></p>
<h3 id="19-4-Response的工作流程"><a href="#19-4-Response的工作流程" class="headerlink" title="19.4 Response的工作流程"></a>19.4 Response的工作流程</h3><p><img src="../images/Servlet/20180513204718428.png" alt="img"></p>
<h2 id="20-Servlet的工作流程"><a href="#20-Servlet的工作流程" class="headerlink" title="20.Servlet的工作流程"></a>20.Servlet的工作流程</h2><p><img src="../images/Servlet/20180513204808318.png" alt="img"></p>
<h2 id="21-ServletContextListener（Servlet全局监听器）"><a href="#21-ServletContextListener（Servlet全局监听器）" class="headerlink" title="21. ServletContextListener（Servlet全局监听器）"></a>21. ServletContextListener（Servlet全局监听器）</h2><p>首先要说明的是，ServletContextListener是一个接口，我们随便写一个类，只要这个类实现了ServletContextListener接口，那么这个类就实现了【监听ServletContext】的功能。那么，这个神奇的接口是如何定义的呢？我们来看一下这个接口的内部情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在这个接口中只声明了两个方法，分别是void contextInitialized(ServletContextEvent var1)和void contextDestroyed(ServletContextEvent var1)方法，所以，我们很容易的就能猜测到，ServletContext的生命只有两种，分别是：</p>
<p>1.ServletContext初始化。（应用start时）———-&gt;Servlet容器调用void contextInitialized(ServletContextEvent var1)</p>
<p>2.ServletContext销毁。（应用stop时）———-&gt;Servlet容器调用 void contextDestroyed(ServletContextEvent var1)</p>
<p>因此，我们大概能够猜到ServletContextListener的工作机制了，当应用启动时，ServletContext进行初始化，然后Servlet容器会自动调用正在监听ServletContext的ServletContextListener的void contextInitialized(ServletContextEvent var1)方法，并向其传入一个ServletContextEvent对象。当应用停止时，ServletContext被销毁，此时Servlet容器也会自动地调用正在监听ServletContext的ServletContextListener的void contextDestroyed(ServletContextEvent var1)方法。</p>
<h2 id="22-【进阶】ServletContextListener在Spring中的应用"><a href="#22-【进阶】ServletContextListener在Spring中的应用" class="headerlink" title="22.【进阶】ServletContextListener在Spring中的应用"></a>22.【进阶】ServletContextListener在Spring中的应用</h2><p>Spring容器是如何借用ServletContextListener这个接口来实例化的。</p>
<p>首先让我们再来回顾一下ServletContext的概念，ServletContext翻译成中文叫做“Servlet上下文”或者“Servlet全局”，其实ServletContext就是一个“域对象”，它存在于整个应用中，并在在整个应用中有且仅有1份，它表示了当前整个应用的“状态”，你也可以理解为某个时刻的ServletContext代表了这个应用在某个时刻的“一张快照”，这张“快照”里面包含了有关应用的许多信息，应用的所有组件都可以从ServletContext获取当前应用的状态信息。ServletContext随着程序的启动而创建，随着程序的停止而销毁。通俗点说，我们可以往这个ServletContext域对象中“存东西”，然后也可以在别的地方中“取出来”。</p>
<p>我们知道，Spring容器可以通过：</p>
<p>ApplicationContext ctx=new ClassPathXmlApplicationContext(“配置文件的路径”）;</p>
<p>显示地实例化一个Spring IOC容器。也可以像下面一样，在web.xml中注册Spring IOC容器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">context</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line">        classpath:applicationContext.xml</span><br><span class="line">    &lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<p>其中的监听器类【org.springframework.web.context.ContextLoaderListener】实现了ServletContextListener接口，能够监听ServletContext的生命周期中的“初始化”和“销毁”。注意，这个【org.springframework.web.context.ContextLoaderListener】监听器类当然不是我们自己写的哦，是人家Spring团队写的，我们只要拿来用就行了。当然，别忘记导入相关的Jar包。（spring-web-4.2.4.RELEASE.jar）</p>
<p>那么，Spring团队给我们提供的这个监听器类是如何实现：当ServletContext初始化后，Spring IOC容器也能跟着初始化的呢？怀着好奇心，让我们再来看一看【org.springframework.web.context.ContextLoaderListener】的内部实现情况吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注下面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注上面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，【org.springframework.web.context.ContextLoaderListener】这个类实现了ServletContextListener接口中的两个方法，其中，当ServletContext初始化后， public void contextInitialized(ServletContextEvent event)方法被调用，接下来执行initWebApplicationContext(event.getServletContext())方法，但是我们发现这个方法并没有在这个类中声明</p>
<p>分析到这一步，我们发现Spring容器在这个方法中被实例化了。接下来，就让我们整理一下整体的思路：</p>
<p>当Servlet容器启动时，ServletContext对象被初始化，然后Servlet容器调用web.xml中注册的监听器的public void contextInitialized(ServletContextEvent event)方法，而在监听器中，调用了this.initWebApplicationContext(event.getServletContext())方法，在这个方法中实例化了Spring IOC容器。即ApplicationContext对象。</p>
<p>因此，当ServletContext创建时我们可以创建applicationContext对象，当ServletContext销毁时，我们可以销毁applicationContext对象。这样applicationContext就和ServletContext“共生死了”。</p>
]]></content>
      <categories>
        <category>javaweb基础</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>sdcba</title>
    <url>/2020/07/02/sdcba/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>test</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet1</title>
    <url>/2020/07/02/Servlet1/</url>
    <content><![CDATA[<hr>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="原博客链接"><a href="#原博客链接" class="headerlink" title="原博客链接"></a>原博客链接</h2><p><a href="https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase</a></p>
<h2 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a>1. 什么是Servlet</h2><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的<strong>服务器端程序</strong>。其<strong>主要功能</strong>在于<font color="red"> <strong>交互式地浏览和修改数据，生成动态Web内容。</strong></font></p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
<p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<h2 id="2-Servlet的工作模式"><a href="#2-Servlet的工作模式" class="headerlink" title="2. Servlet的工作模式"></a>2. Servlet的工作模式</h2><ol>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ol>
<h2 id="3-Servlet-API-概览"><a href="#3-Servlet-API-概览" class="headerlink" title="3.Servlet API 概览"></a>3.Servlet API 概览</h2><p>Servlet API 包含以下4个Java包：</p>
<ul>
<li>1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。</li>
<li>2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。</li>
<li>3.javax.servlet.annotation   其中包含标注servlet,Filter,Listener的标注。它还为被标注元件定义元数据。</li>
<li>4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。</li>
</ul>
<h2 id="4-Servlet的主要类型"><a href="#4-Servlet的主要类型" class="headerlink" title="4.Servlet的主要类型"></a>4.Servlet的主要类型</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jhzPdpRL-1593665732617)(../images/Servlet/image-20200625232800398.png)]</p>
<h2 id="4-Servlet-的使用方法"><a href="#4-Servlet-的使用方法" class="headerlink" title="4.Servlet 的使用方法"></a>4.Servlet 的使用方法</h2><p>Servlet技术的核心是Servlet，<strong><em>\</em>它是所有Servlet类必须直接或者间接实现的一个接口**</strong>。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。</p>
<h2 id="5-Servlet-的工作原理"><a href="#5-Servlet-的工作原理" class="headerlink" title="5.Servlet 的工作原理"></a>5.Servlet 的工作原理</h2><p>Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，<font color="red"><strong>在一个应用程序中，每种Servlet类型只能有一个实例。</strong></font></p>
<p>用户请求致使Servlet容器调用Servlet的Service()方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p>
<p>ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据</p>
<p>ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，<font color="red"><strong>Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</strong></font></p>
<h2 id="6-Servlet-接口中定义的方法"><a href="#6-Servlet-接口中定义的方法" class="headerlink" title="6.Servlet 接口中定义的方法"></a>6.Servlet 接口中定义的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Servlet-的生命周期"><a href="#7-Servlet-的生命周期" class="headerlink" title="7.Servlet 的生命周期"></a>7.Servlet 的生命周期</h2><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：</p>
<ul>
<li>1.init( )———-当Servlet第一次被请求时，我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。</li>
<li>2.service( )——每当请求Servlet时，Servlet容器就会调用这个方法。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。</li>
<li>3.destory——–当要销毁Servlet时，Servlet容器就会调用这个方法。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</li>
</ul>
<h2 id="8-Servlet-的其它两个方法"><a href="#8-Servlet-的其它两个方法" class="headerlink" title="8.Servlet 的其它两个方法"></a>8.Servlet 的其它两个方法</h2><ol>
<li>String  getServletInfo（ ），这个方法会返回Servlet的一段描述，可以返回一段字符串。</li>
<li>ServletConfig getServletConfig（ ），这个方法会返回由Servlet容器传给init（ ）方法的ServletConfig对象。</li>
</ol>
<h2 id="9-ServletRequset接口"><a href="#9-ServletRequset接口" class="headerlink" title="9.ServletRequset接口"></a>9.ServletRequset接口</h2><p>Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。</p>
<p>让我们来看一看ServletRequest接口的部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span></span>;<span class="comment">//返回请求主体的字节数</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;<span class="comment">//返回主体的MIME类型</span></span><br><span class="line">    <span class="function">String <span class="title">getParameter</span><span class="params">(String var1)</span></span>;<span class="comment">//返回请求参数的值.它是在ServletRequest中最常用的方法，可用于获取查询字符串的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-ServletResponse接口"><a href="#10-ServletResponse接口" class="headerlink" title="10.ServletResponse接口"></a>10.ServletResponse接口</h2><p>   javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p>
<p>让我们也来看看ServletResponse内部定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCharacterEncoding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//返回了一个可以向客户端发送文本的PrintWriter对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCommitted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(Locale var1)</span></span>;</span><br><span class="line"><span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的getWriter方法，它返回了一个可以向客户端发送文本的的Java.io.PrintWriter对象。默认情况下，<font color="red"><strong>PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。</strong></font></p>
<p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。</p>
<p> 还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送<strong>二进制数据</strong>的。</p>
<p>在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p>
<h2 id="11-ServletConfig接口"><a href="#11-ServletConfig接口" class="headerlink" title="11.ServletConfig接口"></a>11.ServletConfig接口</h2><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。</p>
<p>其中几个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletName</span><span class="params">()</span></span>;<span class="comment">//获得Servlet在web. xml中配置的name的值.</span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span> <span class="params">(String name)</span></span>;<span class="comment">//获得Servlet的初始化参数.</span></span><br><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span></span>;<span class="comment">//获得所有Servlet的初始化参数的名称.</span></span><br></pre></td></tr></table></figure>

<h2 id="12-ServletContext对象"><a href="#12-ServletContext对象" class="headerlink" title="12.ServletContext对象"></a>12.ServletContext对象</h2><p><font color="red"><strong>ServletContext对象表示Servlet应用程序。</strong></font>每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。</p>
<p>通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。</p>
<p>那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，<font color="red"><strong>因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</strong></font></p>
<p>ServletContext中的下列方法负责处理属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="13-GenericServlet抽象类"><a href="#13-GenericServlet抽象类" class="headerlink" title="13.GenericServlet抽象类"></a>13.GenericServlet抽象类</h2><pre><code>前面我们编写Servlet一直是通过实现Servlet接口来编写的，但是，使用这种方法，则必须要实现Servlet接口中定义的所有的方法，即使有一些方法中没有任何东西也要去实现，并且还需要自己手动的维护ServletConfig这个对象的引用。因此，这样去实现Servlet是比较麻烦的。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<pre><code>幸好，GenericServlet抽象类的出现很好的解决了这个问题。本着尽可能使代码简洁的原则，GenericServlet实现了Servlet和ServletConfig接口，下面是GenericServlet抽象类的具体代码：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE = <span class="string">"javax.servlet.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings = ResourceBundle.getBundle(<span class="string">"javax.servlet.LocalStrings"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameterNames();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>其中，GenericServlet抽象类相比于直接实现Servlet接口，有以下几个好处：</code></pre><ul>
<li>1.为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。</li>
<li>2.提供方法，包围ServletConfig对象中的方法。</li>
<li>3.将init( )方法中的ServletConfig参数赋给了一个内部的ServletConfig引用从而来保存ServletConfig对象，不需要程序员自己去维护ServletConfig了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们发现在GenericServlet抽象类中还存在着另一个没有任何参数的Init()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>设计者的初衷到底是为了什么呢？在第一个带参数的init（）方法中就已经把ServletConfig对象传入并且通过引用保存好了，完成了Servlet的初始化过程，那么为什么后面还要加上一个不带任何参数的init（）方法呢？</p>
<p>我们知道，抽象类是无法直接产生实例的，需要另一个类去继承这个抽象类，那么就会发生方法覆盖的问题，如果在类中覆盖了GenericServlet抽象类的init（）方法，那么程序员就必须手动的去维护ServletConfig对象了，还得调用super.init(servletConfig）方法去调用父类GenericServlet的初始化方法来保存ServletConfig对象，这样会给程序员带来很大的麻烦。GenericServlet提供的第二个不带参数的init( )方法，就是为了解决上述问题的。</p>
<p>这个不带参数的init（）方法，是在ServletConfig对象被赋给ServletConfig引用后，由第一个带参数的init(ServletConfig servletconfig)方法调用的，那么这意味着，当程序员如果需要覆盖这个GenericServlet的初始化方法，则只需要覆盖那个不带参数的init( )方法就好了，此时，servletConfig对象仍然有GenericServlet保存着。</p>
<p>说了这么多，通过扩展GenericServlet抽象类，就不需要覆盖没有计划改变的方法。因此，代码将会变得更加的简洁，程序员的工作也会减少很多。</p>
<p>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p>
<h2 id="14-javax-servlet-http包内容"><a href="#14-javax-servlet-http包内容" class="headerlink" title="14.javax.servlet.http包内容"></a>14.javax.servlet.http包内容</h2><p>之所以所HttpServlet要比GenericServlet强大，其实也是有道理的。HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http包是Servlet API中的第二个包，其中包含了用于编写Servlet应用程序的类和接口。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ex0EkvRl-1593665732619)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200626001542857.png)]</p>
<h2 id="15-HttpServlet抽象类"><a href="#15-HttpServlet抽象类" class="headerlink" title="15.HttpServlet抽象类"></a>15.HttpServlet抽象类</h2><pre><code>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</code></pre><p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletRequest</span> <span class="keyword">extends</span> <span class="title">ServletRequest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法:</p>
<p>首先来看GenericServlet抽象类中是如何定义service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure>

<p> 我们看到是一个抽象方法，也就是HttpServlet要自己去实现这个service方法，我们在看看HttpServlet是怎么覆盖这个service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request = (HttpServletRequest)req;</span><br><span class="line">        response = (HttpServletResponse)res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   我们发现，HttpServlet中的service方法把接收到的ServletRequsest类型的对象转换成了HttpServletRequest类型的对象，把ServletResponse类型的对象转换成了HttpServletResponse类型的对象。之所以能够这样强制的转换，<font color="red"><strong>是因为在调用Servlet的Service方法时，Servlet容器总会传入一个HttpServletRequest对象和HttpServletResponse对象，预备使用HTTP。</strong></font>因此，转换类型当然不会出错了。</p>
<p>转换之后，service方法把两个转换后的对象传入了另一个service方法，那么我们再来看看这个方法是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现，这个service方法的参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象。</p>
<p>接下来我们再看看service方法是如何工作的，我们会发现在service方法中还是没有任何的服务逻辑，但是却在解析HttpServletRequest中的方法参数，并调用以下方法之一：doGet,doPost,doHead,doPut,doTrace,doOptions和doDelete。这7种方法中，每一种方法都表示一个Http方法。doGet和doPost是最常用的。所以，如果我们需要实现具体的服务逻辑，不再需要覆盖service方法了，只需要覆盖doGet或者doPost就好了。</p>
<p><font color="red"><strong>总之，HttpServlet有两个特性是GenericServlet所不具备的：</strong></font></p>
<p>1.不用覆盖service方法，而是覆盖doGet或者doPost方法。少数情况下,还会覆盖其他的5个方法。</p>
<p>2.使用的是HttpServletRequest和HttpServletResponse对象。</p>
<h2 id="16-HttpServletRequest接口"><a href="#16-HttpServletRequest接口" class="headerlink" title="16.HttpServletRequest接口"></a>16.HttpServletRequest接口</h2><p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;<span class="comment">//返回请求上下文的请求URI部分</span></span><br><span class="line">Cookie[] getCookies();<span class="comment">//返回一个cookie对象数组</span></span><br><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String var1)</span></span>;<span class="comment">//返回指定HTTP标题的值</span></span><br><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>;<span class="comment">//返回生成这个请求HTTP的方法名称</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span></span>;<span class="comment">//返回请求URL中的查询字符串</span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//返回与这个请求相关的会话对象</span></span><br></pre></td></tr></table></figure>

<h2 id="17-HttpServletRequest内封装的请求"><a href="#17-HttpServletRequest内封装的请求" class="headerlink" title="17.HttpServletRequest内封装的请求"></a>17.HttpServletRequest内封装的请求</h2><pre><code>Request代表请求，所以我们可以通过该对象分别获得HTTP请求的请求行，请求头和请求体。</code></pre><p><img src="https://img-blog.csdn.net/20180513130638615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="17-1通过request获得请求行"><a href="#17-1通过request获得请求行" class="headerlink" title="17.1通过request获得请求行"></a>17.1通过request获得请求行</h3><p>假设查询字符串为：username=zhangsan&amp;password=123</p>
<p>获得客户端的请求方式：String getMethod()</p>
<p>获得请求的资源：</p>
<p>String getRequestURI()</p>
<p>StringBuffer getRequestURL()</p>
<p>String getContextPath() —web应用的名称</p>
<p>String getQueryString() —- get提交url地址后的参数字符串</p>
<h3 id="17-2通过request获得请求头"><a href="#17-2通过request获得请求头" class="headerlink" title="17.2通过request获得请求头"></a>17.2通过request获得请求头</h3><p>long getDateHeader(String name)</p>
<p>String getHeader(String name)</p>
<p>Enumeration getHeaderNames()</p>
<p>Enumeration getHeaders(String name)</p>
<p>int getIntHeader(String name)</p>
<p>referer头的作用：执行该此访问的的来源，做防盗链</p>
<h3 id="17-3通过request获得请求体"><a href="#17-3通过request获得请求体" class="headerlink" title="17.3通过request获得请求体"></a>17.3通过request获得请求体</h3><p>请求体中的内容是通过post提交的请求参数，格式是：</p>
<p>username=zhangsan&amp;password=123&amp;hobby=football&amp;hobby=basketball</p>
<p>key ———————- value</p>
<p>username                              [zhangsan]</p>
<p>password                              [123]</p>
<p>hobby                                     [football，basketball]                                       </p>
<p>以上面参数为例，通过以下方法获得请求参数：</p>
<p>String getParameter(String name)</p>
<p>String[] getParameterValues(String name)</p>
<p>Enumeration getParameterNames()</p>
<p>Map&lt;String,String[]&gt; getParameterMap()</p>
<pre><code>注意：get请求方式的请求参数 上述的方法一样可以获得。</code></pre><h2 id="18-Request乱码问题的解决方法"><a href="#18-Request乱码问题的解决方法" class="headerlink" title="18.Request乱码问题的解决方法"></a>18.Request乱码问题的解决方法</h2><pre><code>在前面我们讲过，在service中使用的编码解码方式默认为：ISO-8859-1编码，但此编码并不支持中文，因此会出现乱码问题，所以我们需要手动修改编码方式为UTF-8编码，才能解决中文乱码问题:</code></pre><ol>
<li>解决post提交方式的乱码：request.setCharacterEncoding(“UTF-8”);</li>
<li>解决get提交的方式的乱码：parameter = newString(parameter.getbytes(“iso8859-1”),”utf-8”); </li>
</ol>
<h2 id="19-HttpServletResponse接口"><a href="#19-HttpServletResponse接口" class="headerlink" title="19.HttpServletResponse接口"></a>19.HttpServletResponse接口</h2><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。    由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<h3 id="19-1HttpServletResponse内封装的响应"><a href="#19-1HttpServletResponse内封装的响应" class="headerlink" title="19.1HttpServletResponse内封装的响应"></a>19.1HttpServletResponse内封装的响应</h3><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nnfRxfxH-1593665732621)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200626003927082.png)]</p>
<h3 id="19-2通过Response设置响应"><a href="#19-2通过Response设置响应" class="headerlink" title="19.2通过Response设置响应"></a>19.2通过Response设置响应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie var1)</span></span>;<span class="comment">//给这个响应添加一个cookie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;<span class="comment">//给这个请求添加一个响应头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//发送一条响应码，讲浏览器跳转到指定的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;<span class="comment">//设置响应行的状态码</span></span><br><span class="line"></span><br><span class="line">addHeader(String name, String value)</span><br><span class="line">addIntHeader(String name, <span class="keyword">int</span> value)</span><br><span class="line">addDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setHeader(String name, String value)</span><br><span class="line">setDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setIntHeader(String name, <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<p>其中，add表示添加，而set表示设置</p>
<p>PrintWriter getWriter()</p>
<p>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>ServletOutputStream getOutputStream()</p>
<p>获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节(二进制数据)，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。</p>
<p><font color="red"><strong>注意：虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常.</strong></font></p>
<h3 id="19-3Response的乱码问题"><a href="#19-3Response的乱码问题" class="headerlink" title="19.3Response的乱码问题"></a>19.3Response的乱码问题</h3><p>原因：response缓冲区的默认编码是iso8859-1，此码表中没有中文。所以需要更改response的编码方式：</p>
<p><img src="https://img-blog.csdn.net/20180513210927639?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="19-4-Response的工作流程"><a href="#19-4-Response的工作流程" class="headerlink" title="19.4 Response的工作流程"></a>19.4 Response的工作流程</h3><p><img src="https://img-blog.csdn.net/20180513204718428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="20-Servlet的工作流程"><a href="#20-Servlet的工作流程" class="headerlink" title="20.Servlet的工作流程"></a>20.Servlet的工作流程</h2><p><img src="https://img-blog.csdn.net/20180513204808318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="21-ServletContextListener（Servlet全局监听器）"><a href="#21-ServletContextListener（Servlet全局监听器）" class="headerlink" title="21. ServletContextListener（Servlet全局监听器）"></a>21. ServletContextListener（Servlet全局监听器）</h2><p>首先要说明的是，ServletContextListener是一个接口，我们随便写一个类，只要这个类实现了ServletContextListener接口，那么这个类就实现了【监听ServletContext】的功能。那么，这个神奇的接口是如何定义的呢？我们来看一下这个接口的内部情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在这个接口中只声明了两个方法，分别是void contextInitialized(ServletContextEvent var1)和void contextDestroyed(ServletContextEvent var1)方法，所以，我们很容易的就能猜测到，ServletContext的生命只有两种，分别是：</p>
<p>1.ServletContext初始化。（应用start时）———-&gt;Servlet容器调用void contextInitialized(ServletContextEvent var1)</p>
<p>2.ServletContext销毁。（应用stop时）———-&gt;Servlet容器调用 void contextDestroyed(ServletContextEvent var1)</p>
<p>因此，我们大概能够猜到ServletContextListener的工作机制了，当应用启动时，ServletContext进行初始化，然后Servlet容器会自动调用正在监听ServletContext的ServletContextListener的void contextInitialized(ServletContextEvent var1)方法，并向其传入一个ServletContextEvent对象。当应用停止时，ServletContext被销毁，此时Servlet容器也会自动地调用正在监听ServletContext的ServletContextListener的void contextDestroyed(ServletContextEvent var1)方法。</p>
<h2 id="22-【进阶】ServletContextListener在Spring中的应用"><a href="#22-【进阶】ServletContextListener在Spring中的应用" class="headerlink" title="22.【进阶】ServletContextListener在Spring中的应用"></a>22.【进阶】ServletContextListener在Spring中的应用</h2><p>Spring容器是如何借用ServletContextListener这个接口来实例化的。</p>
<p>首先让我们再来回顾一下ServletContext的概念，ServletContext翻译成中文叫做“Servlet上下文”或者“Servlet全局”，其实ServletContext就是一个“域对象”，它存在于整个应用中，并在在整个应用中有且仅有1份，它表示了当前整个应用的“状态”，你也可以理解为某个时刻的ServletContext代表了这个应用在某个时刻的“一张快照”，这张“快照”里面包含了有关应用的许多信息，应用的所有组件都可以从ServletContext获取当前应用的状态信息。ServletContext随着程序的启动而创建，随着程序的停止而销毁。通俗点说，我们可以往这个ServletContext域对象中“存东西”，然后也可以在别的地方中“取出来”。</p>
<p>我们知道，Spring容器可以通过：</p>
<p>ApplicationContext ctx=new ClassPathXmlApplicationContext(“配置文件的路径”）;</p>
<p>显示地实例化一个Spring IOC容器。也可以像下面一样，在web.xml中注册Spring IOC容器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">context</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line">        classpath:applicationContext.xml</span><br><span class="line">    &lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<p>其中的监听器类【org.springframework.web.context.ContextLoaderListener】实现了ServletContextListener接口，能够监听ServletContext的生命周期中的“初始化”和“销毁”。注意，这个【org.springframework.web.context.ContextLoaderListener】监听器类当然不是我们自己写的哦，是人家Spring团队写的，我们只要拿来用就行了。当然，别忘记导入相关的Jar包。（spring-web-4.2.4.RELEASE.jar）</p>
<p>那么，Spring团队给我们提供的这个监听器类是如何实现：当ServletContext初始化后，Spring IOC容器也能跟着初始化的呢？怀着好奇心，让我们再来看一看【org.springframework.web.context.ContextLoaderListener】的内部实现情况吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注下面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注上面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，【org.springframework.web.context.ContextLoaderListener】这个类实现了ServletContextListener接口中的两个方法，其中，当ServletContext初始化后， public void contextInitialized(ServletContextEvent event)方法被调用，接下来执行initWebApplicationContext(event.getServletContext())方法，但是我们发现这个方法并没有在这个类中声明</p>
<p>分析到这一步，我们发现Spring容器在这个方法中被实例化了。接下来，就让我们整理一下整体的思路：</p>
<p>当Servlet容器启动时，ServletContext对象被初始化，然后Servlet容器调用web.xml中注册的监听器的public void contextInitialized(ServletContextEvent event)方法，而在监听器中，调用了this.initWebApplicationContext(event.getServletContext())方法，在这个方法中实例化了Spring IOC容器。即ApplicationContext对象。</p>
<p>因此，当ServletContext创建时我们可以创建applicationContext对象，当ServletContext销毁时，我们可以销毁applicationContext对象。这样applicationContext就和ServletContext“共生死了”。</p>
]]></content>
  </entry>
</search>
