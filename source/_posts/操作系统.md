---
tags: 
- OS
categories: 
- 基础
- 操作系统
typora-root-url: ../_posts
---

# 1.    一、操作系统引论

## 1.1.     计算机层次结构

### 1.1.1.     软件

#### 应用软件

#### 系统软件

##### 数据库系统、汇编器、编译软件

##### 操作系统OS

### 1.1.2.     硬件

#### 裸机

## 1.2.     操作系统定义

### 1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充

### 1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合

## 1.3.     操作系统目标

### 1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别

### 1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程

### 1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作

## 1.4.     操作系统作用

### 1.4.1.     1、用户与计算机硬件系统之间的接口

### 1.4.2.     2、计算机资源的管理者

### 1.4.3.     3、实现对计算机资源的抽象（扩展机/虚拟机）

## 1.5.     操作系统分类

### 1.5.1.     人工操作

#### 利用率=执行时间/（执行时间+读卡时间）

### 1.5.2.     批处理系统

#### 单道批处理系统

##### 定义

###### 若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。

##### 优缺点

###### 1、优点：改善了CPU和I/O设备的使用效率；提高了系统吞吐量

###### 2、缺点：系统资源得不到充分利用；CPU和I/O外设忙闲不均

##### 主要特征

###### 1、自动性

###### 2、顺序性

###### 3、单道性

#### 多道批处理系统

##### 定义

###### 作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。

##### 优缺点

###### 1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）

###### 2、缺点：

用户交互性差：整个作业完成后或中间出错时，才与用户交互

作业平均周转时间长：短作业周转时间显著增长

##### 主要特征

###### 1、多道：内存中同时存放多个作业

###### 2、宏观：并行运行，都处于运行状态

###### 3、微观：串行运行，各作业交替使用CPU

##### 技术问题

### 1.5.3.     分时系统

#### 定义

##### 是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。

#### 主要特征

##### 1、交互性：用户与系统可以进行广泛的人机对话

##### 2、多路性：多用户在各自终端上使用同一CPU

##### 3、独立性：用户独立操作，互不干扰

##### 4、及时性:用户短时间内得到系统地及时回答

##### ps：可靠性：较低

#### 影响响应时间的因素

##### 终端数目；时间片大小；信息交换量；信息交换速度

### 1.5.4.     实时系统

#### 定义

##### 能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位

#### 主要特征

##### 1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序

##### 2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构

##### 3、独立性：独立操作互不干扰

##### 4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级

##### ps:可靠性：高度可靠

#### 实时系统分类

##### 实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统

##### 实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答

#### 任务类型分类

##### 任务执行是否周期性

###### 周期性实时任务：设备周期性发送信号

###### 非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）

##### 截止时间的要求

###### 硬实时任务：必须满足截止时间

###### 软实时任务：允许偶尔不满足截止时间

### 1.5.5.     多处理机操作系统

#### 优点

##### 增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）

##### 提高系统可靠性：故障时系统降级运行

#### 分类

##### 并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连

###### 对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式

###### 非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I/O处理。负载不匀，可靠性较低（通常要求硬件也非对称）

##### 分布式系统（松散耦合）：各处理机有各自的存储器，OS和I/O设备，由通道或通信线路相连

### 1.5.6.     网络操作系统

#### 定义

##### 提供网络通信和网络服务功能的操作系统

#### 主要特征

##### 1、耦合程度

###### 松散耦合，允许异种OS互联，遵循“协议同质”

##### 2、并行性

###### 各机进程独立

##### 3、透明性（用户是否知道或指定资源在哪个机器上）

###### 用户明确指定要使用的网络资源

##### 4、健壮性

###### 要求不高

### 1.5.7.     分布式操作系统

#### 定义：

##### 以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配

#### 主要特征

##### 1、耦合程度

###### 紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。

##### 2、并行性

###### 一个进程可以分散在各机上并行执行，“进程迁移”

##### 3、透明性

###### 网络资源调度对用户透明，用户不了解所占有资源所在位置

##### 4、健壮性

###### 要求比网络OS更强的容错能力（工作时系统重构）

### 1.5.8.     个人计算机操作系统

#### 单用户单任务

##### 只允许一个用户上机，只允许用户程序作为一个任务运行

#### 单用户多任务

##### 只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能

#### 多用户多任务

##### 允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能

## 1.6.     操作系统基本特征

### 1.6.1.     并发

#### 多个事件同一时间段发生

#### ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行

### 1.6.2.     共享

#### 计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问

### 1.6.3.     虚拟

#### 一个物理实体映射为多个逻辑实体——分时或分空间

### 1.6.4.     异步

#### 又称不确定性；指进程的执行顺序和执行时间的不确定性。

## 1.7.     操作系统组成

### 1.7.1.     管理模块

#### 针对不同管理对象模块的程序模块（通常被称为操作系统核心）

### 1.7.2.     用户接口

#### 如外壳（shell）、窗口系统

## 1.8.     操作系统主要功能

### 1.8.1.     存储管理

#### 目标

##### 提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行

#### 功能

##### 1、存储分配和回收

##### 2、存储保护

###### 保证进程互不干扰

##### 3、地址映射

###### 进程逻辑地址到内存物理地址的映射

##### 4、内存扩充

###### 覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间

### 1.8.2.     处理机管理

#### 目标

##### 处理机资源的分配调度

#### 功能

##### 1、进程控制

###### 创建、撤销、挂起、改变优先级等

##### 2、进程同步

###### 协调并发进程之间的推进步骤，以协调资源共享

##### 3、进程通信

###### 进程之间传输数据，协调合作

##### 4、调度

###### 作业或进程的运行切换

### 1.8.3.     设备管理

#### 目标

##### 方便用户使用设备、提高CPU和I/O利用率

#### 功能

##### 1、设备操作

###### 利用设备驱动程序完成对设备的操作

##### 2、设备独立性

###### 提供统一的I/O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容

##### 3、设备分配与回收

###### 多用户间共享I/O设备

### 1.8.4.     文件管理

#### 目标

##### 管理用户文件和系统文件方便用户使用，并保证文件安全性

#### 功能

##### 1、文件存储空间管理

##### 2、目录管理

###### 解决文件检索问题

##### 3、文件读写管理与存取控制

##### 4、软件管理

###### 软件版本、相互依赖关系、安装和卸载等

### 1.8.5.     用户接口

#### 目标

##### 提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供

#### 功能

##### 1、命令接口

###### 联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成

###### 脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成

##### 2、程序接口

###### 用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成

##### 3、图形接口

###### 用鼠标通过菜单框来完成对应用程序和文件的操作

## 1.9.     双模式操作

### 1.9.1.     分类

#### 1、用户模式（目态—模式位1）

#### 2、监控模式（管态—模式位0）

### 1.9.2.     切换

#### 用户态->系统态

##### 中断、故障、系统调用（用户需要操作系统的服务）

#### 系统态->用户态

##### OS设置用户态

### 1.9.3.     作用

#### 确保系统和用户程序不受错误的系统程序的影响

#### 实现方法

##### 将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统

### 1.9.4.     特权指令

#### 1、有关I/O设备的指令

#### 2、访问程序状态的指令

#### 3、存储特殊寄存器的指令

#### 4、其他指令

## 1.10.   操作系统保护机制

### 1.10.1.   I/O保护

#### 所有的I/O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权

### 1.10.2.   存储保护

#### 某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区

#### 为了实现存储保护，增加两个寄存器

##### 基地址寄存器：存放本进程最低的内存物理地址

##### 界限寄存器：存放本进程的存储区域大小

#### 硬件保护原则

##### 管态下OS可以无限制访问核心和所有用户程序的地址空间

#### 修改基地址寄存器和界限寄存器的指令属于特权指令 

### 1.10.3.   CPU保护

#### 为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断

#### 定时时钟是实现分时操作系统的基础

#### 修改定时时钟的指令为特权指令

# 2.    二、进程的描述与控制

## 2.1.     进程描述

### 2.1.1.     进程定义

#### 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程

#### 是资源分配和管理的基本单位

### 2.1.2.     进程执行方式

#### 顺序执行

##### 特征

###### 1、顺序性

###### 2、封闭性

独占全部资源

###### 3、可再现性

初始条件相同则结果相同

#### 并发执行

##### 目的

###### 提高资源利用率

##### 特征（不加入任何系统控制）

###### 1、间断性

###### 2、失去封闭性：共享资源

###### 3、失去可再现性

##### 执行条件

###### 达到封闭性和可再现性

### 2.1.3.     与程序的关系

#### 一个进程多个线程，一个线程对应一个进程

### 2.1.4.     进程特征

#### 1、动态性

#### 2、并发性

#### 3、独立性

##### 资源分配的基本单位

#### 4、异步性

##### 进程各自独立，推进速度不可预知

#### 5、结构化

##### 代码段+数据段+程序控制块（PCB）

##### PCB

### 2.1.5.     进程基本状态及转换

#### 基本状态

##### 就绪（Ready）状态

##### 执行（Running）状态

##### 阻塞（Block）状态

#### 转换

##### PPT-6

## 2.2.     进程控制

### 2.2.1.     程序控制块PCB

#### 1、是描述进程的数据结构，保存与该进程有关的各种数据信息

##### 1、进程描述信息：进程标识符

##### 2、处理机状态信息：保存进程运行现场信息

##### 3、进程调度信息

##### 4、进程控制信息

#### 2、进程的唯一标识，每个进程在OS的登记表项

#### 3、进程创建时生成，终止时回收

#### 4、在内存核心区，系统调用间接访问

#### 5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表

##### OS怎么管理PCB进行进程调度？

###### 作业队列：所有进程集合

###### 就绪队列：就绪进程集合

###### 设备队列：等待I/O设备的进程集合

###### 令进程在各种不同的队列中迁移

##### PCB组织方式

###### 同一状态进程的PCB构成一个链表

###### 同一状态进程归入一个index表，由index指向PCB

### 2.2.2.     进程管理

#### 进程控制

##### 进程生命周期

###### 创建、运行、等待、唤醒、终止

##### 进程控制任务

###### 进程创建、终止、状态转变

##### 实现方式

###### OS内核原语实现

原语：若干条指令构成的原子操作

许多系统调用是原语，但不是全部

#### 进程创建

##### 引起创建的事件

###### 1、用户登录

###### 2、作业调度

###### 3、提供服务

###### 4、应用请求

##### 创建步骤（原语CREATE（））

###### 1、申请空白PCB

###### 2、为新进程分配资源

###### 3、初始化PCB

###### 4、将新进程插入就绪队列

#### 进程终止

##### 引起终止的事件

###### 1、正常结束

###### 2、异常结束

###### 3、外界干预

##### 终止步骤（原语EXIT（））

###### 1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态

###### 2、若处于执行状态，终止该进程，置调度标志为1，重新调度

###### 3、有子孙进程就终止

###### 4、进程资源归还给父进程或者系统

###### 5、进程PCB移出所在队列

#### 进程阻塞与唤醒

##### 引起阻塞与唤醒的事件

###### 1、请求系统共享资源服务

###### 2、启动某种操作（例如I/O）

###### 3、新数据尚未到达

###### 4、等待新任务的到达

##### 阻塞步骤（原语BLOCK（））

###### 1、保存当前进程的CPU现场

###### 2、置该进程状态（变为阻塞态）

###### 3、PCB进入等待队列

###### 4、转进程调度

##### 唤醒步骤（原语WAKEUP（））

###### 1、等待队列中摘下被唤醒进程

###### 2、置该进程状态（变为就绪态）

###### 3、进入就绪队列

###### 4、转进程调度或返回

#### 进程挂起与激活

##### 挂起

###### 挂起引入原因

1、终端用户请求

2、父进程请求

3、负荷调节需要

4、OS需要

###### 目的

合理且充分的利用系统资源

###### 挂起步骤（原语SUSPEND（））

1、从内存调到外存，改变进程状态

2、若活动就绪/阻塞，转为静止就绪/阻塞

3、若正在执行，则转向调度程序重新调度

##### 激活

###### 激活引入原因

1、终端用户请求

2、父进程请求

3、内存空间足够

###### 激活步骤（原语ACTIVE（））

1、从外存调到内存，改变进程状态

2、也可能引起处理机调度（比较被激活进程优先级和当前进程优先级）

## 2.3.     进程同步

### 2.3.1.     基本概念

#### 制约关系

##### 间接制约

###### 进程之间共享某种系统资源而形成的相互制约

##### 直接制约

###### 进程间由于合作形成的相互制约

#### 进程两大关系

##### 互斥

###### 由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权

##### 同步

###### 多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务

#### 临界资源

##### 一段时间内只允许一个进程访问的资源

#### 临界区

##### 每个进程访问临界资源的那段代码被称为临界区

### 2.3.2.     基本准则

#### 空闲则入

#### 忙则等待

#### 有限等待：不能死等

#### 让权等待：不能进入临界区的进程要释放CPU

### 2.3.3.     信号量机制

#### 1、整型信号量机制

#####  表示资源数目的整型量s和原子操作wait(s)+signal(s)

#### 2、记录型信号量机制

##### 信号量s

###### s.count:处置表示某类资源的数目

###### s.queue:阻塞在该信号量的各个进程的PCB链成的队列

##### 原子操作

###### wait():--s.count;if(s.count<0) block(s.queue);

###### signal():++s,count;if(s.count<=0) block(s.queue);

#### 3、AND型信号量

##### 基本思想

###### 将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放

##### 原子操作

###### Swait()

#### 4、二进制信号量

##### 信号量

###### S1=1；S2=0；C=代表共享资源的初始值

### 2.3.4.     信号量的应用

#### 1、信号量实现互斥

##### 设置互斥信号量mutex，初值为1

###### mutex=1，无进程进入临界区

###### mutex=0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列

###### mutex=-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒

##### 流程

###### wait(mutex)；临界区；signal(mutex)；剩余区

#### 2、信号量实现同步

##### 为每个前驱关系设置一个信号量

### 2.3.5.     经典的进程同步问题

#### 1、生产者消费者问题

#### 2、读者写者问题

#### 3、哲学家进餐问题

## 2.4.     进程通信

### 2.4.1.     基本概念：进程之间的信息交换

#### 低级通信

##### 效率低

##### 通信对用户不透明

##### 包括信号量和管程机制

#### 高级通信

##### 指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高

##### 使用方便；高效地传送大量数据

##### 包括下面三种系统

### 2.4.2.     进程通信类型

#### 1、共享存储器系统

##### 1、共享数据结构

###### 低级通信

##### 2、共享存储区

#### 2、消息传递系统

##### 系统提供一组通信原语

##### 实现方式

###### 直接通信

发送进程利用OS提供的发送原语把消息之间发送给目标进程

###### 间接通信

借助收发进程以外的共享数据结构（比如信箱）作为通信中转

#### 3、管道通信系统

##### 连接读写进程的一个共享文件，pipe文件

##### 必须提供的协调能力

###### 互斥

###### 同步

###### 确定对方是否存在，只有对方存在才能通信

## 2.5.     线程Thread简介

### 2.5.1.     定义

#### 进程当中的一条执行流程

### 2.5.2.     属性

#### 1、共享进程资源

#### 2、轻型实体：每个线程只拥有少量资源

#### 3、处理机调度的单位

#### 4、可并发执行

### 2.5.3.     优缺点

#### 优点

##### 1、一个进程可对应多个线程

##### 2、可并发执行

##### 3、创建和终止时间比进程短

##### 4、各个线程资源共享，可直接通信不通过OS内核

#### 缺点

##### 一个线程崩溃会导致所属进程的所有线程崩溃

### 2.5.4.     OS支持线程的方法

#### 1、用户级线程

##### 1、存在于用户空间，内核不了解

##### 2、应用进程利用线程库函数来控制用户线程

##### 3、一个线程阻塞，整个进程等待

##### 4、时间片分配给进程，线程多了每个线程执行时间相对就少

#### 2、内核线程

##### 1、OS支持，负责线程的创建、切换等操作

##### 2、线程的管理慢于用户级线程

##### 3、一个线程阻塞，整个进程不会阻塞

#### ps：多线程模型

##### 一对多

##### 一对一

##### 多对多

# 3.    三、处理机调度和死锁

## 3.1.     处理机调度算法的层次

### 3.1.1.     高级调度

#### 又称：长程调度或作业调度

#### 调度对象：作业（用户利用计算机进行一次运行所需工作的集合）

#### 主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列

#### 相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度

### 3.1.2.     低级调度

#### 进程调度或短程调度

##### 非抢先式调度

###### 拥有处理机的进程完成或阻塞时才把处理机分配给其他进程

##### 抢先式调度

###### 允许暂停拥有处理机的进程，重新分配处理机给另一个进程

###### 时间片原则；优先权原则

#### 调度对象：进程（或内核级线程）

#### 主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）

#### 相关系统：多道、分时、实时三种类型的OS中，都必须配置

### 3.1.3.     中级调度

#### 又称：内存调度

#### 使用目的：提高内存利用率和系统吞吐量

#### 主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态

## 3.2.     选择处理机调度方式和算法的准则

### 3.2.1.     面向用户

#### 周转时间短

##### 批处理系统的重要指标：作业从提交到完成（得到结果）

##### 平均周转时间：完成时间-提交时间

##### 平均带权周转时间：平均周转时间/CPU执行时间

#### 响应时间快

##### 分时系统的重要指标：输入请求到系统给出首次响应的时间

#### 保证截止时间

##### 实时系统的重要指标：开始截止时间和完成截止时间

#### 优先权原则

##### 批处理、分时、实时系统都可遵循

##### 公平性：不因为作业或进程本身特性而使上述指标恶化。

### 3.2.2.     面向系统

#### 系统吞吐量高

##### 批处理系统的重要指标

##### 吞吐量：单位时间内所完成的作业数

#### 处理机利用率高

#### 资源的平衡利用

### 3.2.3.     调度算法本身的调度性能准则

#### 易于实现

#### 执行开销比

## 3.3.     调度算法

### 3.3.1.     定义

#### 根据系统的资源分配策略所规定的资源分配算法

### 3.3.2.     分类

#### 先来先服务算法（FCFS）

##### 算法描述

###### 按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。

##### 特点

###### 利于长作业而不利于短作业

###### 利于CPU繁忙的作业而不利于I/O繁忙的作业

#### 短作业（进程）优先调度算法（SJF/SPF）

##### 算法描述

###### 对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式

###### 对FCFS的改进，目标减少平均周转时间

##### 特点

###### 优点

比FCFS改善平均周转时间和平均带权周转时间

提高系统吞吐量

###### 缺点

对长作业非常不利

未能根据作业的紧迫程度来划分执行的优先级

不能准确估计作业的执行时间，从而影响调度性能

##### 变型

###### 最短剩余时间优先（SRT）

允许抢占

###### 最高响应比优先（HRRN）

响应比=（等待时间+要求执行时间）/要求执行时间

FCFS和SJF的折衷

#### 优先权调度算法

##### 算法描述

###### 作业调度

算法用于作业调度时，系统从后备队列中选择优先权最高的作业装入内存

###### 进程调度

算法用于进程调度时，系统从就绪队列中选择优先权最高的作业派发处理机

###### 类型

抢占式和非抢占式，可抢占程度越高，对实时系统满足度越好

##### 优先权类型

###### 静态优先级

概念

依据进程类型、对资源需求、用户要求等在创建进程使就确定进程优先级，直到进程终止前都不改变

特点

简单，系统开销小

不精确，仅在要求不高的系统中使用

###### 动态优先级

概念

在创建时赋予的优先级可以在运行时改变，以便获得更好的调度性能

##### 高响应比优先调度算法（HRRN）

###### 特征

服务时间越短/等待时间越长，优先级越高

###### 缺点

响应比的计算增加系统开销

###### 响应比=（等待时间+要求执行时间）/要求执行时间

#### 时间片轮转法（RR）

##### 算法描述

###### 就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个

###### 设计目标：提高资源利用率

##### 时间片

###### 时间片长度的影响

太长：退化为FCFS

太短：响应时间长

###### 就绪进程越多，时间片越小

###### 系统的处理能力应当使用户输入通常在一个时间片内能处理完

#### 多队列调度算法

##### 算法描述

###### 设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长

###### 当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降

###### 较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾

##### 算法性能

###### 终端型进程（I/O）

最高优先级

###### 计算型进程（长批处理作业）

每次执行完时间片降低优先级

###### 短批处理作业

先放入最高级，一般1-2级完成

##### 优点

###### 为提高I/O资源利用率和缩短响应时间照顾I/O型进程

###### 为提高系统吞吐量和缩短平均周转时间而照顾短进程

###### 不用估计进程执行时间，动态调节

## 3.4.     实时调度

### 3.4.1.     基本条件

#### 1、提供必要信息

##### 就绪时间

##### 开始截止时间+结束截止时间

##### 处理时间

##### 资源要求

##### 优先级

#### 2、系统处理能力强

##### 单处理机

###### 处理时间Ci/周期时间Pi之和<=1

##### 多处理机

###### 处理时间Ci/周期时间Pi之和<=N

#### 3、抢占式调度机制

#### 4、快速切换机制

##### 对外部中断快速响应

##### 快速任务分配

### 3.4.2.     分类

#### 1、非抢占式调度算法

##### 1、非抢占式轮转调度算法：同RR

##### 2、非抢占式优先调度算法：严格按优先级

#### 2、抢占式调度算法

##### 1、基于时钟中断的抢占式优先权调度算法

###### 优先级低于当前任务就等待

##### 2、立即抢占

###### 立即响应外部中断

### 3.4.3.     常用实时调度算法

#### 1、最早截止时间优先（EDF）

##### 抢占/非抢占都可

###### 子主题

##### 非抢占式调度方式->非周期实时任务；抢占式调度方式->周期实时任务

#### 2、最低松弛度优先算法（LLF）

##### 主要可抢占

##### 松弛度越低（紧急度越高），优先级越高

##### 松弛度=必须完成时间-本身运行时间-当前时间

## 3.5.     死锁

### 3.5.1.     概念

#### 多个进程争夺资源造成的僵局

### 3.5.2.     死锁起因

#### 竞争资源

##### 概念：资源数目不能满足进程需要

##### 竞争不可抢占性资源/临时性资源

#### 顺序不当

##### 进程推进顺序不当

### 3.5.3.     产生死锁的必要条件（同时满足）

#### 1、互斥：任一个时刻只允许一个进程使用资源

#### 2、请求和保持：进程保持了至少一个资源，但又请求新的资源

#### 3、不可抢占：已占用资源不可被抢占

#### 4、环路等待

### 3.5.4.     处理死锁方法

#### 1、预防死锁

##### 概念：限制并发进程对资源的请求，使之不同时满足四个条件

##### 分类

###### 1、摒弃”请求保持“

预先静态分配法：预先分配全部资源，保证不等待

优点：简单、安全、容易实现

缺点：资源被严重浪费，降低了资源利用率，较低进程并发程度；有可能无法预先知道所有资源

###### 2、摒弃”不可剥夺“

进程保持了至少一个资源，但又请求新的资源但没得到满足时。立即释放所持有的资源

缺点

实现复杂，要付出代价

重复申请释放资源，降低系统吞吐率

###### 3、摒弃”环路等待“

有序资源使用法：资源分类按顺序排列，进程按顺序请求

缺点：

资源序号固定，限制新设备增加

降低资源利用率

限制用户简单自主的编程

#### 2、避免死锁

##### 概念：资源动态分配过程中，防止系统进入不安全状态

##### 系统安全状态

###### 按照安全序列为进程分配资源使每个进程都可以顺利完成

##### 银行家算法

###### 安全性算法

###### 特点：

允许互斥、部分分配和不可抢占，可提高资源利用率

要求事先说明最大资源要求，在现实中很困难

#### 3、检测死锁

##### 概念：允许系统进入死锁，但及时检测

##### 死锁定理：

###### S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程

###### 资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤

##### 死锁检测算法

##### 死锁检测算法的应用

#### 4、解除死锁

##### 概念：检测到死锁，采取措施解除

##### 方法

###### 终止进程

1、终止所有死锁进程，代价大、容易实现

2、一次只终止一个进程直到消除环路

###### 剥夺资源

选择一个牺牲者：代价最小

后退：退回到安全状态，重新启动进程/完全回滚，终止进程后重新开始

饿死：避免某进程”饿死“，增加一个元素：做牺牲品的次数

# 4.    四、存储器管理

## 4.1.     存储器的层次结构

### 4.1.1.     存储管理概念

#### OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存

#### 可执行存储器：寄存器+主存

### 4.1.2.     层次结构

#### CPU寄存器

##### 寄存器

###### CPU访问速度最快

#### 主存

##### 高速缓存

###### 备份主存常用数据；减少对主存访问速度

##### 主存储器

###### 保存进程运行时程序和数据，速度远低于处理机执行

##### 磁盘缓存

###### 备份磁盘常用数据，不是独立的存储器（是主存的部分空间）

#### 辅存

##### 固定磁盘

##### 可移动存储介质

## 4.2.     程序的装入和链接

### 4.2.1.     程序的处理步骤

#### 编译

##### 由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)

#### 链接

##### 由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE/DLL)

#### 装入

##### 由装入程序将装入模块(EXE/DLL)装入内存,成为进程

### 4.2.2.     程序的装入

#### 1、绝对装入

##### 概念

###### 编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码

##### 优缺点

###### 优点

装入过程简单

###### 缺点

依赖硬件结构，适用于单道而不适用于多道程序

#### 2、可重定位装入

##### 概念

###### 装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量

###### 地址变换装入时一次完成，进程不再移动，故称为静态重定位

##### 优缺点

###### 优点

不需要硬件支持，可放入多道程序

###### 缺点

一个程序装入需要连续的内存空间，装入后不能移动，不易共享

#### 3、动态运行时装入

##### 概念

###### 进程开始执行时部分装入，运行时需要哪个装哪个

##### 优缺点

###### 优点

可以将一个程序分散在不连续的内存空间中，可以移动，有利于共享

支持程序执行中的地址引用，比如指针变量

###### 缺点

需要硬件支持（通常指CPU），OS实现复杂，是虚拟存储的基础

### 4.2.3.     程序的链接

#### 静态链接

##### 概念

###### 程序运行前把目标模块和库函数直接链接，以后不再拆开

###### 解决的问题

修改相对地址；变换外部调用符号

##### 优缺点

###### 优点

简单易操作

###### 缺点

多用户、多任务冗余（库函数重复）

#### 装入时动态链接

##### 概念

###### 边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址

##### 优缺点

###### 优点

共享：多个进程共享一个模块

便于修改更新

#### 运行时动态链接

##### 概念

###### 将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上

##### 优缺点

###### 优点

部分装入

局部代码修改

便于适应运行环境

###### 缺点

链接开销

管理开销

## 4.3.     连续分配存储管理方式

### 4.3.1.     单一连续分配

#### 概念

##### 内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间

#### 优缺点

##### 优点

###### 最简单，适用于单用户、单任务，易于管理

##### 缺点

###### 不常用的进程也占用内存

###### 对要求内存空间少的进程，造成内存浪费

### 4.3.2.     固定分区分配

#### 概念

##### 划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）

#### 优缺点

##### 优点

###### 易于实现，开销小

##### 缺点

###### 内碎片浪费，分区总数固定，限制了并发执行的程序数目

#### 内碎片

##### 分区之内未利用空间

#### 外碎片

##### 分区之间空闲分区（通常是小空闲分区）

### 4.3.3.     动态分区分配

#### 概念

##### OS根据进程的实际需要为各进程分配连续的内存空间

#### 数据结构

##### 1、空闲分区表

##### 2、空闲分区链表

#### 动态分区算法分类

##### 1、首次适应算法（first-fit）

###### 概念：按分区先后次序查找

###### 优点：分配和释放时间性能较好，空闲分区多分布在内存高端

###### 缺点：查找时间会逐渐增大

##### 2、循环首次适应算法（next-fit）

###### 概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针

###### 优点：分配和释放时间性能较好，空闲分区分布均匀

###### 缺点：较大的空闲分区不宜保留

##### 3、最佳适应算法（best-fit）

###### 概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区

###### 优点：速度较快，可以保留较大的空闲分区

###### 缺点：会形成较多外碎片

##### 4、最坏适应法（worst-fit）

###### 概念：空闲分区表按从大到小排序，找到最大的空闲分区

###### 优点：基本不留下小空闲分区

###### 缺点：较大的空闲分区不被保留

##### 5、快速适应算法

###### 概念：

空闲分区根据容量分类，每类分区容量相同

1、设置空闲分区链表分别指向每类分区

2、管理索引表指向每类空闲分区链表表头

###### 优点：查找效率高，能保留较大分区

###### 缺点：回收分区时开销大；空闲分区划分越细，浪费越严重

##### 6、伙伴系统

###### 概念

动态分区分配和固定分区分配的折衷方案

规定分配的分区和空闲分区大小都是2的k次方，1<=k<=m

算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间

分区回收方法：由伙伴碎片就合并，继而又有伙伴碎片，持续往下合并

###### 优点：

快速搜索合并；外碎片少

###### 缺点：

内部碎片多

按2的幂划分可能产生的内碎片大

#### 分区分配操作

##### 分配内存

###### 利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区

##### 回收内存

###### 1、与前一个空闲分区相邻

###### 2、与后一个空闲分区相邻

###### 3、与前、后空闲分区相邻

###### 4、不与空闲分区相邻

### 4.3.4.     动态重定位分区分配

#### 1、紧凑

##### 各个占用分区向内存一端移动，使空闲分区合并在另一端

##### 何时执行紧凑

###### 每个分区释放后、或者内存分配找不到满足条件的空闲分区时

#### 2、动态重定位

##### 不用修改程序，用新起始地址置换原来的起始地址即可

#### 3、动态重定位分区分配算法

##### 找得到按动态分区方式分配

##### 找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回

## 4.4.     覆盖

### 4.4.1.     引入目标

#### 在较小内存运行较大的程序，常与固定分区配合

### 4.4.2.     原理

#### 程序的几个代码段和数据段按时间顺序先后占用同一内存空间

##### 1、必要部分常驻内存

##### 2、不常用部分其他程序模块实现，平时在外存，要用调入内存

##### 3、不存在调用关系的模块不提示调入内存，可以相互覆盖

### 4.4.3.     缺点

#### 增加了编程复杂度：程序员必须了解程序模块之间的划分关系

#### 外存覆盖内存速度慢，时间换空间

## 4.5.     对换

### 4.5.1.     概念

#### 将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进/滚出（roll-in/roll-out）

#### 交换单位

##### 整个进程的地址空间

### 4.5.2.     原理

#### 换入

##### OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入

#### 换出

##### 内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存

### 4.5.3.     优缺点

#### 优点

##### 增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率

#### 缺点

##### 对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性

### 4.5.4.     与覆盖对比

#### 1、交换不要求程序员了解程序段之间的覆盖结构

#### 2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行

#### 3、覆盖只能覆盖与覆盖程序段无关的程序段

## 4.6.     离散分配存储管理方式

### 4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销

### 4.6.2.     分页存储管理方式

#### 概念

##### 将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB

##### 内存空间划分为和页对应大小的块，称为物理块或页框

##### 页和块一一对应，由页面映像表记录

#### 进程装载

##### 装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。

##### 要解决地址映像，需要硬件支持

#### 数据结构

##### 进程页表：

###### 每个进程一个进程页表，描述进程每个页对应的页框

##### 物理页面表

###### 描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表

##### 请求表

###### 描述系统内各个进程页表的位置和大小，用于地址转换

###### 请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号

#### 逻辑地址结构

##### 逻辑页号（m-n）+页内偏移量（n位）

##### 逻辑地址空间2的m次方，页框大小2的n次方

#### 优缺点

##### 优点

###### 没有外碎片，内碎片大小不超过页大小

###### 程序不必连续存放，便于改变程序占用空间的大小

##### 缺点

###### 程序全部装入内存

#### 地址变换机构

##### 基本地址变换机构

###### 逻辑地址=逻辑页号+页内偏移地址

###### 物理地址=页框号+页框内偏移地址

###### 根据页号查进程页表转换为页框号，页内偏移地址=页框内偏移地址

##### 具有快表的地址变换机构

###### 大多数页表存储在内存中，需访问两次

第一次读取页表

第二次访问数据

###### 联想（关联）存储器（快表TLB）

具有并行查找功能的高速缓冲寄存器

根据程序局部性原理，将页表的一部分放在里面（8~32个）

###### 地址变换步骤

1、首先查找快表，直接命中生成物理地址，访存一次

2、不命中查找内存，置换页表再生成，访存两次

#### 两级和多级页表

##### 引入原因

###### 页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法

###### 分散存储

将页表分页，每个页面大小与物理页框大小相同，解决难以找到连续的物理内存的问题

##### 两级页表

###### 定义

增加页表的页表（外层页表），也叫页目录表，存放页表起始地址

###### 逻辑地址结构

外层页号（页表目录）+外存页内地址（页表）+页内地址

###### 访存次数

3次

##### 多级页表

###### 定义

增加多个页表的页表（外层页表）

###### 访存次数

n+1

###### 计算方法：

把逻辑地址转换为二进制，根据每位0/1查找页表，加上页内偏移地址就是对应的物理地址了（PPT27）

##### 反置页表

###### 定义

每个进程一张页表，页表按照进程的逻辑地址顺序排序，内容位物理块号（页框号）

###### 检索方式

根据进程id和页号检索

###### 特点

系统只有一张页表，每个物理页框在页表中只有一项

访问查页表速度慢，可能需要查找整张表

不易于实现页面共享

### 4.6.3.     分段存储管理方式

#### 概念

##### 按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始

##### 程序划分为数据段、代码段、和共享段，可以分别编写编译

#### 特征

##### 方便编程

##### 分段共享

##### 分段保护

###### 根据不同类型的段采取不同的保护措施

##### 动态链接

###### 进程开始时只装入主模块，运行时再根据需要装入其他模块

##### 动态增长

###### 比如数据段可能根据需要增大

#### 数据结构

##### 进程段表：

###### 每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长

##### 系统段表

###### 描述每个占用段的分配使用情况

##### 空闲段表

###### 描述每个空闲段，可以结合到系统段表中

#### 逻辑地址结构

##### 段号（m-n）+段内地址（n位）

#### 优缺点

##### 优点

###### 没有内碎片，外碎片可以紧凑来消除

###### 程序不必连续存放，便于改变程序占用空间的大小

##### 缺点

###### 程序全部装入内存

#### 地址变换机构

##### 基本地址变换机构

###### 逻辑地址=段号S+段内地址d

###### 段表寄存器=段表始地址f+段表长度TL

###### 段表=段长SL+段基址d

###### 步骤

1、比较段号S和段表长度TL，若S>TL，访问越界，产生越界中断信号

2、未越界：根据段表始地址f和段号S，计算该段对应段表项的位置，从而读出该段在内存的起始地址

3、比较段内地址d是否超过该段段长SL，若d>SL,访问越界，产生越界中断信号

4、未越界，段基址d与段内地址d相加得到物理地址

##### 具有快表的地址变换机构

#### 分页和分段的主要区别

##### 1、单位：页是物理单位，段是逻辑单位。

##### 2、目的：分页目的是系统管理，分段目的是用户需要

##### 3、大小：页大小系统固定，段不固定

##### 4、地址空间：分页一维（页号），分段二维（段号+段内地址）

##### 5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度

##### 6、共享：分段方便共享代码

#### 信息共享

##### 能共享的代码必须是可重入代码

##### 可重入代码：

###### 允许多个进程同时访问，代码执行时不允许修改

##### 调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量

### 4.6.4.     段页式存储管理方式

#### 概念

##### 段内分页，先将用户程序分为若干段，每个段再分为若干页

#### 数据结构

##### 每个进程一张段表，每个段一张页表。

##### 段表=段表大小+段表首地址

##### 页表=段号+段内页号+页内偏移量

#### 地址变换机构

##### 暂定

# 5.    五、虚拟存储器

## 5.1.     虚拟存储器概述

### 5.1.1.     问题

#### 前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入

### 5.1.2.     常规存储管理方式特征

#### 1、一次性

#### 2、程序的驻留性

##### 装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用

### 5.1.3.     定义

#### 是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统

#### 借助于外存空间，允许一个进程在其运行过程只部分装入

#### 虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和

#### 对用户透明，用户地址空间称为虚存空间或虚地址空间

### 5.1.4.     工作过程

#### 1、进程部分装入

#### 2、执行时内容不在内存（缺页/缺段），请求调入

#### 3、若此时内存已满，请求置换

### 5.1.5.     好处

#### 1、较小的内存可以运行较大的进程

#### 2、容纳更多进程并发执行

#### 3、不影响编程的程序结构（和覆盖不同）

#### 4、提供的虚拟内存空间大于物理内存

### 5.1.6.     局部性原理

#### 指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域

#### 1、时间局部性

##### 循环结构

###### 指令/数据的执行/访问局限在较短时期

#### 2、空间局部性

##### 顺序执行

###### 访问的地址局限在一定范围内（例如·数组）

#### 具体实现

### 5.1.7.     实现方式

#### 分页请求系统

##### 纯分页系统+请求调页+页面置换——页面虚拟存储器

##### 1、硬件支持

###### 1、页表增加项

###### 2、缺页中断

###### 3、地址变换机构

##### 2、实现请求分页的软件

#### 请求分段系统

##### 纯分段系统+请求调段+分段置换——段式虚拟存储器

##### 1、硬件支持

###### 1、段表增加项

###### 2、缺段中断

###### 3、地址变换机构

##### 需要CPU、MMU支持，段页式

### 5.1.8.     特征

#### 1、多次性

##### 进程/作业多次调度

#### 2、对换性

#### 3、虚拟性

##### 逻辑地址空间>实际物理内存

#### 4、离散性

##### 进程的物理空间不连续

## 5.2.     请求分页存储器管理方式

### 5.2.1.     概念

#### 在基础分页存储管理基础上增加请求调页和页面置换功能

#### 基本单位：长度固定的页

#### ps:虚拟存储是最常用的实现方式

### 5.2.2.     硬件支持

#### 1、进程页表：增加项

##### 1、状态位：在内存还是外存

##### 2、修改位：该页是否修改过

##### 3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔

##### 4、外存地址：磁盘地址

#### 2、缺页中断机构

##### 概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序

##### 缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）

#### 3、地址变换机构

##### 在原基础上增加缺页中断，具体看PPT29

### 5.2.3.     内存分配

#### 1、最小物理块数的确定

##### OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行

##### 进程运行最小页框数和指令系统有关

###### 1、单地址+直接寻址

2个页面

###### 2、间接寻址

3个页面

###### 3、如swap A，B 

至少6个

#### 2、物理块的分配策略

##### 1、固定分配局部置换

###### 每个进程分配固定页框

###### 缺页从该进程所属页框调出旧页面，换出新页面

###### 困难点：

分配多少页框合适

多了内存可装入进程减少

少了缺页中断频繁

##### 2、可变分配全局置换（最易实现）

###### 每个进程分配固定页框，OS控制一定数量的空闲页框

###### 缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框

###### 困难点：

不公平

##### 2、可变分配局部置换

###### 每个进程分配固定页框，OS控制一定数量空闲页框

###### 缺页先计算缺页中断率

中断率低：从该进程所属页框调出旧页面，换出新页面

中断率高：OS给该进程分配空闲页框

###### 困难点：

统计缺页中断率增加系统开销

#### 3、物理块的分配算法

##### 1、平均分配

##### 2、按比例分配

##### 3、按优先权分配

## 5.3.     页面调入

### 5.3.1.     页面调入策略

#### OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入

#### 1、何时调入

##### 1、预调页

###### 缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）

##### 2、请求调页

###### 缺页只调缺的这一页

#### 2、何处调入

##### 1、进程运行前

###### 全部页面从文件区调入交换区，以后都从交换区调

##### 2、运行中

###### 未被修改的页面一直从文件区调

###### 被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区

##### 3、UNIX方式

###### 未运行的页面一直从文件区调

###### 运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区

### 5.3.2.     页面调入过程

#### PPT30

### 5.3.3.     页面调入算法

#### 功能

##### 内存满时，选择内存中哪个页面置换

#### 目标

##### 降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”

#### 页面锁定

##### OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志

#### 分类

##### 1、最佳置换算法（OPT）

###### 选择“以后不用的”或”离当前位置最远的“页面置换

###### 理想情况，不能实现，只作为评价依据

##### 2、先进先出置换算法（FIFO）

###### 选择“建立最早”页面置换

###### 方法

链表表示建立时间先后

###### 缺点：

性能较差，较早进入的页一般也是经常访问的页

可能有Belady现象

###### Belady现象：

OS分配N个内存给进程，对一个访问序列S，N增大时，缺页次数PE（S，N）时而增大，时而减小

现象原因：FIFO置换特征与进程访问内存动态特征矛盾，即，置换页面并不是进程不会访问的

##### 3、最近最久未使用置换算法（LRU）

###### 利用最近的过去预测最近的将来，选择“最久未使用”页面置换

###### 方法：

记录首次访问以来过去的时间t

###### 缺点：

由于记录使用时间，增加系统硬件开销

###### 硬件机构

1、设立栈：被访问的页面挪到栈顶，于是栈底是最久未访问页面

2、页面设立移位寄存器：被访问时左边最高位置1，短期右移且最高位补0，寄存器值最小则为最久未访问页面

##### 4、Clock置换算法

###### 又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合

###### 一、简单Clock置换算法

方法：

每页设置访问标志位A，被访问过置1

步骤：

1、按照FIFO算法，寻找A=0做置换页，同时途中改A=1的页为A=0；

2、若所有页面都检查过，回到开头重新开始

3、最后指针停放在置换页的下一页

###### 二、改进Clock置换算法

方法：

每页设置访问标志位A和修改位M，被访问或修改过置1

步骤：

1、按照FIFO算法，寻找A=0，W=0做置换页，不改A=0；

2、按照FIFO算法，寻找A=0，W=1做置换页，更改A=0；

3、还没找到，回到1、2继续找，这回一定找得到

##### ps：其他置换算法

###### 5、最少使用置换算法（LFU）

又称最不常用算法

选择“最少访问”页面置换

方法：

设置访问计数器，计算访问次数

缺页中断时调入值最小的页面并清空所有计数器

###### 6、页面缓冲算法（PB）

FIFO的发展，有机会回收刚被置换的页面

方法：设置两个链表

空闲页面链表

已修改页面链表

步骤：

被置换页面未修改，直接归入空闲列表末尾；否则归入已修改链表

调入新页，新页内容读入空闲列表第一项，删除第一项

已修改页面在达到一定值时，一次性写回外存；此期间有被再次访问的页，可以直接在内存调入，减少I/O访问次数

## 5.4.     抖动与工作集

### 5.4.1.     缺页率与页框数

#### 缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点

### 5.4.2.     工作集

#### 概念

##### w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合

#### 性质

##### 随△单调递增

##### 局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值

#### 引入目的

##### 依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来

#### 步骤：

##### OS跟着进程们，分配给进程大于工作集的帧数

##### 有空闲帧，启动另一个进程

##### 如果所有工作集之和大于帧总数，OS选择挂起某个进程

#### 优点

##### 工作集防止了抖动，提高了程序并发度

#### 困难

##### 过去预测未来可能不准确

##### 记录工作集变化增加了开销，开销大

##### △取值难以优化，而且通常该值不断改变

### 5.4.3.     抖动

#### 概念

##### 每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动

#### 产生原因

##### 随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）

##### 因此要选个合适的进程数目

#### 预防方法

##### 1、引入工作集算法

##### 2、挂起若干进程

##### 3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I/O等待队列中）

##### 4、L=S准则：产生缺页的时间L=系统处理缺页的平均时间S，此时CPU利用率最好

## 5.5.     请求分段存储器管理方式

### 5.5.1.     概念

#### 在基础分段存储管理基础上增加请求调段和段置换功能

#### 基本单位：长度不固定的段

### 5.5.2.     硬件支持

#### 1、进程页表：增加项

##### 1、存取方式：只执行、只读、读/写

##### 2、增补位：是否动态增长

##### 其他和请求分页一样

#### 2、缺段中断机构

##### 分段越界中断处理；分段保护中断处理；缺段中断处理

#### 3、地址变换机构

##### 在原基础上增加缺段中断，具体看PPT32

### 5.5.3.     分段共享

#### 数据结构

##### 共享段表

###### 系统中配置一张，所有共享段在该表中都有一项PPT32

#### 共享段的分配与回收

##### 1、分配

###### 首次用共享段，调入内存，填写共享段表项，置共享进程计数count=1

###### 其他进程使用，count++

##### 2、回收

###### 修改共享段表，count=0

###### 将该段占用内存回收

##### 另外，共享段一般不放入外存

### 5.5.4.     分段保护

#### 1、越界检查

#### 2、存取控制检查

#### 3、环保护机构

##### 低环有高优先权，OS在0环

##### 访问调用原则

###### 一个程序可访问相同环或低优先权环的数据

###### 一个程序可调用相同环或高优先权环的数据

# 6.    六、设备管理

## 6.1.     设备管理概述

### 6.1.1.     概念

#### OS中负责I/O设备管理的部分叫做I/O系统，完成设备管理功能，对OS影响非常大

#### 设备管理是最繁杂且与硬件关联最紧密的部分

### 6.1.2.     主要对象

#### I/O设备，设备控制器，I/O通道

### 6.1.3.     基本任务

#### 完成用户I/O请求，提高I/O效率，提高I/O设备利用率

### 6.1.4.     主要功能

#### 缓存区管理；设备分配/管理；虚拟存储；实现设备独立性

## 6.2.     I/O系统概述

### 6.2.1.     I/O系统组成

#### I/O设备，设备控制器及接口，I/O通道，总线等

### 6.2.2.     I/O设备类型

#### 1、按传输速率

##### 低/中/高速

#### 2、按信息交换单位

##### 块设备——数据块为单位

##### 字符设备——字符为单位

#### 3、按设备共享属性

##### 独占

##### 共享

##### 虚拟

###### 虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用

### 6.2.3.     设备与控制器之间的接口

#### 设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备

#### 控制器与设备传递的信号

##### 1、数据信号：控制器->设备

##### 2、控制信号：控制器->设备

##### 3、状态信号：设备->控制器

## 6.3.     设备管理目标

### 6.3.1.     1、提供统一界面，方便用户使用

### 6.3.2.     2、发挥系统并行性，提高I/O使用效率

### 6.3.3.     3、设备保护：实现设备的正确安全使用

## 6.4.     缓冲管理

### 6.4.1.     概念

#### 缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域

### 6.4.2.     引入缓冲区原因

#### 1、处理数据的生产者和消费者速度不匹配

#### 2、协调传输速度不一致的设备

#### 3、减少CPU中断频率

#### 4、提高CPU和I/O设备之间的并行性

### 6.4.3.     缓冲区分类

#### 单缓冲

##### 一个缓冲区，CPU外设轮流使用

#### 双缓冲区

##### 两个缓冲区，CPU和外设处理速度相近，可以连续处理

#### 循环缓冲

##### 环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大

#### 缓冲池

##### 分类

###### 1、空闲缓冲区队列emq

###### 2、输入缓冲区队列inq

###### 3、输出缓冲区队列outq

##### 操作

###### 1、收容输入

设备输入data

###### 2、提取输入

计算机读入data

###### 3、收容输出

计算机输出data

###### 4、提取输出

向设备输出data

## 6.5.     I/O软件

### 6.5.1.     设计目标

#### 高效性

##### 确保I/O设备与CPU并发性，提高资源利用率

#### 通用性

##### 提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作

### 6.5.2.     采用方式

#### 抽象、包装、软件分层

### 6.5.3.     应达到的目标

#### 1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射

#### 2、统一命令

#### 3、对错误的处理：尽可能低层处理，不涉及高层

#### 4、缓冲技术

#### 5、设备的分配和回收

#### 6、I/O控制方式：不同设备的控制方式不同

### 6.5.4.     层次结构

#### 1、用户空间软件

##### 用户层软件必须通过一组系统调用获取OS服务

#### 2、与设备无关的OS软件（无关层）

##### 设备独立性概念

###### 基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件

###### 设备独立性软件设置在驱动程序之上，界限因OS的不同而不同

###### 使应用程序独立于物理设备

##### 实现方式

###### 1、引入物理设备、逻辑设备

###### 2、应用程序通过逻辑设备名调用设备，OS负责转换

##### 设备独立性好处

###### 1、设备分配的灵活性

###### 2、实现I/O重定向：实现I/O操作的设备可更换，而不用改变应用程序

##### 设备独立性软件功能

###### 1、执行所有设备的公有操作

###### 2、向用户层软件提供统一接口

##### 逻辑设备映射到物理设备的方式

###### 1、逻辑设备表LUT

逻辑设备名+物理设备名+驱动程序入口地址

###### 2、LUT的实现可以采用两种方式

整个系统一张（逻辑设备名不能相同）；每个用户一张，放入PCB中

#### 3、设备驱动程序（驱动层）

##### 处理过程

###### 1、抽象要求转具体要求

###### 2、检查I/O请求合法性

###### 3、读出和检查设备状态

###### 4、传送参数

###### 5、设置工作方式

###### 6、启动I/O设备

##### 特点

###### 1、I/O请求进程与设备控制器之间的桥梁，中转数据和控制

###### 2、与I/O设备特性、控制方式、硬件密切相关

###### 3、向上屏蔽设备细节

###### 4、驱动程序允许可重入

#### 4、中断处理程序

#### 5、硬件

#### ps：

##### 功能上看，无关层为I/O管理的主要部分

##### 代码量上看，驱动层为I/O管理的主要部分

### 6.5.5.     设备分配与回收

#### 设备分配

##### 数据结构

###### 1、系统设备表SDT

###### 2、设备控制表DCT

###### 3、控制器控制表COCT

###### 4、通道控制表CHCT

##### 考虑因素

###### 1、设备固有属性

独享；共享；虚拟设备

###### 2、设备分配算法

先来先服务（FCFS）

基于优先级

###### 3、设备分配的安全性

安全分配方式：进程发出I/O后阻塞，不占用OS资源

不安全分配方式：多个设备并行操作；可能造成死锁

##### 独占设备的分配程序

###### 1、分配设备

###### 2、分配控制器

###### 3、分配通道

#### SPOOLing技术（假脱机）

##### 概念

###### 联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机

###### 联机I/O，主机直接控制I/O

###### 脱机I/O，一台外围机控制器代替主机控制I/O

###### SPOOLing用联机I/O模拟脱机I/O工作

##### 原理

###### SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序

###### SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设

###### 以上称为实际I/O

###### 缓冲池中读入和读出就不是实际I/O

##### 组成

###### 1、输入井和输出井：在磁盘

###### 2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾

###### 3、输入进程和输出进程：守护进程

##### 优点

###### 1、高速虚拟I/O操作

###### 2、实现独享设备的共享

###### 3、SPOOLing程序提供虚拟设备

## 6.6.     磁盘调度

### 6.6.1.     磁盘存储器管理

#### 磁盘存储器：随机读写、共享设备，可移动介质

#### 特点：容量大，速度快

#### 管理要求：合理分配空间，访问效率高。容错强。

#### 其性能直接影响文件系统的性能指标

### 6.6.2.     磁盘性能

#### 数据的组织

##### 地址格式：驱动器号+磁道号+磁头号+扇区号

#### 磁盘类型

##### 固定头磁盘；移动头磁盘

#### 磁盘访问时间

##### 寻道时间+旋转延迟时间+传输时间

##### 寻道时间是主要影响参数

#### 提高速度的途径

##### 1、硬件解决

##### 2、好的调度算法

###### 减少寻道时间

##### 3、缓冲区

### 6.6.3.     调度算法

#### 1、先来先服务

##### 执行顺序为磁盘I/O请求先后顺序

#### 2、最短寻道时间优先（SSTF）

##### 选择距当前磁头移动最少的磁盘I/O请求

##### 不能保证平均寻道时间最短，进程可能饿死

#### 3、扫描算法（SCAN）

##### （电梯调度算法）选择当前磁头前进方向上移动距离最少的I/O请求，没有前进方向的请求才改变方向

##### SSTF的改进，没有进程饿死

#### 4、循环扫描算法（CSCAN）

##### 选定一个方向扫描，到末尾再返回最里欲访问的磁道

##### 负载或重负载时，磁盘I/O性能比扫描算法好

#### 5、N-Step-SCAN算法

##### 磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法

##### 目标

###### 解决磁臂黏着问题

#### 6、FSCAN调度算法

##### 磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法

##### 目标

###### 解决磁臂黏着问题

### 6.6.4.     磁盘高速缓存

#### 概念

##### 利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存

#### 1、磁盘高速缓存形式

##### 大小固定

##### 未利用的内存空间组成缓冲池

#### 2、数据交付方式

##### 1、磁盘高速缓存中的数据直接传送到请求进程的内存区

##### 2、磁盘高速缓存中的数据指针传送到请求进程的内存区

#### 3、置换算法

##### LRU/NRU/最少使用算法

#### 如何保持数据的一致性

##### 备用电源

##### OS定期回写

### 6.6.5.     提高磁盘I/O速度的其他方法

#### 1、提前读

#### 2、延迟写

#### 3、优化物理块的分布

#### 4、虚拟盘

# 7.    七、文件管理

## 7.1.     文件管理概述

### 7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能

## 7.2.     数据分类

### 7.2.1.     数据项

#### 基本数据项

#### 组合数据项

### 7.2.2.     记录

#### 一组相关数据项的集合，由于描述一个对象在某方面的属性

### 7.2.3.     文件

#### 创建者定义，具有文件名的一组相关元素的集合

#### 文件体（文件本身信息）+文件属性（文件存储和管理信息）

#### 文件属性：类型/长度/物理位置/建立时间

## 7.3.     文件系统

### 7.3.1.     文件类型

#### 1、用途

##### 系统文件

##### 用户文件

##### 库文件

#### 2、数据形式

##### 源文件（ASCII/汉字）

##### 目标文件（obj）

##### 可执行文件（exe）

#### 3、存取控制属性

##### 只执行文件

##### 只读文件

##### 读写文件

#### 4、组织形式和处理方式

##### 普通文件

##### 目录文件

##### 特殊文件

###### 各类I/O设备

### 7.3.2.     文件系统层次结构

#### 从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口

#### 对象及其属性

##### 文件/目录/磁盘存储空间

#### 对对象操纵和管理的软件集合(核心）

##### 功能

###### 1、文件存储空间管理

###### 2、文件目录管理

###### 3、文件逻辑地址和物理地址的转换

###### 4、文件读和写管理

###### 5、文件共享和保护

#### 文件系统接口

##### 1、命令接口

##### 2、程序接口

### 7.3.3.     文件操作

#### 创建create

#### 删除delete

#### 打开open

#### 关闭close

#### 读写read/write

#### 截断：文件长度=0

#### 设置读写位置

#### 其他（以系统调用方式提供）

##### 1、文件属性相关

##### 2、有关目录操作

##### 3、文件共享

### 7.3.4.     文件逻辑结构

#### 又称文件的组织，是指从用户观点出发观察到的文件组织形式

#### 设计要求

##### 访问性能

###### 便于检索，便于修改

##### 存储性能

###### 转换方便，节省空间

#### 类型

##### 是否有结构

###### 有结构文件

定长记录

记录长度相同

变长记录

各记录长度不同

###### 无结构文件

文件长度以字节为单位，读、写指针访问下一个字符

##### 组织形式划分

###### 顺序文件

顺序排列，定长或变长都可

排列方式

1、串结构

存入时间决定顺序

2、顺序结构

按关键字排序，效率更高

读写方式

1、定长：ptr=ptr+L

2、变长：ptr=ptr+Li

优缺点

优点

批量处理数据

缺点

单个记录处理困难

###### 索引文件

建立一张索引表，每个记录对应一个索引项

###### 索引顺序文件

建立一张索引表，将顺序文件中的·记录分为若干组，每组第一个记录对应一个索引项

###### ps：直接文件：

键值直接对应物理地址

###### ps：哈希文件

哈希函数根据键值计算相对位置，再根据相对位置得到内容

访问速度最快，但有空闲空间浪费

### 7.3.5.     文件物理结构

#### 文件的存储结构，指文件在外存的组织形式

#### 目的

##### 1、提高存储空间的利用率

##### 2、提高文件的访问速度

#### 分配方式

##### 1、连续分配

###### 每个文件分配一组相邻接的盘块

###### 主要问题

随着使用磁盘碎片增多，性能下降，需要整理

###### 优点

访问速度快，定位容易，只需记录第一个簇的位置，可通过紧凑合并外存空闲空间

###### 缺点

需要连续空间，需要事先知道文件长度

##### 2、链接分配

###### 隐式分配

不连续，每个簇中有指向下一个簇的指针，目录存放第一个簇和最后一个簇的指针

优点

解决了连续分配的问题

缺点

随机访问效率差，可靠性差

###### 显式分配

不连续，指针单独存放在文件分配表（FAT）中与文件对应的目录项存放文件首块的地址

##### 3、索引分配

###### 单级索引

###### 多级索引

###### 混合方式

## 7.4.     目录管理

### 7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址

### 7.4.2.     实现目标

#### 按名存取

#### 快速检索

#### 文件共享

#### 文件重名的解决

### 7.4.3.     文件控制块FCB

#### 文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项

#### 包含信息

##### 1、基本信息类

##### 2、存取控制信息类

##### 3、使用信息类

### 7.4.4.     索引结点

#### 引入

##### 文件名和文件描述信息分开存放，将FCB拆分为两部分

##### 1、文件目录部分

###### 文件名+索引结点编号（指针）

##### 2、I结点

###### 除文件名以外的数据结构

#### 磁盘索引节点

##### 指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node

#### 内存索引结点

##### 文件打开后，磁盘上的I-node拷贝到内存，以便使用

### 7.4.5.     目录结构

#### 1、单级目录

#### 2、两级目录

#### 3、多级目录（树）

#### 4、无环图目录

#### 4、通用图目录

## 7.5.     文件存储空间管理

### 7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况

### 7.5.2.     方式

#### 1、空闲表法

##### 首次/下次适应，最佳/最坏

##### 连续分配（一般），首次适应（算法）

##### 序号+第一空闲盘块号+空闲盘块数

#### 2、空闲链表法

##### 空闲簇有指向下一个空闲簇的指针

##### 两种形式

###### 空闲簇链接

###### 空闲区链接

除指向下一个指针，还指明本盘区大小

#### 3、位示图

##### 每一位表示一个簇，0和1表示空闲和占用

#### 4、成组链接法

##### 栈底放盘块数

##### 栈底上面一个存放一组空闲盘块

## 7.6.     文件共享

### 7.6.1.     1、硬链接

#### 文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针

### 7.6.2.     2、符号链接

## 7.7.     文件保护

### 7.7.1.     1、文件不受物理损坏/2、避免文件被非法访问

### 7.7.2.     常用方法:

#### 根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问

#### ACL方法的缺点

##### 每个文件ACL过长，事先无法知道系统用户的列表

##### 原来固定大小的文件目录条目，现在必须可变，空间管理复杂化

#### 精简ACL的方法

##### 每个文件三种类型用户

###### 拥有者：创建文件的用户

###### 组：可访问者

###### 其他用户