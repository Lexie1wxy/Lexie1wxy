<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bootstrap</title>
    <url>/2020/07/07/Bootstrap/</url>
    <content><![CDATA[<h2 id="什么是-Bootstrap？"><a href="#什么是-Bootstrap？" class="headerlink" title="什么是 Bootstrap？"></a>什么是 Bootstrap？</h2><p>Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。</p>
<h2 id="Bootstrap-包的内容"><a href="#Bootstrap-包的内容" class="headerlink" title="Bootstrap 包的内容"></a>Bootstrap 包的内容</h2><ul>
<li><p><strong>基本结构</strong>：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。这将在 <strong>Bootstrap 基本结构</strong> 部分详细讲解。</p>
</li>
<li><p><strong>CSS</strong>：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。这将在 <strong>Bootstrap CSS</strong> 部分详细讲解。</p>
</li>
<li><p><strong>组件</strong>：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。这将在 <strong>布局组件</strong> 部分详细讲解。</p>
</li>
<li><p>JavaScript 插件</p>
<p>：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。这将在</p>
</li>
</ul>
<p>  Bootstrap 插件</p>
<p>  部分详细讲解。</p>
<ul>
<li><strong>定制</strong>：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis逆向工程</title>
    <url>/2020/07/10/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Mybatis逆向工程简介"><a href="#Mybatis逆向工程简介" class="headerlink" title="Mybatis逆向工程简介"></a>Mybatis逆向工程简介</h2><p>MyBatis逆向工程是指用数据库的表直接生成Java代码，利用MyBatis官方提供的逆向工程，可以针对单表自动生MyBatis执行所需要的代码（如pojo实体类，mapper接口和mapper.xml）。</p>
<h2 id="MAVEN配置步骤"><a href="#MAVEN配置步骤" class="headerlink" title="MAVEN配置步骤"></a>MAVEN配置步骤</h2><h3 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1 pom.xml"></a>1 pom.xml</h3><p><strong>——————只需要改一下项目名和generator.xml的路径就行</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MybatisGenerator01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--配置文件的路径--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-在src-main-resource目录下新建配置文件generatorConfig-xml"><a href="#2-在src-main-resource目录下新建配置文件generatorConfig-xml" class="headerlink" title="2 在src/main/resource目录下新建配置文件generatorConfig.xml"></a>2 在src/main/resource目录下新建配置文件generatorConfig.xml</h3><p><strong>————————更改表名和想要的包的路径</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入属性配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"generator.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"$&#123;jdbc.driverLocation&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"default"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--jdbc的数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">"$&#123;jdbc.connectionURL&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">"$&#123;jdbc.userId&#125;"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类</span></span><br><span class="line"><span class="comment">            targetPackage     指定生成的model生成所在的包名</span></span><br><span class="line"><span class="comment">            targetProject     指定在该项目下所在的路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.slx.zsxt.model"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对model添加 构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.slx.zsxt.mapper"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码</span></span><br><span class="line"><span class="comment">                type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象</span></span><br><span class="line"><span class="comment">                type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象</span></span><br><span class="line"><span class="comment">                type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.slx.zsxt.dao"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--以下example为false，表示不会生成example类，否则将自动生成example类</span></span><br><span class="line"><span class="comment">        &lt;table schema="" tableName="%"</span></span><br><span class="line"><span class="comment">               enableCountByExample="false"</span></span><br><span class="line"><span class="comment">               enableUpdateByExample="false"</span></span><br><span class="line"><span class="comment">               enableDeleteByExample="false"</span></span><br><span class="line"><span class="comment">               enableSelectByExample="false"</span></span><br><span class="line"><span class="comment">               selectByExampleQueryId="false"&gt;</span></span><br><span class="line"><span class="comment">        &lt;/table&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user"</span> <span class="attr">domainObjectName</span>=<span class="string">"User"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"userlogin"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserLogin"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"role"</span> <span class="attr">domainObjectName</span>=<span class="string">"Role"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"student"</span> <span class="attr">domainObjectName</span>=<span class="string">"Student"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加properties文件"><a href="#3-添加properties文件" class="headerlink" title="3 添加properties文件"></a>3 添加properties文件</h3><p><strong>————————driver的路径可以在idea直接复制maven仓库里jar包的绝对路径（要改反斜线）</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverLocation</span>=<span class="string">D:/tools/Maven/apache-maven-3.5.2-bin/repository/mysql/mysql-connector-java/5.1.35/mysql-connector-java-5.1.35.jar</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.connectionURL</span>=<span class="string">jdbc:mysql://localhost:3306/examination_system?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">jdbc.userId</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<h3 id="4-添加Maven运行查看是否成功生成"><a href="#4-添加Maven运行查看是否成功生成" class="headerlink" title="4 添加Maven运行查看是否成功生成"></a>4 添加Maven运行查看是否成功生成</h3><p><strong>————————Edit Configuration</strong>           </p>
<p><strong>Parameters页面——&gt;name填项目名——&gt;Command line填 mybatis-generator:generate -e</strong></p>
<p> <strong>——&gt; Apply——&gt;OK</strong></p>
<p><img src="../images/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20200710174745474.png" alt="image-20200710174745474"></p>
<h3 id="5-成功"><a href="#5-成功" class="headerlink" title="5 成功"></a>5 成功</h3><p><strong>————————生成的项目结构</strong></p>
<p><img src="../images/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/image-20200710175237234.png" alt="image-20200710175237234"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Html</title>
    <url>/2020/07/05/Html/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Html和CSS、JavaScript的关系，学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的：</p>
<ol>
<li>HTML是网页内容的载体，是名词。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。</li>
<li>CSS样式是表现。就像网页的外衣，是形容词。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。</li>
<li>JavaScript是用来实现网页上的特效效果，是动词。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。</li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HyperText Markup Language，全名为超文本标记语言，这里的<strong>超文本</strong>指的是<strong>超链接</strong>。HTML 是用来描述网页的一种语言。HTML 是一种在 Web 上使用的通用标记语言。HTML 允许你格式化文本，添加图片，创建链接、输入表单、框架和表格等等，并可将之存为文本文件，浏览器即可读取和显示，HTML文档也叫做 web 页面</p>
<p>ps： HTML标签不区分大小写，<h1>和<H1>是一样的，但建议小写，因为大部分程序员都以小写为准。</p>
<h2 id="标准结构"><a href="#标准结构" class="headerlink" title="标准结构"></a>标准结构</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span>     声明文档类型为 HTML5 文档</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>         HTML根标签,元素是 HTML 页面的根元素</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>         头标签元素包含了文档的元（meta）数据，如 <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> 定义网页编码格式为 utf-8（由于在大部分浏览器中直接输出中文会出现乱码，所以要在头部将字符声明为UTF-8）</span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>...<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span>&gt;</span>元素可提供有关页面的元信息（meta-information）,必需属性content定义与 http-equiv 或 name 属性相关的元信息</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span>...<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span>...<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>         主题标签</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 元素定义一个大标题</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 元素定义一个段落</span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="各种标签"><a href="#各种标签" class="headerlink" title="各种标签"></a>各种标签</h2><h3 id="1-标题段落标签"><a href="#1-标题段落标签" class="headerlink" title="1 标题段落标签"></a>1 标题段落标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--我是一个注释--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">我是换行<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">我是水平线<span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;p&gt;和&lt;br/&gt;标签的不同是：&lt;p&gt;标签自动换行，并生成空白行而&lt;br/&gt;不会生成空白行。--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-文本标签及格式化"><a href="#2-文本标签及格式化" class="headerlink" title="2 文本标签及格式化"></a>2 文本标签及格式化</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">“6”</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span>我是一句话<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>更小的文本<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>重要的文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>计算机代码<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调文本<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体文本<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>键盘输入<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>预格式化文本<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span>&gt;</span> （缩写）<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span> （联系地址，显示斜体）<span class="tag">&lt;/<span class="name">address</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bdo</span>&gt;</span> （文字方向）<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>（短文本引用）<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> （长文本引用）<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span> （工作的名称）<span class="tag">&lt;/<span class="name">cite</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span> （删除的文本）<span class="tag">&lt;/<span class="name">del</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span> （插入的文本）<span class="tag">&lt;/<span class="name">ins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span> （下标文本）<span class="tag">&lt;/<span class="name">sub</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span> （上标文本）<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-链接"><a href="#3-链接" class="headerlink" title="3 链接"></a>3 链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">普通的链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/"</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">图像链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.example.com/"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">alt</span>=<span class="string">"替换文本"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">邮件链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:webmaster@example.com"</span>&gt;</span>发送e-mail<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">书签：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"tips"</span>&gt;</span>提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tips"</span>&gt;</span>跳到提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4 图片"></a>4 图片</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">alt</span>=<span class="string">"替换文本"</span> <span class="attr">height</span>=<span class="string">"42"</span> <span class="attr">width</span>=<span class="string">"42"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-样式-区块"><a href="#5-样式-区块" class="headerlink" title="5 样式/区块"></a>5 样式/区块</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文档中的块级元素,换行，文档布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文档中的内联元素，不换行，组合行内元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6 列表"></a>6 列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>定义列表——项目 1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>定义列表——项目 2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7 表格"></a>7 表格</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">*jyICLegw1qm</span><br></pre></td></tr></table></figure>

<h3 id="8-框架"><a href="#8-框架" class="headerlink" title="8 框架"></a>8 框架</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--iframe 用于在网页内显示网页。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-表单"><a href="#9-表单" class="headerlink" title="9 表单"></a>9 表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--HTML 表单用于搜集不同类型的用户输入。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo_form.php"</span> <span class="attr">method</span>=<span class="string">"post/get"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;input&gt; 元素————最重要的表单元素。</span></span><br><span class="line"><span class="comment">1、type：指定input类型</span></span><br><span class="line"><span class="comment">2、name：为文本框命名，以备后台程序ASP 、PHP使用。</span></span><br><span class="line"><span class="comment">3、value：为文本输入框设置默认值。(一般起到提示作用)--&gt;</span></span><br><span class="line">单行文本框:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"text1"</span> <span class="attr">size</span>=<span class="string">"40"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--单选多选框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>   <span class="attr">type</span>=<span class="string">"radio/checkbox"</span>   <span class="attr">value</span>=<span class="string">"值"</span>    <span class="attr">name</span>=<span class="string">"名称"</span>   <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、type:</span></span><br><span class="line"><span class="comment">   当type="radio"时，控件为单选框</span></span><br><span class="line"><span class="comment">   当type="checkbox"时，控件为复选框</span></span><br><span class="line"><span class="comment">2、value：提交数据到服务器的值（后台程序PHP使用）</span></span><br><span class="line"><span class="comment">3、name：为控件命名，以备后台程序ASP、PHP使用</span></span><br><span class="line"><span class="comment">4、checked：当设置checked="checked"时，该选项被默认选中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"sing"</span>&gt;</span>唱歌</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"dance"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span>跳舞</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"basketball"</span>&gt;</span>打球</span><br><span class="line">单选按钮：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">submit定义用于向表单处理程序（form-handler）提交表单的按钮。<span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Send"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">密码输入框：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello World!')"</span>&gt;</span>我是个按钮，点我!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--HTML 表单用于搜集不同类型的用户输入。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo_form.php"</span> <span class="attr">method</span>=<span class="string">"post/get"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--&lt;datalist&gt; 元素为 &lt;input&gt; 元素规定预定义选项列表。</span></span><br><span class="line"><span class="comment">用户会在他们输入数据时看到预定义选项的下拉列表。</span></span><br><span class="line"><span class="comment">&lt;input&gt; 元素的 list 属性必须引用 &lt;datalist&gt; 元素的 id 属性。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Opera"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Safari"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;select&gt; 元素定义下拉列表： multiple可以多选ctrl+单击</span></span><br><span class="line"><span class="comment">语法：&lt;option value="提交值"&gt;选项&lt;/option&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--&lt;textarea&gt; 元素定义多行输入字段（文本域）,cols 限制每行最多输入字符数,rows 限制输入的行数：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-实体"><a href="#10-实体" class="headerlink" title="10 实体"></a>10 实体</h3><p><strong>HTML 中的预留字符必须被替换为字符实体</strong></p>
<p><img src="/../images/Html/image-20200705163639943.png" alt="image-20200705163639943"></p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>Html</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/07/01/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><h3 id="搭建整合环境"><a href="#搭建整合环境" class="headerlink" title="搭建整合环境"></a>搭建整合环境</h3><p>原博客<a href="https://blog.csdn.net/qq_44543508/article/details/100192558" target="_blank" rel="noopener">https://blog.csdn.net/qq_44543508/article/details/100192558</a></p>
<h4 id="整合说明"><a href="#整合说明" class="headerlink" title="整合说明"></a>整合说明</h4><p>XML+注解</p>
<h4 id="整合的思路："><a href="#整合的思路：" class="headerlink" title="整合的思路："></a>整合的思路：</h4><p>1、搭建整合的环境</p>
<p>2、Spring的配置搭建完成</p>
<p>3、再使用Spring整合SpringMVC框架</p>
<p>4、之后使用Spring整合MyBatis框架</p>
<p>5、最后spring整合mybatis框架配置事务（Spring的声明式事务管理）</p>
<h4 id="创建数据库和表结构语句："><a href="#创建数据库和表结构语句：" class="headerlink" title="创建数据库和表结构语句："></a>创建数据库和表结构语句：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create database ssm;</span><br><span class="line">use ssm;</span><br><span class="line"><span class="function">create table <span class="title">account</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span> primary key auto_increment,</span></span></span><br><span class="line"><span class="function"><span class="params">name varchar(<span class="number">50</span>)</span>,</span></span><br><span class="line"><span class="function">money <span class="keyword">double</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建maven的工程"><a href="#创建maven的工程" class="headerlink" title="创建maven的工程"></a>创建maven的工程</h4><ol>
<li><p>创建Twossm父工程（打包方式选择pom，必须的）</p>
<p>不勾选模块，删除src,更改pom的<packaging>标签</p>
<p><font color="red"><strong><em>创建java jar、pom项目时创建maven-archetype-quickstart</em></strong></font></p>
<p><font color="red"><strong><em>创建java war项目时创建maven-archetype-webapp</em></strong></font></p>
</li>
<li><p>创建Twossm_web子模块（打包方式是war包）</p>
<p>父工程下new-&gt;module-&gt;选择webapp模块创建，更改pom的<packaging>标签</p>
</li>
<li><p>创建Twossm_service子模块（打包方式是jar包）</p>
<p>父工程下new-&gt;module-&gt;选择quickstart模块创建，更改pom的<packaging>标签</p>
</li>
<li><p>创建Twossm_dao子模块（打包方式是jar包）—-同上</p>
</li>
<li><p>创建Twossm_domain子模块（打包方式是jar包）</p>
<p><em>web依赖于service，service依赖于dao，dao依赖于domain</em></p>
</li>
<li><p>在Twossm_parent的pom.xml文件中引入坐标依赖<br>找到对应的&lt; properties &gt;标签，以及&lt; dependencies &gt;标签，复制粘贴即可<br>版本控制是在&lt; properties &gt;标签中控制，从坐标依赖中可以看出版本号：spring5X、MySQL5.1.44、mybatis3.4.5</p>
</li>
<li><p>部署Twossm_web的项目，只要把Twossm_web项目加入到tomcat服务器中即可</p>
<p>这一段后边都改了，直接创建一个工程就行，其他子模块改成包</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本控制--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--添加依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- log start --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- log end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编写实体类：Twossm-domain项目"><a href="#编写实体类：Twossm-domain项目" class="headerlink" title="编写实体类：Twossm_domain项目"></a>编写实体类：Twossm_domain项目</h4><ol>
<li>首先介绍一些快捷键：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IDEA查找接口的实现类： ctrl + alt +B </span><br><span class="line">IDEA快速实现接口： Alt + Shift + P （很常用，基本上一实现接口就得用）</span><br><span class="line">Get&#x2F;Set&#x2F;toString方法快捷键：Esc</span><br><span class="line">自动补全返回值类型的快捷键：Ctrl + Alt+ V</span><br><span class="line">快速生成语句快速生成Main()方法: psvm + 回车 （老铁，是不是更习惯main+Alt+&#x2F; ？）</span><br><span class="line">快速生成输出语句: sout + 回车 (其实我想说我也喜欢syso，Alt+&#x2F; )</span><br><span class="line">内容提示,代码补全键：Ctrl+Alt+空格</span><br><span class="line">格式化代码：Ctrl+Alt+L</span><br><span class="line">查找所有，你没看错是所有：Shift + Shift</span><br><span class="line">自由切换：Ctrl+Tab</span><br><span class="line">删除整行：Ctrl+X</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后编写数据表对应的实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写dao接口"><a href="#编写dao接口" class="headerlink" title="编写dao接口"></a>编写dao接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountdao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写service接口和实现类"><a href="#编写service接口和实现类" class="headerlink" title="编写service接口和实现类"></a>编写service接口和实现类</h4><p>例如：IAccountService 以及  AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询所有账户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存帐户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service业务层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Service业务层：保存帐户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里整合环境就搭建好了，现在开始搭建Spring的配置</p>
<h2 id="Spring框架代码的编写"><a href="#Spring框架代码的编写" class="headerlink" title="Spring框架代码的编写"></a>Spring框架代码的编写</h2><h3 id="创建resources的资源文件目录管理XML配置文件"><a href="#创建resources的资源文件目录管理XML配置文件" class="headerlink" title="创建resources的资源文件目录管理XML配置文件"></a>创建resources的资源文件目录管理XML配置文件</h3><p>Mark Directory as—&gt;Resources Root</p>
<h3 id="编写applicationContext-xml的配置文件"><a href="#编写applicationContext-xml的配置文件" class="headerlink" title="编写applicationContext.xml的配置文件"></a>编写applicationContext.xml的配置文件</h3><p>resources—&gt;New—&gt;File—–&gt;applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gx"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些注解不扫描--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>记得一起加个log4j.properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout, R</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pattern to output the caller's file name and line number.</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] (%F:%L) - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.R.File</span>=<span class="string">example.log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R.MaxFileSize</span>=<span class="string">100KB</span></span><br><span class="line"><span class="comment"># Keep one backup file</span></span><br><span class="line"><span class="meta">log4j.appender.R.MaxBackupIndex</span>=<span class="string">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.R.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.R.layout.ConversionPattern</span>=<span class="string">%p %t %c - %m%n</span></span><br></pre></td></tr></table></figure>

<h3 id="在项目中编写测试方法，进行测试"><a href="#在项目中编写测试方法，进行测试" class="headerlink" title="在项目中编写测试方法，进行测试"></a>在项目中编写测试方法，进行测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">"accountService"</span>);</span><br><span class="line">        as.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC框架代码的编写"><a href="#SpringMVC框架代码的编写" class="headerlink" title="SpringMVC框架代码的编写"></a>SpringMVC框架代码的编写</h2><h3 id="在web-xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码"><a href="#在web-xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码" class="headerlink" title="在web.xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码"></a>在web.xml中配置DispatcherServlet前端控制器以及DispatcherServlet过滤器解决中文乱码</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--加载springmvc.xml配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--启动服务器，创建该servlet--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--解决中文乱码的过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="resources文件夹下创建springmvc-xml的配置文件"><a href="#resources文件夹下创建springmvc-xml的配置文件" class="headerlink" title="resources文件夹下创建springmvc.xml的配置文件"></a>resources文件夹下创建springmvc.xml的配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描，只扫描Controller注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置的视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/css"</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/js/"</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启SpringMVC注解的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建jsp页面"><a href="#创建jsp页面" class="headerlink" title="创建jsp页面"></a>创建jsp页面</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href="account/findAll"&gt;测试SpringMVC查询&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编写controller代码"><a href="#编写controller代码" class="headerlink" title="编写controller代码"></a>编写controller代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/account/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Controller表现层：查询所有账户..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;  <span class="comment">//在视图解析器中配置了前缀后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳转界面jsp"><a href="#跳转界面jsp" class="headerlink" title="跳转界面jsp"></a>跳转界面jsp</h3><p>WEB-INF—-&gt;pages—-&gt;list.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Bule</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">9</span>/<span class="number">2</span></span><br><span class="line">  Time: <span class="number">7</span>:<span class="number">32</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">            &lt;h2&gt;查询所有的账户&lt;/h2&gt;</span><br><span class="line">          </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="部署Tomcat进行测试"><a href="#部署Tomcat进行测试" class="headerlink" title="部署Tomcat进行测试"></a>部署Tomcat进行测试</h3><p>测试成功就说明搭建好了<del>~</del></p>
<h2 id="Spring整合SpringMVC的框架"><a href="#Spring整合SpringMVC的框架" class="headerlink" title="Spring整合SpringMVC的框架"></a>Spring整合SpringMVC的框架</h2><h3 id="Spring整合SpringMVC的框架原理分析"><a href="#Spring整合SpringMVC的框架原理分析" class="headerlink" title="Spring整合SpringMVC的框架原理分析"></a>Spring整合SpringMVC的框架原理分析</h3><p>整合成功的表现：</p>
<ol>
<li>在controller（SpringMVC）中能成功的调用service（Spring）对象中的方法。</li>
</ol>
<p>要想在controller中调用service方法，就要注入service到controller中来，有service对象才可以调用service方法，方法是这样没有错，但是有一个问题:</p>
<p>就是启动Tomcat之后试想一下，在web.xml中配置有前端控制器，web容器会帮我们加载springmvc.xml配置文件，在springmvc.xml配置文件中我们配置情况是只扫描controller，别的不扫，而spring.xml文件就从头到尾没有执行过，spring中的配置扫描自然也不会去扫描，就相当于没有将spring交到IOC容器当中去。</p>
<p>所以，现在的解决方案就是，在启动服务器时就加载spring配置文件,怎么实现呢？这时候监听器listener就派上用场了，具体实现如下：</p>
<p><img src="/../images/SSM%E6%95%B4%E5%90%88/20190902171005382.png" alt="img"></p>
<h3 id="在web-xml中配置ContextLoaderListener监听器"><a href="#在web-xml中配置ContextLoaderListener监听器" class="headerlink" title="在web.xml中配置ContextLoaderListener监听器"></a>在web.xml中配置ContextLoaderListener监听器</h3><p>在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文件）。要想加载applicationContext.xml的配置文件有两种方法</p>
<p>第一种（不建议）：把applicationContext.xm配置文件配置到WEB-INF目录下</p>
<p>第二种（强烈建议）：在web.xml中配置加载路径(方便管理和维护)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置配置文件的路径--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="controller中注入service对象，调用service对象方法并测试"><a href="#controller中注入service对象，调用service对象方法并测试" class="headerlink" title="controller中注入service对象，调用service对象方法并测试"></a>controller中注入service对象，调用service对象方法并测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.gx.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>   <span class="comment">//按类型注入</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/account/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Controller表现层：查询所有账户..."</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; list = accountService.findAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，总算是整合完了spring、springmvc，同学你还能看到这里，我也挺欣慰的哈哈，手动再给你点个赞，接下来编写MyBatis环境惹！</p>
<h2 id="MyBatis框架代码的编写"><a href="#MyBatis框架代码的编写" class="headerlink" title="MyBatis框架代码的编写"></a>MyBatis框架代码的编写</h2><p>一看到Mybatis，就要想到dao，没错，MyBatis环境搭建首先是dao，搭建mybatis，之前要编写mapper映射的配置文件，其实挺麻烦的，所以选择使用注解！</p>
<h3 id="在IAccountdao接口方法上添加注解，编写SQL语句"><a href="#在IAccountdao接口方法上添加注解，编写SQL语句" class="headerlink" title="在IAccountdao接口方法上添加注解，编写SQL语句"></a>在IAccountdao接口方法上添加注解，编写SQL语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>  <span class="comment">//此注解代表这是一个持久层，用法类似@controller、@service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountdao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from account"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into account (name,money) value(#&#123;name&#125;,#&#123;money&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建SqlMapConfig-xml的配置文件并编写"><a href="#创建SqlMapConfig-xml的配置文件并编写" class="headerlink" title="创建SqlMapConfig.xml的配置文件并编写"></a>创建SqlMapConfig.xml的配置文件并编写</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///ssm?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用的是注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper class="com.gx.dao.IAccountdao"/&gt; --&gt;</span> <span class="comment">&lt;!-- 该包下所有的dao接口都可以使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.gx.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/SSM%E6%95%B4%E5%90%88/20190902181214119.png" alt="img"></p>
<h3 id="创建并编写Mybatis测试方法"><a href="#创建并编写Mybatis测试方法" class="headerlink" title="创建并编写Mybatis测试方法"></a>创建并编写Mybatis测试方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gx.dao.IAccountdao;</span><br><span class="line"><span class="keyword">import</span> com.gx.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyBatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Account account =<span class="keyword">new</span> Account();</span><br><span class="line">        account.setName(<span class="string">"杜永蓝"</span>);</span><br><span class="line">        account.setMoney(<span class="number">200</span>d);</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">// 创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        <span class="comment">// 创建SqlSession对象</span></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line">        <span class="comment">// 获取到代理对象</span></span><br><span class="line">        IAccountdao dao = session.getMapper(IAccountdao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存</span></span><br><span class="line">        dao.saveAccount(account);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        session.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">        SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line"></span><br><span class="line">        SqlSession session = factory.openSession();</span><br><span class="line"></span><br><span class="line">        IAccountdao dao = session.getMapper(IAccountdao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Account&gt; list = dao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Account account: list ) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这Mybatis框架搭建完成；</p>
<h2 id="Spring整合MyBatis框架"><a href="#Spring整合MyBatis框架" class="headerlink" title="Spring整合MyBatis框架"></a>Spring整合MyBatis框架</h2><h3 id="Spring整合MyBatis的框架原理分析"><a href="#Spring整合MyBatis的框架原理分析" class="headerlink" title="Spring整合MyBatis的框架原理分析"></a>Spring整合MyBatis的框架原理分析</h3><p>Spring整合MyBatis框架之前，先想一想，怎样才算整合成功呢？</p>
<p>其实，这和之前的spring整合springMVC的套路差不多，其实就是，Service能成功调用dao对象，能够做查询操作或者新增数据能存进数据库。</p>
<p>现在spring已经是在IOC容器中了，dao是一个接口，可以通过程序帮这个接口生成代理对象，我们要是可以把这个代理对象也放进IOC容器，那么service就可以拿到这个对象，之后在service中做一个注入，service从而调用dao代理对象的方法，那么我们怎么去实现dao接口生成的代理对象放入IOC容器呢？其实很简单，只需要如下操作！</p>
<p><strong>整合目的：把SqlMapConfig.xml配置文件中的内容配置到applicationContext.xml配置文件中</strong></p>
<h3 id="在applicationContext-xml中配置数据库连接池"><a href="#在applicationContext-xml中配置数据库连接池" class="headerlink" title="在applicationContext.xml中配置数据库连接池"></a>在applicationContext.xml中配置数据库连接池</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring整合MyBatis框架--&gt;</span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql:///ssm?useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"user"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在applicationContext-xml中配置SqlSessionFactory工厂"><a href="#在applicationContext-xml中配置SqlSessionFactory工厂" class="headerlink" title="在applicationContext.xml中配置SqlSessionFactory工厂"></a>在applicationContext.xml中配置SqlSessionFactory工厂</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--配置SqlSessionFactory工厂--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"sqlSessonFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在applicationContext-xml中配置IAccountdao接口所在包"><a href="#在applicationContext-xml中配置IAccountdao接口所在包" class="headerlink" title="在applicationContext.xml中配置IAccountdao接口所在包"></a>在applicationContext.xml中配置IAccountdao接口所在包</h3><p>因为工厂有了，SqlSession也有了，那代理谁呢，所以我们要配置IAccountdao接口所在包，告诉SqlSession去代理接口所在包中的代理，从而存到IOC容器中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--配置IAccountdao接口所在包--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"mapperScanner"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.gx.dao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小结上面的三个配置"><a href="#小结上面的三个配置" class="headerlink" title="小结上面的三个配置"></a>小结上面的三个配置</h3><p>其实，上面的操作就是<strong>把mybatis中的配置（SqlMapConfig.xml）转移到spring中去，让它产生代理并存到IOC容器中</strong>！</p>
<h3 id="完善Service-Controller层代码，完善list-jsp页面"><a href="#完善Service-Controller层代码，完善list-jsp页面" class="headerlink" title="完善Service/Controller层代码，完善list.jsp页面"></a>完善Service/Controller层代码，完善list.jsp页面</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Bule</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">9</span>/<span class="number">2</span></span><br><span class="line">  Time: <span class="number">7</span>:<span class="number">32</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;查询所有的账户&lt;/h2&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"account"</span>&gt;</span><br><span class="line">    $&#123;account.name&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>界面跳转成功就说明ssm框架整合成功啦！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>快犒劳一下自己！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>最后一步！！！！！！！！！</p>
<h2 id="spring整合mybatis框架配置事务（Spring声明式事务管理）"><a href="#spring整合mybatis框架配置事务（Spring声明式事务管理）" class="headerlink" title="spring整合mybatis框架配置事务（Spring声明式事务管理）"></a>spring整合mybatis框架配置事务（Spring声明式事务管理）</h2><p>在整合spring、mybatis测试的时候（TestMybatis中），新增数据保存的时候会手动的提交过事务session.commit()，如果不写这一句，就会出现数据没提交的情况，因此为了完美的整合ssm，我们必须配置Spring的声明式事务管理！</p>
<h3 id="在applicationContext-xml中配置Spring框架声明式事务管理"><a href="#在applicationContext-xml中配置Spring框架声明式事务管理" class="headerlink" title="在applicationContext.xml中配置Spring框架声明式事务管理"></a>在applicationContext.xml中配置Spring框架声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring框架声明式事务管理--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--配置AOP增强--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.gx.service.Impl.*ServiceImpl.*(..))"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="完善index-jsp页面"><a href="#完善index-jsp页面" class="headerlink" title="完善index.jsp页面"></a>完善index.jsp页面</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/save"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    姓名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;&lt;br/&gt;</span><br><span class="line">    金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> /&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="完善Service层、Controller层代码"><a href="#完善Service层、Controller层代码" class="headerlink" title="完善Service层、Controller层代码"></a>完善Service层、Controller层代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Service业务层：保存帐户..."</span>);</span><br><span class="line">    iaccountdao.saveAccount(account);  <span class="comment">//调用service中的saveAccount(account)方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/account/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account, HttpServletRequest request, HttpServletResponse response)</span> throws IOException </span>&#123;</span><br><span class="line">    accountService.saveAccount(account);</span><br><span class="line">    response.sendRzedirect(request.getContextPath()+<span class="string">"/account/findAll"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p>完lalalalalala！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<h3 id="源码、源码、源码"><a href="#源码、源码、源码" class="headerlink" title="源码、源码、源码~"></a>源码、源码、源码~</h3><p>链接：<a href="https://pan.baidu.com/s/1rJ5zy1cMuiHYvFHz1wFuOg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rJ5zy1cMuiHYvFHz1wFuOg</a><br>提取码：yjx3 </p>
]]></content>
      <categories>
        <category>框架</category>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/07/06/JavaScript/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Html和CSS、JavaScript的关系，学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的：</p>
<ol>
<li>HTML：提供网页的结构，提供网页中的内容</li>
<li>CSS: 用来美化网页</li>
<li>JavaScript: 可以用来控制网页内容，给网页增加动态的效果</li>
</ol>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="1-JavaScript定义"><a href="#1-JavaScript定义" class="headerlink" title="1 JavaScript定义"></a>1 JavaScript定义</h2><p>JavaScript是一种运行在<strong><em>客户端</em></strong> 的<strong><em>脚本语言</em></strong><br>JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</p>
<h2 id="2-JavaScript组成"><a href="#2-JavaScript组成" class="headerlink" title="2 JavaScript组成"></a>2 JavaScript组成</h2><p><img src="/../images/JavaScript/20190411102957329.png" alt="img"></p>
<p>（1）核心（ECMAScript）：这一部分主要是js的基本语法。</p>
<p>（2）BOM：Brower Object Model（浏览器对象模型），主要是获取浏览器信息或操作浏览器的，例如：浏览器的前进与后退、浏览器弹出提示框、浏览器地址栏输入网址跳转等操作等。</p>
<p>（3）DOM：Document Object Model（文档对象模型），此处的文档暂且理解为html，html加载到浏览器的内存中，可以使用js的DOM技术对内存中的html节点进行修改，用户从浏览器看到的是js动态修改后的页面。（增删改查）</p>
<h2 id="3-特点："><a href="#3-特点：" class="headerlink" title="3 特点："></a>3 特点：</h2><ol>
<li>交互性（它可以做的就是信息的动态交互）</li>
<li>安全性（不允许直接访问本地硬盘）</li>
<li>跨平台性（只要是可以解析js的浏览器都可以执行，和平台无关）</li>
</ol>
<h2 id="4-与java区别"><a href="#4-与java区别" class="headerlink" title="4 与java区别"></a>4 与java区别</h2><p><img src="/../images/JavaScript/20180921084329128.png" alt="img"></p>
<h2 id="5-作用"><a href="#5-作用" class="headerlink" title="5 作用"></a>5 作用</h2><p>JavaScript 被用来改进设计、验证表单、检测浏览器、创建cookies，等等。JavaScript 是因特网上最流行的脚本语言，并且可在所有主要的浏览器中运行。</p>
<p>在目前学习阶段只要记住最常用的二个：（1）动态修改html及css代码 （2）验证表单</p>
<h1 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h1><p>HTML 中的脚本必须位于 &lt; script&gt; 与 &lt; /script&gt; 标签之间。</p>
<p>脚本可被放置在 HTML 页面的 &lt; body&gt; 和 &lt; head&gt; 部分中。</p>
<h2 id="内嵌式："><a href="#内嵌式：" class="headerlink" title="内嵌式："></a>内嵌式：</h2><p>理论上js可以书写在页面的任意位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">alert(<span class="string">"内嵌式"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="外链式："><a href="#外链式：" class="headerlink" title="外链式："></a>外链式：</h2><p>首先新建一个文件类型为.js的文件，然后在该文件中写js语句，通过script标签对引入到html页面中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js文件路径地址"</span>&gt;这里不能写js语句&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="行内式："><a href="#行内式：" class="headerlink" title="行内式："></a>行内式：</h2><p>直接书写在标签身上，是一个简写的事件，所以又称之为事件属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onclick单击事件</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"点我呀!"</span> onclick=<span class="string">"alert('点我干啥!^6^');"</span>&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"alert('恭喜你,中 500 万.');"</span>&gt;点我呀!&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>JavaScript 没有任何打印或者输出的函数。</p>
<p>JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li>使用 <strong>window.alert()</strong> 弹出警告框。</li>
<li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li>
<li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li>
<li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="javascipt-字面量"><a href="#javascipt-字面量" class="headerlink" title="javascipt 字面量"></a>javascipt 字面量</h2><p>在编程语言中，一个字面量是一个常量，如 3.14。</p>
<p><strong>数字（Number）字面量</strong> 可以是整数或者是小数，或者是科学计数(e)；</p>
<p><strong>字符串（String）字面量</strong> 可以使用单引号或双引号 ；</p>
<p><strong>表达式字面量</strong> 用于计算；</p>
<p><strong>数组（Array）字面量</strong> 定义一个数组；</p>
<p><strong>对象（Object）字面量</strong> 定义一个对象；</p>
<p><strong>函数（Function）字面量</strong> 定义一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a * b;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h2><p>在编程语言中，变量用于存储数据值。JavaScript 变量的生命期从它们被声明的时间开始。</p>
<p>局部变量会在函数运行以后被删除。</p>
<p>全局变量会在页面关闭后被删除。</p>
<p>JavaScript 使用关键字 <strong>var</strong> 来定义变量， 使用等号来为变量赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名称 = 存储的数据; (variable 变量)</span><br><span class="line">数值型：<span class="keyword">var</span> i = <span class="number">1</span>;	<span class="keyword">var</span> d = <span class="number">2.35</span>;</span><br><span class="line">字符串：<span class="keyword">var</span> str = <span class="string">"用心学习"</span>;</span><br><span class="line">布尔型：<span class="keyword">var</span> b = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JavaScript/1470709911288582.gif" alt="img"></p>
<h2 id="JavaScript-操作符"><a href="#JavaScript-操作符" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+	-	*	<span class="regexp">/	%	++	--</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>由于js中的小数和整数都是number类型，不存在类似整数除以整数还是整数的结论。</li>
<li>字符串和其他的数据使用+号运算，会连接成一个新的字符串。</li>
<li>字符串使用除了+以外的运算符：如果字符串本身是一个数字，那么会自动转成number进行运算<br>，否则就会返回一个NaN的结果，表示这不是一个数字。NaN：not a number</li>
</ol>
<h3 id="关系（比较）运算符"><a href="#关系（比较）运算符" class="headerlink" title="关系（比较）运算符"></a><strong>关系（比较）运算符</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;		&gt;=		&lt;		&lt;=  	!=		</span><br><span class="line">==	等于（只比较内容）	===	恒等于（比较内容的同时还要比较数据类型）</span><br><span class="line">注意：关系运算符返回的结果只有两个：<span class="literal">true</span> / <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="算术运算符-1"><a href="#算术运算符-1" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+	-	*	<span class="regexp">/	%	++	--</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>由于js中的小数和整数都是number类型，不存在类似整数除以整数还是整数的结论。</li>
<li>字符串和其他的数据使用+号运算，会连接成一个新的字符串。</li>
<li>字符串使用除了+以外的运算符：如果字符串本身是一个数字，那么会自动转成number进行运算<br>，否则就会返回一个NaN的结果，表示这不是一个数字。NaN：not a number</li>
</ol>
<h3 id="关系（比较）运算符-1"><a href="#关系（比较）运算符-1" class="headerlink" title="关系（比较）运算符"></a><strong>关系（比较）运算符</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;		&gt;=		&lt;		&lt;=  	!=		</span><br><span class="line">==	等于（只比较内容）	===	恒等于（比较内容的同时还要比较数据类型）</span><br><span class="line">注意：关系运算符返回的结果只有两个：<span class="literal">true</span> / <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;&amp;	 	与		<span class="literal">true</span>&amp;&amp;<span class="literal">false</span>		====&gt;<span class="literal">false</span></span><br><span class="line">|| 		或		<span class="literal">true</span>||<span class="literal">false</span>			====&gt;<span class="literal">true</span></span><br><span class="line">！ 		非		!<span class="literal">true</span>				====&gt;<span class="literal">false</span></span><br><span class="line"><span class="literal">false</span>（理解）：<span class="literal">false</span>,  <span class="number">0</span>,  <span class="literal">null</span>,  <span class="literal">undefined</span> </span><br><span class="line"><span class="literal">true</span>（理解）：<span class="literal">true</span>, 非<span class="number">0</span>,  非<span class="literal">null</span>,  非<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="三元运算符："><a href="#三元运算符：" class="headerlink" title="三元运算符："></a><strong>三元运算符：</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">条件？表达式<span class="number">1</span>：表达式<span class="number">2</span></span><br><span class="line">如果条件为<span class="literal">true</span>，返回表达式<span class="number">1</span>的结果</span><br><span class="line">如果条件为<span class="literal">false</span>，返回表达式<span class="number">2</span>的结果</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-数据类型："><a href="#JavaScript-数据类型：" class="headerlink" title="JavaScript 数据类型："></a>JavaScript 数据类型：</h2><h3 id="类型介绍："><a href="#类型介绍：" class="headerlink" title="类型介绍："></a>类型介绍：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数值型：number</span><br><span class="line">字符串：string（凡是引号包裹起来的内容全部都是字符串）</span><br><span class="line">布尔：boolean（<span class="literal">true</span>、<span class="literal">false</span>）</span><br><span class="line">对象类型：object（特殊取值<span class="literal">null</span>）</span><br><span class="line">空：<span class="literal">null</span></span><br><span class="line">未定义型：<span class="literal">undefined</span></span><br><span class="line">JavaScript 有多种数据类型：数字，字符串，数组，对象等等：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">16</span>;                                  <span class="comment">// Number 通过数字字面量赋值 </span></span><br><span class="line"><span class="keyword">var</span> points = x * <span class="number">10</span>;                              <span class="comment">// Number 通过表达式字面量赋值 </span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">"Johnson"</span>;                         <span class="comment">// String 通过字符串字面量赋值 </span></span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Saab"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];              <span class="comment">// Array  通过数组字面量赋值 </span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">firstName</span>:<span class="string">"John"</span>, <span class="attr">lastName</span>:<span class="string">"Doe"</span>&#125;;  <span class="comment">// Object 通过对象字面量赋值</span></span><br><span class="line"><span class="comment">// Object 有两种寻址方式</span></span><br><span class="line">name=person.lastname;</span><br><span class="line">name=person[<span class="string">"lastname"</span>];</span><br><span class="line"></span><br><span class="line">Undefined 和 Null</span><br><span class="line">Undefined 这个值表示变量不含有值。</span><br><span class="line">可以通过将变量的值设置为 <span class="literal">null</span> 来清空变量。</span><br></pre></td></tr></table></figure>

<p><img src="/../images/JavaScript/1470710140220491.gif" alt="img"></p>
<h2 id="JavaScript-类型转换"><a href="#JavaScript-类型转换" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h2><p>Number() 转换为数字， String() 转换为字符串， Boolean() 转化为布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在 JavaScript 中有 <span class="number">5</span> 种不同的数据类型：</span><br><span class="line">- string（凡是引号包裹起来的内容全部都是字符串）</span><br><span class="line">- number（凡是数字都是数值型，不区分整数和小数）</span><br><span class="line">- boolean（<span class="literal">true</span>、<span class="literal">false</span>）</span><br><span class="line">- object（特殊取值<span class="literal">null</span>）</span><br><span class="line">- <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3 种对象类型：</span></span><br><span class="line"><span class="function">- <span class="title">Object</span></span></span><br><span class="line"><span class="function">- <span class="title">Date</span></span></span><br><span class="line"><span class="function">- <span class="title">Array</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2 个不包含任何值的数据类型：</span></span><br><span class="line"><span class="function">- <span class="title">null</span></span></span><br><span class="line"><span class="function">- <span class="title">undefined</span></span></span><br></pre></td></tr></table></figure>

<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>typeof(value); 或者typeof value;     返回这个变量的类型.<br>说明 : 同一个变量, 可以进行不同类型的数据赋值.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"John"</span>                 <span class="comment">// 返回 string </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                   <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>                    <span class="comment">// 返回 number </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                  <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]              <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;  <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;         <span class="comment">// 返回 function</span></span><br><span class="line"><span class="keyword">typeof</span> myCar                  <span class="comment">// 返回 undefined (if myCar is not declared) </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                   <span class="comment">// 返回 object</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">-------------------------------------请注意------------------------------------------------</span></span><br><span class="line"><span class="regexp">NaN 的数据类型是 number</span></span><br><span class="line"><span class="regexp">数组(Array)的数据类型是 object</span></span><br><span class="line"><span class="regexp">日期(Date)的数据类型为 object</span></span><br><span class="line"><span class="regexp">null 的数据类型是 object</span></span><br><span class="line"><span class="regexp">未定义变量的数据类型为 undefined</span></span><br><span class="line"><span class="regexp">如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 typeof 来判断他们的类型，因为都是 返回 Object。</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"John"</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125; </span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>].constructor              <span class="comment">// 返回函数 Array()   &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.constructor  <span class="comment">// 返回函数 Object()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor             <span class="comment">// 返回函数 Date()    &#123; [native code] &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.constructor         <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line">你可以使用 <span class="keyword">constructor</span> 属性来查看对象是否为数组 (包含字符串 "Array"):</span><br><span class="line">function isArray(myArray) &#123; </span><br><span class="line">    <span class="keyword">return</span> myArray.constructor.toString().indexOf(<span class="string">"Array"</span>) &gt; <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line">你可以使用 <span class="keyword">constructor</span> 属性来查看是对象是否为日期 (包含字符串 "Date"):</span><br><span class="line">function isDate(myDate) &#123; </span><br><span class="line">    <span class="keyword">return</span> myDate.constructor.toString().indexOf(<span class="string">"Date"</span>) &gt; <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-变量："><a href="#JavaScript-变量：" class="headerlink" title="JavaScript 变量："></a>JavaScript 变量：</h2><p>1、定义：就是存放数据的、内部可以存储任意数据</p>
<p>2、声明变量：3、变量命名规范：</p>
<ol>
<li>只能由字母、数字、_（下划线）、$（美元符号）组成。</li>
<li>不能以数字开头。</li>
<li>命名中不能出现-（js会理解成减号进行减法的操作），不能和关键字冲突。</li>
</ol>
<p><strong>js是弱类型语言，不重视类型的定义，但js会根据为变量赋值的情况自定判断该变量是何种类型：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数值型：<span class="keyword">var</span> i = <span class="number">1</span>;	<span class="keyword">var</span> d = <span class="number">2.35</span>;</span><br><span class="line">字符串：<span class="keyword">var</span> str = <span class="string">"用心学习"</span>;</span><br><span class="line">布尔型：<span class="keyword">var</span> b = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h2><p>JavaScript 语句可以写在函数内，函数可以重复引用：</p>
<h3 id="引用一个函数"><a href="#引用一个函数" class="headerlink" title="引用一个函数"></a><strong>引用一个函数</strong></h3><p>引用一个函数= 调用函数(执行函数内的语句)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形式参数</span>)</span>&#123;函数体&#125;</span><br><span class="line">调用函数：函数名(实际参数);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a * b;                                <span class="comment">// 返回 a 乘于 b 的结果 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果函数需要传递参数、不需要指定参数的类型、直接使用变量即可</span></span><br><span class="line"><span class="comment">//js中出现二个重名的函数名、后者会把前面的覆盖掉</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数是没有名字的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">形式参数</span>)</span>&#123;函数体&#125;</span><br><span class="line">调用方式：将匿名函数赋值给一个变量，通过变量名调用函数</span><br><span class="line">定义函数并赋值给变量：<span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">形式参数</span>)</span>&#123;函数体&#125;</span><br><span class="line">调用函数：fn(实际参数);</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 匿名函数 : 没有名称的函数</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">i, u</span>) </span>&#123;</span><br><span class="line">        alert(i + <span class="string">" love "</span> + u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用函数 :</span></span><br><span class="line">   func(<span class="string">"柳岩"</span>, <span class="string">"小白"</span>);<span class="comment">//显示柳岩love小白</span></span><br><span class="line"> </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h2><p>JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。</p>
<p>循环语句和语句标识符和java类似，其他需要注意的如下：</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性。</p>
<h3 id="对代码行进行折行"><a href="#对代码行进行折行" class="headerlink" title="对代码行进行折行"></a>对代码行进行折行</h3><p>您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：        </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"你好 \ W3Cschool!"</span>);</span><br><span class="line">\不过，您不能像这样折行：       </span><br><span class="line"><span class="built_in">document</span>.write \ (<span class="string">"你好W3Cschool!"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-注释："><a href="#JavaScript-注释：" class="headerlink" title="JavaScript 注释："></a>JavaScript 注释：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">单行注释：		<span class="comment">//	注释语句		快捷键ctrl+/</span></span><br><span class="line">多行注释：		<span class="comment">/* 注释语句 */</span>    快捷键ctrl+shift+<span class="regexp">/   </span></span><br><span class="line"><span class="regexp">注意：多行注释相互不能嵌套使用，只能在多行注释里面使用单行注释！</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript正则表达式"><a href="#JavaScript正则表达式" class="headerlink" title="JavaScript正则表达式"></a>JavaScript正则表达式</h2><p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p>
<p>搜索模式可用于文本搜索和文本替换。在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置。</p>
<p><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串。</p>
<h3 id="使用-RegExp-对象"><a href="#使用-RegExp-对象" class="headerlink" title="使用 RegExp 对象"></a>使用 RegExp 对象</h3><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p>
<p><strong>test() 方法</strong>是一个正则表达式方法，用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<p><strong>exec() 方法</strong>是一个正则表达式方法。exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<p><img src="/../images/JavaScript/image-20200707114925112.png" alt="image-20200707114925112"></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/../images/JavaScript/1470710362109508.gif" alt="img"></p>
<h2 id="JavaScript-调试"><a href="#JavaScript-调试" class="headerlink" title="JavaScript 调试"></a>JavaScript 调试</h2><h3 id="console-log-方法"><a href="#console-log-方法" class="headerlink" title="console.log() 方法"></a>console.log() 方法</h3><p>如果浏览器支持调试，你可以使用 console.log() 方法在调试窗口上打印 JavaScript 值：</p>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p>
<p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p>
<p>在检查完毕后，可以重新执行代码（如播放按钮）。</p>
<h3 id="debugger-关键字"><a href="#debugger-关键字" class="headerlink" title="debugger 关键字"></a>debugger 关键字</h3><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。这个关键字与在调试工具中设置断点的效果是一样的。如果没有调试可用，debugger 语句将无法工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span> * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">debugger</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementbyId(<span class="string">"demo"</span>).innerHTML = x;</span><br></pre></td></tr></table></figure>

<h3 id="主要浏览器的调试工具"><a href="#主要浏览器的调试工具" class="headerlink" title="主要浏览器的调试工具"></a>主要浏览器的调试工具</h3><p>通常，浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<p>各浏览器的步骤如下:</p>
<h4 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h4><ul>
<li>打开浏览器。</li>
<li>在菜单中选择工具。</li>
<li>在工具中选择开发者工具。</li>
<li>最后，选择 Console。</li>
</ul>
<h2 id="JavaScript-表单验证"><a href="#JavaScript-表单验证" class="headerlink" title="JavaScript 表单验证"></a>JavaScript 表单验证</h2><p>JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。</p>
<p>表单数据经常需要使用 JavaScript 来验证其正确性：</p>
<ul>
<li>验证表单数据是否为空？</li>
<li>验证输入是否是一个正确的email地址？</li>
<li>验证日期是否输入正确？</li>
<li>验证表单输入内容是否为数字型？</li>
</ul>
<h2 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h2><p>JSON 是用于存储和传输数据的格式。</p>
<p>JSON 通常用于服务端向网页传递数据 。</p>
<h3 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON?"></a>什么是 JSON?</h3><ul>
<li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li>
<li>JSON 是一种轻量级的数据交换格式。</li>
<li>JSON是独立的语言 *****</li>
<li>JSON 易于理解。</li>
</ul>
<p>注意： JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。  文本可以被任何编程语言读取及作为数据格式传递。</p>
<p>JSON实例</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"employees"</span>:[ </span><br><span class="line">    &#123;<span class="attr">"firstName"</span>:<span class="string">"John"</span>, <span class="attr">"lastName"</span>:<span class="string">"Doe"</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">"firstName"</span>:<span class="string">"Anna"</span>, <span class="attr">"lastName"</span>:<span class="string">"Smith"</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">"firstName"</span>:<span class="string">"Peter"</span>, <span class="attr">"lastName"</span>:<span class="string">"Jones"</span>&#125; </span><br><span class="line">]&#125; </span><br><span class="line"></span><br><span class="line">JSON 字符串转换为 JavaScript 对象</span><br><span class="line">通常我们从服务器中读取 JSON 数据，并在网页中显示数据。</span><br><span class="line">简单起见，我们网页中直接设置 JSON 字符串:</span><br><span class="line">首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="utf-8"&gt;</span><br><span class="line">&lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;为 JSON 字符串创建对象&lt;/h2&gt;</span><br><span class="line">&lt;p id="demo"&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var text = '&#123;"employees":[' +</span><br><span class="line">	'&#123;"firstName":"John","lastName":"Doe" &#125;,' +</span><br><span class="line">	'&#123;"firstName":"Anna","lastName":"Smith" &#125;,' +</span><br><span class="line">	'&#123;"firstName":"Peter","lastName":"Jones" &#125;]&#125;';</span><br><span class="line">obj = JSON.parse(text);</span><br><span class="line">document.getElementById("demo").innerHTML =</span><br><span class="line">	obj.employees[1].firstName + " " + obj.employees[1].lastName;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="javascript-void-0-含义"><a href="#javascript-void-0-含义" class="headerlink" title="javascript:void(0) 含义"></a>javascript:void(0) 含义</h2><p>我们经常会使用到 javascript:void(0) 这样的代码，那么在 JavaScript 中 javascript:void(0) 代表的是什么意思呢？</p>
<p>javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。</p>
<h3 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h3><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
<p><strong>注意：</strong>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
<h2 id="JavaScript-代码规范"><a href="#JavaScript-代码规范" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h2><p>所有的 JavaScript 项目适用同一种规范。代码规范通常包括以下几个方面:</p>
<ul>
<li>变量和函数的命名规则</li>
<li>空格，缩进，注释的使用规则。</li>
<li>其他常用规范……</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">变量：变量名推荐使用驼峰法来命名(camelCase)</span><br><span class="line">运算符：通常运算符 ( = + - * <span class="regexp">/ ) 前后需要添加空格</span></span><br><span class="line"><span class="regexp">代码缩进：通常使用 4 个空格符号来缩进代码块</span></span><br><span class="line"><span class="regexp">           </span></span><br><span class="line"><span class="regexp">语句规则：</span></span><br><span class="line"><span class="regexp">简单语句:一条语句通常以分号作为结束符。</span></span><br><span class="line"><span class="regexp">复杂语句的通用规则:</span></span><br><span class="line"><span class="regexp">将左花括号放在第一行的结尾。</span></span><br><span class="line"><span class="regexp">左花括号前添加一空格。</span></span><br><span class="line"><span class="regexp">将右花括号独立放在一行。</span></span><br><span class="line"><span class="regexp">不要以分号结束一个复杂的声明。</span></span><br><span class="line"><span class="regexp">if (time &lt; 20) &#123;</span></span><br><span class="line"><span class="regexp">    greeting = "Good day";</span></span><br><span class="line"><span class="regexp">&#125; else &#123;</span></span><br><span class="line"><span class="regexp">    greeting = "Good evening";</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">           </span></span><br><span class="line"><span class="regexp">对象规则</span></span><br><span class="line"><span class="regexp">对象定义的规则:</span></span><br><span class="line"><span class="regexp">将左花括号与类名放在同一行。</span></span><br><span class="line"><span class="regexp">冒号与属性值间有个空格。</span></span><br><span class="line"><span class="regexp">字符串使用双引号，数字不需要。</span></span><br><span class="line"><span class="regexp">最后一个属性-值对后面不要添加逗号。</span></span><br><span class="line"><span class="regexp">将右花括号独立放在一行，并以分号作为结束符号。</span></span><br><span class="line"><span class="regexp">短的对象代码可以直接写成一行:</span></span><br><span class="line"><span class="regexp">var person = &#123;</span></span><br><span class="line"><span class="regexp">    firstName: "John",</span></span><br><span class="line"><span class="regexp">    lastName: "Doe",</span></span><br><span class="line"><span class="regexp">    age: 50,</span></span><br><span class="line"><span class="regexp">    eyeColor: "blue"</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">每行代码字符小于 80</span></span><br><span class="line"><span class="regexp">为了便于阅读每行字符建议小于数 80 个。</span></span><br><span class="line"><span class="regexp">如果一个 JavaScript 语句超过了 80 个字符，建议在 运算符或者逗号后换行。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">命名规则</span></span><br><span class="line"><span class="regexp">一般很多代码语言的命名规则都是类似的，例如:</span></span><br><span class="line"><span class="regexp">变量和函数为驼峰法（ camelCase）</span></span><br><span class="line"><span class="regexp">全局变量为大写 (UPPERCASE )</span></span><br><span class="line"><span class="regexp">常量 (如 PI) 为大写 (UPPERCASE )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">HTML 和 CSS 的横杠(-)字符:</span></span><br><span class="line"><span class="regexp">HTML5 属性可以以 data- (如：data-quantity, data-price) 作为前缀。</span></span><br><span class="line"><span class="regexp">CSS 使用 - 来连接属性名 (font-size)。</span></span><br><span class="line"><span class="regexp">注意:- 通常在 JavaScript 中被认为是减法，所以不允许使用。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">下划线:</span></span><br><span class="line"><span class="regexp">很多程序员比较喜欢使用下划线(如：date_of_birth), 特别是在 SQL 数据库中。</span></span><br><span class="line"><span class="regexp">PHP 语言通常都使用下划线。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">HTML 载入外部 JavaScript 文件</span></span><br><span class="line"><span class="regexp">使用简洁的格式载入 JavaScript 文件 ( type 属性不是必须的):</span></span><br><span class="line"><span class="regexp">&lt;script src="myscript.js"&gt;</span></span><br><span class="line"><span class="regexp">使用 JavaScript 访问 HTML 元素</span></span><br><span class="line"><span class="regexp">一个糟糕的 HTML 格式可能会导致 JavaScript 执行错误。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">使用小写文件名</span></span><br><span class="line"><span class="regexp">大多 Web 服务器 (Apache, Unix) 对大小写敏感： london.jpg 不能通过 London.jpg 访问。</span></span><br><span class="line"><span class="regexp">其他 Web 服务器 (Microsoft, IIS) 对大小写不敏感： london.jpg 可以通过 London.jpg 或 london.jpg 访问。</span></span><br><span class="line"><span class="regexp">你必须保持统一的风格，我们建议统一使用小写的文件名。</span></span><br></pre></td></tr></table></figure>







<h2 id="Javascript案例-轮播图"><a href="#Javascript案例-轮播图" class="headerlink" title="Javascript案例:轮播图"></a>Javascript案例:轮播图</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">说明<span class="number">1</span> : script 标签需要放在 body 标签之后.</span><br><span class="line"></span><br><span class="line">说明<span class="number">2</span> : <span class="built_in">window</span>.setInterval(“字符串函数名称()”, 时间毫秒数);</span><br><span class="line">说明<span class="number">3</span> : <span class="built_in">window</span>.setInterval(函数名称, 时间毫秒数);</span><br><span class="line">说明<span class="number">4</span> : <span class="built_in">window</span>.setInterval(匿名函数, 时间毫秒数);            推荐使用</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;轮播图&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        div &#123;</span></span><br><span class="line"><span class="regexp">            width: 80%;</span></span><br><span class="line"><span class="regexp">            margin: 50px auto;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        img &#123;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="container"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img src="../img</span><span class="regexp">/01.jpg" alt="图片"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现1：</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 需求 : 动态获取页面中的 img 标签, 然后修改 img 标签的 src 属性.</span></span><br><span class="line">    <span class="comment">// 1. 获取 img 标签</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span><br><span class="line">    <span class="comment">// alert(img);</span></span><br><span class="line">    <span class="comment">// 定义一个变量</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 1.2 定义一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeImageSrc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        img.src = <span class="string">"../img/0"</span>+count+<span class="string">".jpg"</span>;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">8</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 循环切换图片</span></span><br><span class="line">    <span class="comment">// window.setInterval(函数, 时间毫秒); 在指定的时间毫秒间隔, 不断调用第一个参数传入的函数.</span></span><br><span class="line">    <span class="comment">// 调用方式一 :</span></span><br><span class="line">    <span class="comment">// window.setInterval("changeImageSrc()", 1000);</span></span><br><span class="line">    <span class="comment">// 调用方式二 :</span></span><br><span class="line">    <span class="built_in">window</span>.setInterval(changeImageSrc, <span class="number">1000</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现2：</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需求 : 动态获取页面中的 img 标签, 然后修改 img 标签的 src 属性.</span></span><br><span class="line">    <span class="comment">// 1. 获取 img 标签</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span><br><span class="line">    <span class="comment">// alert(img);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义一个变量</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2. 循环切换图片</span></span><br><span class="line">    <span class="comment">// window.setInterval(匿名函数, 时间毫秒); 在指定的时间毫秒间隔, 不断调用第一个参数传入的匿名函数.</span></span><br><span class="line">    <span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        img.src = <span class="string">"../img/0"</span>+count+<span class="string">".jpg"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">8</span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">事件三要素：</span><br><span class="line"><span class="number">1.</span>	事件源：被监听的html元素（就是这个事件加给谁），就是某个（某些）html标签</span><br><span class="line"><span class="number">2.</span>	事件类型：某类动作，例如点击事件，移入移除事件，敲击键盘事件等</span><br><span class="line"><span class="number">3.</span>	执行指令：事件触发后需要执行的代码，一般使用函数进行封装</span><br><span class="line">语法格式：事件源.事件类型=执行指令</span><br></pre></td></tr></table></figure>

<h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><p><img src="/../images/JavaScript/20180921101943914.png" alt="img"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;事件&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 窗口 : window 对象提供了一个事件类型  onload 页面加载完成事件.</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 事件源 : window事件类型 : 页面加载完成事件 (onload)  执行指令: 就是赋值的 function 函数.</span></span><br><span class="line"><span class="regexp">        window.onload = function () &#123;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 获取页面的 btn 按钮</span></span><br><span class="line"><span class="regexp">            var btn = document.getElementById("btn");</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ alert(btn);</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 给 btn 按钮绑定一个事件 (单击事件 onclick)</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 事件源 : btn按钮    事件类型 : 单击事件 (onclick)  执行指令: 就是赋值的 function 函数.</span></span><br><span class="line"><span class="regexp">            btn.onclick = function () &#123;</span></span><br><span class="line"><span class="regexp">                alert("恭喜你, 中了 500 万!");</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button id="btn"&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="js对象"><a href="#js对象" class="headerlink" title="js对象"></a>js对象</h1><h2 id="一、Object类型"><a href="#一、Object类型" class="headerlink" title="一、Object类型"></a>一、Object类型</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>  到目前为止，我们使用的引用类型最多的可能就是Object 类型了。虽然Object 的实例不具备多少功能，但对于在应用程序中的存储和传输数据而言，它是非常理想的选择。<br>创建Object 类型有两种。一种是使用new 运算符，一种是字面量表示法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用<span class="keyword">new</span> 运算符创建<span class="built_in">Object</span></span><br><span class="line">        <span class="keyword">var</span> box = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//new 方式</span></span><br><span class="line">        box.name = <span class="string">'李四'</span>; <span class="comment">//创建属性字段</span></span><br><span class="line">        box.age = <span class="number">28</span>; <span class="comment">//创建属性字段</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">2.n</span>ew 关键字可以省略</span><br><span class="line">        <span class="keyword">var</span> box = <span class="built_in">Object</span>(); <span class="comment">//省略了new 关键字</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span>使用字面量方式创建<span class="built_in">Object</span></span><br><span class="line">        <span class="keyword">var</span> box = &#123; <span class="comment">//字面量方式</span></span><br><span class="line">            name : <span class="string">'李四'</span>, <span class="comment">//创建属性字段</span></span><br><span class="line">            age : <span class="number">28</span></span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="number">4.</span>属性字段也可以使用字符串创建</span><br><span class="line">        <span class="keyword">var</span> box = &#123;</span><br><span class="line">            <span class="string">'name'</span> : <span class="string">'李四'</span>, <span class="comment">//也可以用字符串形式</span></span><br><span class="line">            <span class="string">'age'</span> : <span class="number">28</span></span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="number">5.</span>使用字面量及传统复制方式</span><br><span class="line">        <span class="keyword">var</span> box = &#123;&#125;; <span class="comment">//字面量方式声明空的对象</span></span><br><span class="line">        box.name = <span class="string">'李四'</span>; <span class="comment">//点符号给属性复制</span></span><br><span class="line">        box.age = <span class="number">28</span>;</span><br><span class="line"> </span><br><span class="line"><span class="number">6.</span>两种属性输出方式</span><br><span class="line">        alert(box.age); <span class="comment">//点表示法输出</span></span><br><span class="line">        alert(box[<span class="string">'age'</span>]); <span class="comment">//中括号表示法输出，注意引号</span></span><br><span class="line">        PS：在使用字面量声明<span class="built_in">Object</span> 对象时，不会调用<span class="built_in">Object</span>()构造函数(Firefox 除外)。</span><br><span class="line"> </span><br><span class="line"><span class="number">7.</span>给对象创建方法</span><br><span class="line">        <span class="keyword">var</span> box = &#123;</span><br><span class="line">            run : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//对象中的方法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'运行'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        alert(box.run()); <span class="comment">//调用对象中的方法</span></span><br><span class="line"> </span><br><span class="line"><span class="number">8.</span>使用<span class="keyword">delete</span> 删除对象属性</span><br><span class="line">        <span class="keyword">delete</span> box.name; <span class="comment">//删除属性</span></span><br><span class="line">        在实际开发过程中，一般我们更加喜欢字面量的声明方式。因为它清晰，语法代码少，</span><br><span class="line">而且还给人一种封装的感觉。字面量也是向函数传递大量可选参数的首选方式。</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//参数是一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj.name != <span class="literal">undefined</span>) alert(obj.name); <span class="comment">//判断属性是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (obj.age != <span class="literal">undefined</span>) alert(obj.age);</span><br><span class="line">&#125;</span><br><span class="line">        box(&#123; <span class="comment">//调用函数传递一个对象</span></span><br><span class="line">            name : <span class="string">'李四'</span>,</span><br><span class="line">            age : <span class="number">28</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="二、对象们"><a href="#二、对象们" class="headerlink" title="二、对象们"></a>二、对象们</h2><p><img src="/../images/JavaScript/20180921104023978.png" alt="img"></p>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><p>Array对象是数组对象，跟java中的数组一个意思，但是使用语法上稍微有些区别。</p>
<p>Java：可以保存多种类型相同的数据。在Java中数组的长度是固定的，类型也固定的。</p>
<p>js：可以保存不同类型的数据，同时长度不固定。可以把其理解成Java中的ArrayList。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建空数组：<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">创建指定容量的数组：<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">创建数组并填充元素：<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(a,b,c...);</span><br><span class="line">创建元素数组：<span class="keyword">var</span> arr = [a,b,c...];</span><br></pre></td></tr></table></figure>

<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建当前日期时间：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">创建指定日期时间：<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(毫秒值);</span><br><span class="line">其中毫秒值为<span class="number">1970</span><span class="number">-01</span><span class="number">-01</span>至今的时间毫秒值</span><br><span class="line"></span><br><span class="line">年：getFullYear()			以四位数字返回年份 </span><br><span class="line">月：getMonth()			    返回月份 (<span class="number">0</span> ~ <span class="number">11</span>)</span><br><span class="line">日：getDate() 				返回一个月中的某一天</span><br><span class="line">星期：getDay()			    返回一周中的某一天 (<span class="number">0</span> ~ <span class="number">6</span>)，<span class="number">0</span>代表周日</span><br><span class="line">小时：getHours() 			返回小时（<span class="number">0</span> ~ <span class="number">23</span>）</span><br><span class="line">分：getMinutes() 			返回分钟（<span class="number">0</span> ~ <span class="number">59</span>）</span><br><span class="line">秒：getSeconds() 			返回秒数（<span class="number">0</span> ~ <span class="number">59</span>）</span><br><span class="line">毫秒值：getTime()			返回 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日至今的毫秒数</span><br><span class="line">toLocaleString()			把<span class="built_in">Date</span>对象转换为字符串</span><br><span class="line">toLocaleDateString()		把<span class="built_in">Date</span>对象的日期部分转换为字符串</span><br><span class="line">toLocaleTimeString()		把<span class="built_in">Date</span>对象的时间部分转换为字符串</span><br></pre></td></tr></table></figure>

<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p>Math对象是数学对象，是一个工具对象，因此Math对象不用使用new的方式创建，直接使用Math就可以调用对象内部的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() 返回 <span class="number">0.0</span> ~ <span class="number">1.0</span> 之间的随机double小数</span><br></pre></td></tr></table></figure>

<h2 id="三、全局函数"><a href="#三、全局函数" class="headerlink" title="三、全局函数"></a>三、全局函数</h2><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p><img src="/../images/JavaScript/20180921105518443.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">全局函数：</span><br><span class="line"><span class="built_in">parseInt</span>(num); 	<span class="comment">// 取整，不会四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.round(num);<span class="comment">// 取整，会四舍五入</span></span><br></pre></td></tr></table></figure>

<h3 id="编码解码函数"><a href="#编码解码函数" class="headerlink" title="编码解码函数"></a>编码解码函数</h3><p><img src="/../images/JavaScript/20180921105850342-1594053033028.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">"https://www.baidu.com?wd=编码解码函数"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// encodeURI 编码字符串(资源路径)</span></span><br><span class="line">      str = <span class="built_in">window</span>.encodeURI(str);</span><br><span class="line">      <span class="built_in">document</span>.write(str + <span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// decodeURI 解码字符串</span></span><br><span class="line">      str = <span class="built_in">window</span>.decodeURI(str);</span><br><span class="line">      <span class="built_in">document</span>.write(str + <span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line"> </span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/JavaScript/20180921110034490.png" alt="img"></p>
<h2 id="四、BOM"><a href="#四、BOM" class="headerlink" title="四、BOM"></a>四、BOM</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>BOM（Browser Object Mode），浏览器对象模型，是将我们使用的浏览器抽象成对象模型，例如我们打开一个浏览器，会呈现出以下页面，通过js提供浏览器对象模型对象我们可以模拟浏览器功能。</p>
<p>HTML DOM树</p>
<p><img src="/../images/JavaScript/pic_htmltree.gif" alt="DOM HTML tree"></p>
<p>通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件做出反应</li>
</ul>
<h3 id="2、查找-HTML-元素"><a href="#2、查找-HTML-元素" class="headerlink" title="2、查找 HTML 元素"></a>2、查找 HTML 元素</h3><p>通常，通过 JavaScript，您需要操作 HTML 元素。</p>
<p>为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事：</p>
<ul>
<li>通过 id 找到 HTML 元素getElementsById</li>
<li>通过标签名找到 HTML 元素getElementsByTagName</li>
<li>通过类名找到 HTML 元素getElementsByClassName</li>
</ul>
<h3 id="3、HTML-DOM-改变-HTML-内容"><a href="#3、HTML-DOM-改变-HTML-内容" class="headerlink" title="3、HTML DOM 改变 HTML 内容"></a>3、HTML DOM 改变 HTML 内容</h3><h4 id="改变-HTML-输出流"><a href="#改变-HTML-输出流" class="headerlink" title="改变 HTML 输出流"></a>改变 HTML 输出流</h4><ol>
<li>JavaScript 能够创建动态的 HTML 内容：</li>
</ol>
<p>在 JavaScript 中，[document.write()]可用于直接向 HTML 输出流写内容。</p>
<ol start="2">
<li>修改 HTML 内容的最简单的方法是使用 innerHTML 属性]</li>
</ol>
<p>document.getElementById(<em>id</em>).innerHTML=<em>new HTML</em></p>
<ol start="3">
<li>改变 HTML 属性如需改变 HTML 元素的属性，请使用这个语法：</li>
</ol>
<p>document.getElementById(<em>id</em>).<em>attribute=new value</em></p>
<h4 id="改变CSS"><a href="#改变CSS" class="headerlink" title="改变CSS"></a>改变CSS</h4><p>如需改变 HTML 元素的样式，请使用这个语法：    </p>
<p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>new style</em>    </p>
<h3 id="4、HTML-DOM-EventListener"><a href="#4、HTML-DOM-EventListener" class="headerlink" title="4、HTML DOM EventListener"></a>4、HTML DOM EventListener</h3><ol>
<li>addEventListener() 方法用于向指定元素添加事件句柄。</li>
</ol>
<ul>
<li>addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。</li>
<li>你可以向一个元素添加多个事件句柄。</li>
<li>你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。</li>
<li>你可以向同个元素添加不同类型的事件：</li>
<li>addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支出的事件对象如: xmlHttpRequest 对象。</li>
<li>addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。</li>
<li>当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。</li>
<li>你可以使用 removeEventListener() 方法来移除事件的监听。 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>);</span></span><br><span class="line"><span class="function">第一个参数是事件的类型 (<span class="params">如 <span class="string">"click"</span> 或 <span class="string">"mousedown"</span></span>).</span></span><br><span class="line"><span class="function">第二个参数是事件触发后调用的函数。</span></span><br><span class="line"><span class="function">第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</span></span><br><span class="line"><span class="function">注意:不要使用 "<span class="title">on</span>" 前缀。 例如，使用 "<span class="title">click</span>" ,而不是使用 "<span class="title">onclick</span>"。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">向原元素添加事件句柄</span></span><br><span class="line"><span class="function">实例</span></span><br><span class="line"><span class="function">当用户点击元素时弹出 "<span class="title">Hello</span> <span class="title">World</span>!" :</span></span><br><span class="line"><span class="function"><span class="title">element</span>.<span class="title">addEventListener</span>(<span class="params"><span class="string">"click"</span>, function(</span>)</span>&#123; alert(<span class="string">"Hello World!"</span>); &#125;);</span><br><span class="line"></span><br><span class="line">向同一个元素中添加多个事件句柄</span><br><span class="line">addEventListener() 方法允许向同个元素添加多个事件，且不会覆盖已存在的事件：</span><br><span class="line">实例</span><br><span class="line">element.addEventListener(<span class="string">"click"</span>, myFunction); </span><br><span class="line">element.addEventListener(<span class="string">"click"</span>, mySecondFunction); </span><br><span class="line"></span><br><span class="line">你可以向同个元素添加不同类型的事件：</span><br><span class="line">实例</span><br><span class="line">element.addEventListener(<span class="string">"mouseover"</span>, myFunction); </span><br><span class="line">element.addEventListener(<span class="string">"click"</span>, mySecondFunction); </span><br><span class="line">element.addEventListener(<span class="string">"mouseout"</span>, myThirdFunction);</span><br><span class="line"></span><br><span class="line">向 Window 对象添加事件句柄</span><br><span class="line">addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, <span class="built_in">window</span> 对象。或者其他支出的事件对象如: xmlHttpRequest 对象。</span><br><span class="line">实例</span><br><span class="line">当用户重置窗口大小时添加事件监听：</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = sometext; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">传递参数</span><br><span class="line">当传递参数值时，使用<span class="string">"匿名函数"</span>调用带参数的函数：</span><br><span class="line">实例</span><br><span class="line">element.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myFunction(p1, p2); &#125;);</span><br><span class="line"></span><br><span class="line">事件冒泡或事件捕获？</span><br><span class="line">事件传递有两种方式：冒泡与捕获。</span><br><span class="line">事件传递定义了元素事件触发的顺序。 如果你将 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 <span class="string">"click"</span> 事件先被触发呢？</span><br><span class="line">在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： &lt;p&gt; 元素的点击事件先触发，然后会触发 &lt;div&gt; 元素的点击事件。</span><br><span class="line">在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： &lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。</span><br><span class="line">addEventListener() 方法可以指定 <span class="string">"useCapture"</span> 参数来设置传递类型：</span><br><span class="line"></span><br><span class="line">removeEventListener() 方法</span><br><span class="line">removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:</span><br><span class="line">实例</span><br><span class="line">element.removeEventListener(<span class="string">"mousemove"</span>, myFunction);</span><br></pre></td></tr></table></figure>

<h3 id="5、HTML-DOM-元素"><a href="#5、HTML-DOM-元素" class="headerlink" title="5、HTML DOM 元素"></a>5、HTML DOM 元素</h3><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性，分别是：</p>
<ol>
<li>nodeName : 节点的名称</li>
<li>nodeValue ：节点的值</li>
<li>nodeType ：节点的类型</li>
</ol>
<h4 id="创建新的-HTML-元素"><a href="#创建新的-HTML-元素" class="headerlink" title="创建新的 HTML 元素"></a><strong>创建新的 HTML 元素</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;</span><br><span class="line">&lt;p id=<span class="string">"p1"</span>&gt;这是一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="p2"&gt;这是另一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var para=document.createElement("p");</span></span><br><span class="line"><span class="regexp">var node=document.createTextNode("这是一个新段落。");</span></span><br><span class="line"><span class="regexp">para.appendChild(node);</span></span><br><span class="line"><span class="regexp">var element=document.getElementById("div1");</span></span><br><span class="line"><span class="regexp">element.appendChild(para);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="删除已有的-HTML-元素"><a href="#删除已有的-HTML-元素" class="headerlink" title="删除已有的 HTML 元素"></a><strong>删除已有的 HTML 元素</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;</span><br><span class="line">	&lt;p id=<span class="string">"p1"</span>&gt;这是一个段落。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">	&lt;p id="p2"&gt;这是另一个段落。&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var parent=document.getElementById("div1");</span></span><br><span class="line"><span class="regexp">var child=document.getElementById("p1");</span></span><br><span class="line"><span class="regexp">parent.removeChild(child);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习博客链接合集</title>
    <url>/2020/07/02/Maven%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="使用IntelliJ-IDEA-配置Maven（入门）"><a href="#使用IntelliJ-IDEA-配置Maven（入门）" class="headerlink" title="使用IntelliJ IDEA 配置Maven（入门）"></a>使用IntelliJ IDEA 配置Maven（入门）</h3><p><a href="https://blog.csdn.net/qq_32588349/article/details/51461182?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_32588349/article/details/51461182?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="idea-plugins红色波浪线报错"><a href="#idea-plugins红色波浪线报错" class="headerlink" title="idea plugins红色波浪线报错"></a>idea plugins红色波浪线报错</h3><p><a href="https://blog.csdn.net/m0_37735176/article/details/90695284?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/m0_37735176/article/details/90695284?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="Maven遇到插件下载不下来（Cannot-resolve-plugin-org-apache-maven-plugins-maven-clean-plugin-2-5）"><a href="#Maven遇到插件下载不下来（Cannot-resolve-plugin-org-apache-maven-plugins-maven-clean-plugin-2-5）" class="headerlink" title="Maven遇到插件下载不下来（Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5）"></a>Maven遇到插件下载不下来（Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5）</h3><p><a href="https://blog.csdn.net/weixin_39778417/article/details/103796452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39778417/article/details/103796452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<h3 id="Maven使用详解，非常详细"><a href="#Maven使用详解，非常详细" class="headerlink" title="Maven使用详解，非常详细"></a>Maven使用详解，非常详细</h3><p>1、</p>
<p><a href="https://blog.csdn.net/quuqu/article/details/52458589" target="_blank" rel="noopener">https://blog.csdn.net/quuqu/article/details/52458589</a></p>
<p>2、</p>
<p><a href="https://blog.csdn.net/hcmony/article/details/56013655?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/hcmony/article/details/56013655?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase</a></p>
<h3 id="Maven创建工程步骤"><a href="#Maven创建工程步骤" class="headerlink" title="Maven创建工程步骤"></a>Maven创建工程步骤</h3><p>1、file——new——project</p>
<p>2、Maven——-Create from archetype——maven-archetype-webapp——next</p>
<p>3、Name+Location———next——Maven home diretory</p>
<p>4、<strong>+</strong>——–archetypeCatalog——internal</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/01/hello-world/</url>
    <content><![CDATA[<p><strong>Welcome to Lexie’s World!!!</strong></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>TCP-IP(school)</title>
    <url>/2020/07/02/TCP-IP/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>l 1-4：与因特网相关的机构IAB, IETF, IRTF, ISOC, InterNIC, ICANN, W3C的全称和主要职能是什么？</p>
<p>IAB: Internet Architecture Boar，因特网体系结构委员会。建立因特网标准，管理RFC文档的发布，建立因特网的策略性研究计划。</p>
<p>IETF：Internet Engineering Task Force，因特网工程任务组。负责因特网标准的制定。</p>
<p>IRTF：Internet Research Task Force，因特网研究任务组。负责与因特网发展相关的长远的理论研究。</p>
<p>ISOC：Internet Society，因特网协会。致力于确保全球因特网发展的有益性和开放性，负责管理所有与因特网相关的工作。</p>
<p>InterNIC：Internet Network Information Center，因特网网络信息中心。负责以.com、.org、.net和.edu等顶级域名的注册与管理。</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers，因特网名称与数字地址分配机构。负责IP地址的分配、协议标识符的指派、通用顶级域名以及国家和地区顶级域名系统的管理、根服务器的管理等。</p>
<p>W3C：World Wide Web Consortium，WWW协会。负责制定和颁布WWW有关的应用标准</p>
<p>l 1-5：RFC文档有哪几种可能的状态？各种状态的含义是什么？</p>
<p>RFC文档有8种状态，具体如下：</p>
<p>\1. 标准化轨迹的RFC</p>
<p>p 提案标准：需要进一步的试验证实其可行性。</p>
<p>p 草案标准：需要两个独立的、具有相互操作性的实例来验证其每一个方面。</p>
<p>p 因特网标准：同时赋予一个STD XXXX编号。</p>
<p>\2. 非标准化轨迹的RFC</p>
<p>p 实验性的RFC：反映一些研究成果。</p>
<p>p 信息性的RFC (同时赋予FYI XXXX编号) ：指南、手册、术语表等。</p>
<p>p 历史性的RFC：被新标准取代或者过时的RFC。</p>
<p>\3. 其他状态的RFC</p>
<p>p 最佳当前实现的RFC：同时赋予BCP XXXX编号。</p>
<p>p 未知性的RFC ：未被分类的文档，主要是因特网早期的RFC文档。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>l 2-2 协议分层有什么好处？</p>
<p>分层的优点：</p>
<p>p 有利于将复杂的问题分解成多个相对独立的简单问题，分而治之；越下面的层次越具体，越上面的层次越高级。上层调用下层功能；</p>
<p>p 新技术的引入，不会对所有层次产生影响；</p>
<p>p 网络互联时只需考虑底层某一个或几个异构的层次，而不是所有层次。</p>
<p>l 2-6 Wi-Fi和WiMAX的含义分别是什么？</p>
<p>WiMAX ：Worldwide Interoperability for Microwave Access</p>
<p>Wi-Fi：Wireless Fidelity，无线保真</p>
<p>l 2-7 简述OSI参考模型与TCP/IP模型的关系。</p>
<p><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img"></p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>l 3-3 现有一个C类网络地址块199.5.6.0，需要支持至少7个子网，每个子网最多9台主机。请进行子网规划，给出各子网的地址、可以分配给主机的地址范围和子网广播地址。</p>
<p>题目要求至少7个子网，子网位m, 主机位n，m+n=8。2^m-2 &gt;= 7 因此m＞=4，又每个子网最多9台主机，则n选4</p>
<p>选m=4, n=4 </p>
<table>
<thead>
<tr>
<th>子网地址</th>
<th>开始地址</th>
<th>结束地址</th>
<th>广播地址</th>
</tr>
</thead>
<tbody><tr>
<td>199.5.6.16</td>
<td>199.5.6.17</td>
<td>199.5.6.30</td>
<td>199.5.6.31</td>
</tr>
<tr>
<td>199.5.6.32</td>
<td>199.5.6.33</td>
<td>199.5.6.46</td>
<td>199.5.6.47</td>
</tr>
<tr>
<td>199.5.6.48</td>
<td>199.5.6.49</td>
<td>199.5.6.62</td>
<td>199.5.6.63</td>
</tr>
<tr>
<td>199.5.6.64</td>
<td>199.5.6.65</td>
<td>199.5.6.78</td>
<td>199.5.6.79</td>
</tr>
<tr>
<td>199.5.6.80</td>
<td>199.5.6.81</td>
<td>199.5.6.94</td>
<td>199.5.6.95</td>
</tr>
<tr>
<td>199.5.6.96</td>
<td>199.5.6.97</td>
<td>199.5.6.110</td>
<td>199.5.6.111</td>
</tr>
<tr>
<td>199.5.6.112</td>
<td>199.5.6.113</td>
<td>199.5.6.126</td>
<td>199.5.6.127</td>
</tr>
</tbody></table>
<p>l 3-5 若IP地址为156.42.72.37，子网掩码为255.255.192.0，其子网地址是什么？</p>
<p>子网地址156.42.64.0</p>
<p>l 3-6 将以203.119.64.0开始的16个C类地址块构造一个超网，请给出该超网的超网地址和超网掩码。</p>
<p>超网地址203.199.64.0，超网掩码255.255.240.0</p>
<p>l 3-8 在下列地址块组中，哪个组可以构成超网？其超网掩码是什么？</p>
<p>   a. 199.87.136.0 199.87.137.0 199.87.138.0 199.87.139.0</p>
<p>   b. 199.87.130.0 199.87.131.0 199.87.132.0 199.87.133.0</p>
<p>   c. 199.87.16.0 199.87.17.0 199.87.18.0</p>
<p>   d. 199.87.64.0 199.87.68.0 199.87.72.0 199.87.76.0</p>
<p>a组可以 超网掩码：255.255.252.0</p>
<p>l 3-9 以斜线表示法（CIDR表示法）表示下列IP地址和掩码。</p>
<p>   a. IP地址：200.187.16.0，掩码：255.255.248.0</p>
<p>   b. IP地址：190.170.30.65，掩码：255.255.255.192</p>
<p>   c. IP地址：100.64.0.0，掩码：255.224.0.0</p>
<p>200.187.16.0/21</p>
<p>190.170.30.65/26</p>
<p>100.64.0.0/11</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>l 4-3 当ARP/RARP报文封装在以太网帧中进行发送时，为什么要添加PAD字段？</p>
<p>由于ARP和RARP报文较短（28个字节），后面必须增加18个字节的填充PAD，以达到以太网最小帧长度的要求。</p>
<p>l 4-6 简述目的主机为远程主机时的信息传输过程。</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>l 5-1 IP协议为什么不提供对IP数据报数据区的校验功能？IP协议为什么要对IP数据报首部进行校验？</p>
<p>IP不校验数据区，因为：</p>
<p>p IP数据来自高层协议，且在传输过程中一般不会变化，出于简单原则，IP对其不校验；</p>
<p>p 如需要，由高层（如传输层）端到端校验。</p>
<p>对IP数据报首部进行校验：</p>
<p>p IP首部属于网络层的控制信息，不应由其他层校验；</p>
<p>p 首部部分字段是不断变化的(例如TTL字段)，因此要由IP进行点到点的校验。</p>
<p>l 5-6 一个首部长度为20个字节、数据区长度为2000字节的IP数据报如何在MTU为820字节的网络中传输？</p>
<p>将IP数据报文分片成3块，在ip首部中设置好段标识符字段、DF字段、MF字段和段偏移字段。</p>
<p>数据长度分别为800字节，800字节，400字节</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>l 6-3 ICMP与IP协议是什么关系？</p>
<p>ICMP协议位于网络层，IP协议之上，所以ICMP报文使用IP数据报进行封装。ICMP是IP的补充，用于IP传输时的差错报告、拥塞控制、路径控制以及时间、掩码等信息的获取。 </p>
<p>l 6-4 在利用时间戳请求应答报文进行时钟同步时，主机A的初始时间戳为32530000，接收到主机B应答时的时间戳为32530246，主机B的接收时间戳和发送时间戳分别为32530100和32530130，主机A和主机B之间的时间差是多少？</p>
<p>往返时延=（32530246-32530000）- （32530130-32530100）=246-30=216</p>
<p>因此单程时延=216/2=108</p>
<p>AB之间的时间差=32530100-（32530000+108）= -8</p>
<p>因此B比A慢8毫秒，或者说A比B快8毫秒</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>l <strong>7-1.</strong> 直接传递和间接传递有什么不同？</p>
<p>直接传递：IP数据报在信宿网络中，直接传到信宿的过程</p>
<p>间接传递：IP数据报在非信宿网络中的传递过程</p>
<p>l <strong>7-2.</strong> 路由信息协议RIP和开放最短路优先协议OSPF有什么不同？</p>
<p>使用的基本算法不同，DV和LS……</p>
<p>l <strong>7-5.</strong> RIP、OSPF和BGP报文分别封装到什么协议中进行传送？</p>
<p>RIP协议使用UDP数据报分装</p>
<p>OSPF报文直接使用IP数据报封装</p>
<p>BGP报文使用TCP协议传输，因此用TCP协议分装</p>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>l 8-1 为什么常用的服务器的端口号都采用熟知端口号，而客户端一般采用临时端口号？</p>
<p>为了让客户机能够找到，服务器进程要先启动，并且必须公开IP地址，使用公认的传输层协议与熟知端口。</p>
<p>客户进程使用临时端口号，通信前向操作系统申请，通信后归还。</p>
<p>l 8-6 为了避免和消除拥塞，TCP采用了哪些策略来控制拥塞窗口？</p>
<p>包含慢启动，拥塞避免，拥塞解决等策略。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>l <strong>9-1</strong> 递归解析与反复解析有什么不同？</p>
<p>递归解析时，客户机请求所在区域的服务器解析，若不能给出结果，服务器将请求另一个服务器（通常是其父或子服务器）并等待响应。后续的服务器也是进行类似的处理。一直到找到能解析的服务器，然后原路返回解析结果。</p>
<p>反复解析时，客户机请求所在区域的域名服务器解析，若不能给出结果，则返回另一个服务器的IP地址，客户机再向第二个服务器发出解析请求。后续的服务器也是进行类似的处理，直到找到可以解析的服务器。</p>
<p>l <strong>9-3</strong> DNS是如何提高解析效率的？</p>
<p>为了提高DNS解析效率，通常DNS服务器的高速缓存中，存放最近解析过的本区域之外的信息及其授权服务器地址，下次可直接使用，无需重复进行麻烦的递归或反复解析。</p>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><p>l 10-1 简述BOOTP协议与RARP协议的异同。</p>
<p>BOOTP协议使计算机获得IP地址，所在网络的掩码，默认路由器的IP地址，默认DNS服务器的IP地址。</p>
<p>RARP使用链路层广播也能获取IP地址，但不能跨路由器。</p>
<p>l 10-5 DHCP/BOOTP中继代理的作用是什么？</p>
<p>中继代理运行于设备（一般是路由器）上的一个程序。客户机广播发送DHCP/BOOTP请求报文，由中继代理以单播方式转发给位于其它网络的服务器；服务器向中继代理单播返回应答，中继代理再单播给客户机。</p>
<h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><p>l 11-2. 举例说明第2层组播地址(组播MAC地址)可以从IP组播地址中衍生实现。</p>
<p>例如：IP组播地址224.66.60.89 (11100000. 01000010. 00111100. 01011001) ，可得其以太网的物理组播地址为：00000001 00000000 01011110 01000010 00111100 01011001，也即其组播MAC地址为：01. 00. 5e. 42.3c.59</p>
<p>l 11-4. 比较组播路由协议的稀疏模式和密集模式。</p>
<p>密集模式用于较高带宽、组成员较为集中的网络，主要使用基于源的组播树；</p>
<p>稀疏模式用于网络带宽有限，组播组成员较少且分散的网络，主要使用组共享组播树。</p>
<p>##第二章</p>
<p>l 12-1 简述TFTP与FTP的不同点。</p>
<p>TFTP与FTP的不同点：</p>
<p>p FTP基于TCP，TFTP基于UDP；</p>
<p>p FTP需要客户机登录到服务器，TFTP不需要；</p>
<p>p TFTP功能简单，不允许读取服务器的文件目录等。</p>
<p>l 12-6 FTP中传输与控制为什么采用独立的连接？</p>
<p>FTP建立两条TCP连接：</p>
<p>p 一条传送控制信息(命令和响应) ；</p>
<p>p 另一条传送文件数据。</p>
<h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><p><strong>第**</strong>13<strong>**章</strong></p>
<p>l 13-3 试分析比较SMTP, MIME, IMAP, POP之间的主要区别。</p>
<p>SMTP只能传送ASCII码文本邮件，MIME可通过SMTP实现传送多种语言、多种数据类型(如文本、声音、图像、视频等)的邮件。</p>
<p>客户读取邮件使用邮件获取协议，POP3或IMAP。</p>
<p>l 13-5 简述电子邮件的工作过程。</p>
<h2 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h2><p>l 15-4 简述HTTP的3种通信方式。</p>
<h2 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h2><p>l SNMP管理站与被管设备的通信方式？</p>
<p>l MIB和SMI分别是什么？</p>
<p>l SNMP的两种数据采集方法的特点是什么？</p>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/07/02/Servlet/</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a>1. 什么是Servlet</h2><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的<strong>服务器端程序</strong>。其<strong>主要功能</strong>在于<font color="red"> <strong>交互式地浏览和修改数据，生成动态Web内容。</strong></font></p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
<p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<h2 id="2-Servlet的工作模式"><a href="#2-Servlet的工作模式" class="headerlink" title="2. Servlet的工作模式"></a>2. Servlet的工作模式</h2><ol>
<li>客户端发送请求至服务器</li>
<li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li>
<li>服务器将响应返回客户端</li>
</ol>
<h2 id="3-Servlet-API-概览"><a href="#3-Servlet-API-概览" class="headerlink" title="3.Servlet API 概览"></a>3.Servlet API 概览</h2><p>Servlet API 包含以下4个Java包：</p>
<ul>
<li>1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。</li>
<li>2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。</li>
<li>3.javax.servlet.annotation   其中包含标注servlet,Filter,Listener的标注。它还为被标注元件定义元数据。</li>
<li>4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。</li>
</ul>
<h2 id="4-Servlet的主要类型"><a href="#4-Servlet的主要类型" class="headerlink" title="4.Servlet的主要类型"></a>4.Servlet的主要类型</h2><p><img src="/../images/Servlet/image-20200702203255042.png" alt="image-20200702203255042"></p>
<h2 id="4-Servlet-的使用方法"><a href="#4-Servlet-的使用方法" class="headerlink" title="4.Servlet 的使用方法"></a>4.Servlet 的使用方法</h2><p>Servlet技术的核心是Servlet，<strong><em>\</em>它是所有Servlet类必须直接或者间接实现的一个接口**</strong>。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。</p>
<h2 id="5-Servlet-的工作原理"><a href="#5-Servlet-的工作原理" class="headerlink" title="5.Servlet 的工作原理"></a>5.Servlet 的工作原理</h2><p>Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，<font color="red"><strong>在一个应用程序中，每种Servlet类型只能有一个实例。</strong></font></p>
<p>用户请求致使Servlet容器调用Servlet的Service()方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。</p>
<p>ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据</p>
<p>ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。</p>
<p>对于每一个应用程序，<font color="red"><strong>Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</strong></font></p>
<h2 id="6-Servlet-接口中定义的方法"><a href="#6-Servlet-接口中定义的方法" class="headerlink" title="6.Servlet 接口中定义的方法"></a>6.Servlet 接口中定义的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Servlet-的生命周期"><a href="#7-Servlet-的生命周期" class="headerlink" title="7.Servlet 的生命周期"></a>7.Servlet 的生命周期</h2><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：</p>
<ul>
<li>1.init( )———-当Servlet第一次被请求时，我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。</li>
<li>2.service( )——每当请求Servlet时，Servlet容器就会调用这个方法。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。</li>
<li>3.destory——–当要销毁Servlet时，Servlet容器就会调用这个方法。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</li>
</ul>
<h2 id="8-Servlet-的其它两个方法"><a href="#8-Servlet-的其它两个方法" class="headerlink" title="8.Servlet 的其它两个方法"></a>8.Servlet 的其它两个方法</h2><ol>
<li>String  getServletInfo（ ），这个方法会返回Servlet的一段描述，可以返回一段字符串。</li>
<li>ServletConfig getServletConfig（ ），这个方法会返回由Servlet容器传给init（ ）方法的ServletConfig对象。</li>
</ol>
<h2 id="9-ServletRequset接口"><a href="#9-ServletRequset接口" class="headerlink" title="9.ServletRequset接口"></a>9.ServletRequset接口</h2><p>Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。</p>
<p>让我们来看一看ServletRequest接口的部分内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span></span>;<span class="comment">//返回请求主体的字节数</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;<span class="comment">//返回主体的MIME类型</span></span><br><span class="line">    <span class="function">String <span class="title">getParameter</span><span class="params">(String var1)</span></span>;<span class="comment">//返回请求参数的值.它是在ServletRequest中最常用的方法，可用于获取查询字符串的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-ServletResponse接口"><a href="#10-ServletResponse接口" class="headerlink" title="10.ServletResponse接口"></a>10.ServletResponse接口</h2><p>   javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p>
<p>让我们也来看看ServletResponse内部定义了哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCharacterEncoding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//返回了一个可以向客户端发送文本的PrintWriter对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCommitted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(Locale var1)</span></span>;</span><br><span class="line"><span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的getWriter方法，它返回了一个可以向客户端发送文本的的Java.io.PrintWriter对象。默认情况下，<font color="red"><strong>PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。</strong></font></p>
<p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。</p>
<p> 还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送<strong>二进制数据</strong>的。</p>
<p>在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。</p>
<h2 id="11-ServletConfig接口"><a href="#11-ServletConfig接口" class="headerlink" title="11.ServletConfig接口"></a>11.ServletConfig接口</h2><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。</p>
<p>其中几个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletName</span><span class="params">()</span></span>;<span class="comment">//获得Servlet在web. xml中配置的name的值.</span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span> <span class="params">(String name)</span></span>;<span class="comment">//获得Servlet的初始化参数.</span></span><br><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span></span>;<span class="comment">//获得所有Servlet的初始化参数的名称.</span></span><br></pre></td></tr></table></figure>

<h2 id="12-ServletContext对象"><a href="#12-ServletContext对象" class="headerlink" title="12.ServletContext对象"></a>12.ServletContext对象</h2><p><font color="red"><strong>ServletContext对象表示Servlet应用程序。</strong></font>每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。</p>
<p>通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。</p>
<p>那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，<font color="red"><strong>因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。</strong></font></p>
<p>ServletContext中的下列方法负责处理属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String var1)</span></span>;</span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String var1)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="13-GenericServlet抽象类"><a href="#13-GenericServlet抽象类" class="headerlink" title="13.GenericServlet抽象类"></a>13.GenericServlet抽象类</h2><p>​    前面我们编写Servlet一直是通过实现Servlet接口来编写的，但是，使用这种方法，则必须要实现Servlet接口中定义的所有的方法，即使有一些方法中没有任何东西也要去实现，并且还需要自己手动的维护ServletConfig这个对象的引用。因此，这样去实现Servlet是比较麻烦的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br></pre></td></tr></table></figure>

<p>​    幸好，GenericServlet抽象类的出现很好的解决了这个问题。本着尽可能使代码简洁的原则，GenericServlet实现了Servlet和ServletConfig接口，下面是GenericServlet抽象类的具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE = <span class="string">"javax.servlet.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings = ResourceBundle.getBundle(<span class="string">"javax.servlet.LocalStrings"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameter(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getInitParameterNames();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="keyword">this</span>.getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletConfig sc = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sc.getServletName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其中，GenericServlet抽象类相比于直接实现Servlet接口，有以下几个好处：</p>
<ul>
<li>1.为Servlet接口中的所有方法提供了默认的实现，则程序员需要什么就直接改什么，不再需要把所有的方法都自己实现了。</li>
<li>2.提供方法，包围ServletConfig对象中的方法。</li>
<li>3.将init( )方法中的ServletConfig参数赋给了一个内部的ServletConfig引用从而来保存ServletConfig对象，不需要程序员自己去维护ServletConfig了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们发现在GenericServlet抽象类中还存在着另一个没有任何参数的Init()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>设计者的初衷到底是为了什么呢？在第一个带参数的init（）方法中就已经把ServletConfig对象传入并且通过引用保存好了，完成了Servlet的初始化过程，那么为什么后面还要加上一个不带任何参数的init（）方法呢？</p>
<p>我们知道，抽象类是无法直接产生实例的，需要另一个类去继承这个抽象类，那么就会发生方法覆盖的问题，如果在类中覆盖了GenericServlet抽象类的init（）方法，那么程序员就必须手动的去维护ServletConfig对象了，还得调用super.init(servletConfig）方法去调用父类GenericServlet的初始化方法来保存ServletConfig对象，这样会给程序员带来很大的麻烦。GenericServlet提供的第二个不带参数的init( )方法，就是为了解决上述问题的。</p>
<p>这个不带参数的init（）方法，是在ServletConfig对象被赋给ServletConfig引用后，由第一个带参数的init(ServletConfig servletconfig)方法调用的，那么这意味着，当程序员如果需要覆盖这个GenericServlet的初始化方法，则只需要覆盖那个不带参数的init( )方法就好了，此时，servletConfig对象仍然有GenericServlet保存着。</p>
<p>说了这么多，通过扩展GenericServlet抽象类，就不需要覆盖没有计划改变的方法。因此，代码将会变得更加的简洁，程序员的工作也会减少很多。</p>
<p>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p>
<h2 id="14-javax-servlet-http包内容"><a href="#14-javax-servlet-http包内容" class="headerlink" title="14.javax.servlet.http包内容"></a>14.javax.servlet.http包内容</h2><p>之所以所HttpServlet要比GenericServlet强大，其实也是有道理的。HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http包是Servlet API中的第二个包，其中包含了用于编写Servlet应用程序的类和接口。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。</p>
<p><img src="/../images/Servlet/image-20200702203329608.png" alt="image-20200702203329608"></p>
<h2 id="15-HttpServlet抽象类"><a href="#15-HttpServlet抽象类" class="headerlink" title="15.HttpServlet抽象类"></a>15.HttpServlet抽象类</h2><p>​    HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</p>
<p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServletRequest</span> <span class="keyword">extends</span> <span class="title">ServletRequest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HttpServletResponse</span> <span class="keyword">extends</span> <span class="title">ServletResponse</span></span></span><br></pre></td></tr></table></figure>

<p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法:</p>
<p>首先来看GenericServlet抽象类中是如何定义service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure>

<p> 我们看到是一个抽象方法，也就是HttpServlet要自己去实现这个service方法，我们在看看HttpServlet是怎么覆盖这个service方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request = (HttpServletRequest)req;</span><br><span class="line">        response = (HttpServletResponse)res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   我们发现，HttpServlet中的service方法把接收到的ServletRequsest类型的对象转换成了HttpServletRequest类型的对象，把ServletResponse类型的对象转换成了HttpServletResponse类型的对象。之所以能够这样强制的转换，<font color="red"><strong>是因为在调用Servlet的Service方法时，Servlet容器总会传入一个HttpServletRequest对象和HttpServletResponse对象，预备使用HTTP。</strong></font>因此，转换类型当然不会出错了。</p>
<p>转换之后，service方法把两个转换后的对象传入了另一个service方法，那么我们再来看看这个方法是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现，这个service方法的参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象。</p>
<p>接下来我们再看看service方法是如何工作的，我们会发现在service方法中还是没有任何的服务逻辑，但是却在解析HttpServletRequest中的方法参数，并调用以下方法之一：doGet,doPost,doHead,doPut,doTrace,doOptions和doDelete。这7种方法中，每一种方法都表示一个Http方法。doGet和doPost是最常用的。所以，如果我们需要实现具体的服务逻辑，不再需要覆盖service方法了，只需要覆盖doGet或者doPost就好了。</p>
<p><font color="red"><strong>总之，HttpServlet有两个特性是GenericServlet所不具备的：</strong></font></p>
<p>1.不用覆盖service方法，而是覆盖doGet或者doPost方法。少数情况下,还会覆盖其他的5个方法。</p>
<p>2.使用的是HttpServletRequest和HttpServletResponse对象。</p>
<h2 id="16-HttpServletRequest接口"><a href="#16-HttpServletRequest接口" class="headerlink" title="16.HttpServletRequest接口"></a>16.HttpServletRequest接口</h2><p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getContextPath</span><span class="params">()</span></span>;<span class="comment">//返回请求上下文的请求URI部分</span></span><br><span class="line">Cookie[] getCookies();<span class="comment">//返回一个cookie对象数组</span></span><br><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String var1)</span></span>;<span class="comment">//返回指定HTTP标题的值</span></span><br><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>;<span class="comment">//返回生成这个请求HTTP的方法名称</span></span><br><span class="line"><span class="function">String <span class="title">getQueryString</span><span class="params">()</span></span>;<span class="comment">//返回请求URL中的查询字符串</span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span>;<span class="comment">//返回与这个请求相关的会话对象</span></span><br></pre></td></tr></table></figure>

<h2 id="17-HttpServletRequest内封装的请求"><a href="#17-HttpServletRequest内封装的请求" class="headerlink" title="17.HttpServletRequest内封装的请求"></a>17.HttpServletRequest内封装的请求</h2><p>​    Request代表请求，所以我们可以通过该对象分别获得HTTP请求的请求行，请求头和请求体。</p>
<p><img src="/../images/Servlet/image-20200702203353091.png" alt="image-20200702203353091"></p>
<h3 id="17-1通过request获得请求行"><a href="#17-1通过request获得请求行" class="headerlink" title="17.1通过request获得请求行"></a>17.1通过request获得请求行</h3><p>假设查询字符串为：username=zhangsan&amp;password=123</p>
<p>获得客户端的请求方式：String getMethod()</p>
<p>获得请求的资源：</p>
<p>String getRequestURI()</p>
<p>StringBuffer getRequestURL()</p>
<p>String getContextPath() —web应用的名称</p>
<p>String getQueryString() —- get提交url地址后的参数字符串</p>
<h3 id="17-2通过request获得请求头"><a href="#17-2通过request获得请求头" class="headerlink" title="17.2通过request获得请求头"></a>17.2通过request获得请求头</h3><p>long getDateHeader(String name)</p>
<p>String getHeader(String name)</p>
<p>Enumeration getHeaderNames()</p>
<p>Enumeration getHeaders(String name)</p>
<p>int getIntHeader(String name)</p>
<p>referer头的作用：执行该此访问的的来源，做防盗链</p>
<h3 id="17-3通过request获得请求体"><a href="#17-3通过request获得请求体" class="headerlink" title="17.3通过request获得请求体"></a>17.3通过request获得请求体</h3><p>请求体中的内容是通过post提交的请求参数，格式是：</p>
<p>username=zhangsan&amp;password=123&amp;hobby=football&amp;hobby=basketball</p>
<p>key ———————- value</p>
<p>username                              [zhangsan]</p>
<p>password                              [123]</p>
<p>hobby                                     [football，basketball]                                       </p>
<p>以上面参数为例，通过以下方法获得请求参数：</p>
<p>String getParameter(String name)</p>
<p>String[] getParameterValues(String name)</p>
<p>Enumeration getParameterNames()</p>
<p>Map&lt;String,String[]&gt; getParameterMap()</p>
<pre><code>注意：get请求方式的请求参数 上述的方法一样可以获得。</code></pre><h2 id="18-Request乱码问题的解决方法"><a href="#18-Request乱码问题的解决方法" class="headerlink" title="18.Request乱码问题的解决方法"></a>18.Request乱码问题的解决方法</h2><p>​    在前面我们讲过，在service中使用的编码解码方式默认为：ISO-8859-1编码，但此编码并不支持中文，因此会出现乱码问题，所以我们需要手动修改编码方式为UTF-8编码，才能解决中文乱码问题:</p>
<ol>
<li>解决post提交方式的乱码：request.setCharacterEncoding(“UTF-8”);</li>
<li>解决get提交的方式的乱码：parameter = newString(parameter.getbytes(“iso8859-1”),”utf-8”); </li>
</ol>
<h2 id="19-HttpServletResponse接口"><a href="#19-HttpServletResponse接口" class="headerlink" title="19.HttpServletResponse接口"></a>19.HttpServletResponse接口</h2><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。    由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p>
<h3 id="19-1HttpServletResponse内封装的响应"><a href="#19-1HttpServletResponse内封装的响应" class="headerlink" title="19.1HttpServletResponse内封装的响应"></a>19.1HttpServletResponse内封装的响应</h3><p><img src="/../images/Servlet/image-20200702203414720.png" alt="image-20200702203414720"></p>
<h3 id="19-2通过Response设置响应"><a href="#19-2通过Response设置响应" class="headerlink" title="19.2通过Response设置响应"></a>19.2通过Response设置响应</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(Cookie var1)</span></span>;<span class="comment">//给这个响应添加一个cookie</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;<span class="comment">//给这个请求添加一个响应头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//发送一条响应码，讲浏览器跳转到指定的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;<span class="comment">//设置响应行的状态码</span></span><br><span class="line"></span><br><span class="line">addHeader(String name, String value)</span><br><span class="line">addIntHeader(String name, <span class="keyword">int</span> value)</span><br><span class="line">addDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setHeader(String name, String value)</span><br><span class="line">setDateHeader(String name, <span class="keyword">long</span> date)</span><br><span class="line">setIntHeader(String name, <span class="keyword">int</span> value)</span><br></pre></td></tr></table></figure>

<p>其中，add表示添加，而set表示设置</p>
<p>PrintWriter getWriter()</p>
<p>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。</p>
<p>ServletOutputStream getOutputStream()</p>
<p>获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节(二进制数据)，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。</p>
<p><font color="red"><strong>注意：虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常.</strong></font></p>
<h3 id="19-3Response的乱码问题"><a href="#19-3Response的乱码问题" class="headerlink" title="19.3Response的乱码问题"></a>19.3Response的乱码问题</h3><p>原因：response缓冲区的默认编码是iso8859-1，此码表中没有中文。所以需要更改response的编码方式：<img src="/../images/Servlet/image-20200702203439847.png" alt="image-20200702203439847"></p>
<h3 id="19-4-Response的工作流程"><a href="#19-4-Response的工作流程" class="headerlink" title="19.4 Response的工作流程"></a>19.4 Response的工作流程</h3><p><img src="/../images/Servlet/image-20200702203451765.png" alt="image-20200702203451765"></p>
<h2 id="20-Servlet的工作流程"><a href="#20-Servlet的工作流程" class="headerlink" title="20.Servlet的工作流程"></a>20.Servlet的工作流程</h2><p><img src="/../images/Servlet/image-20200702203504410.png" alt="image-20200702203504410"></p>
<h2 id="21-ServletContextListener（Servlet全局监听器）"><a href="#21-ServletContextListener（Servlet全局监听器）" class="headerlink" title="21. ServletContextListener（Servlet全局监听器）"></a>21. ServletContextListener（Servlet全局监听器）</h2><p>首先要说明的是，ServletContextListener是一个接口，我们随便写一个类，只要这个类实现了ServletContextListener接口，那么这个类就实现了【监听ServletContext】的功能。那么，这个神奇的接口是如何定义的呢？我们来看一下这个接口的内部情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在这个接口中只声明了两个方法，分别是void contextInitialized(ServletContextEvent var1)和void contextDestroyed(ServletContextEvent var1)方法，所以，我们很容易的就能猜测到，ServletContext的生命只有两种，分别是：</p>
<p>1.ServletContext初始化。（应用start时）———-&gt;Servlet容器调用void contextInitialized(ServletContextEvent var1)</p>
<p>2.ServletContext销毁。（应用stop时）———-&gt;Servlet容器调用 void contextDestroyed(ServletContextEvent var1)</p>
<p>因此，我们大概能够猜到ServletContextListener的工作机制了，当应用启动时，ServletContext进行初始化，然后Servlet容器会自动调用正在监听ServletContext的ServletContextListener的void contextInitialized(ServletContextEvent var1)方法，并向其传入一个ServletContextEvent对象。当应用停止时，ServletContext被销毁，此时Servlet容器也会自动地调用正在监听ServletContext的ServletContextListener的void contextDestroyed(ServletContextEvent var1)方法。</p>
<h2 id="22-【进阶】ServletContextListener在Spring中的应用"><a href="#22-【进阶】ServletContextListener在Spring中的应用" class="headerlink" title="22.【进阶】ServletContextListener在Spring中的应用"></a>22.【进阶】ServletContextListener在Spring中的应用</h2><p>Spring容器是如何借用ServletContextListener这个接口来实例化的。</p>
<p>首先让我们再来回顾一下ServletContext的概念，ServletContext翻译成中文叫做“Servlet上下文”或者“Servlet全局”，其实ServletContext就是一个“域对象”，它存在于整个应用中，并在在整个应用中有且仅有1份，它表示了当前整个应用的“状态”，你也可以理解为某个时刻的ServletContext代表了这个应用在某个时刻的“一张快照”，这张“快照”里面包含了有关应用的许多信息，应用的所有组件都可以从ServletContext获取当前应用的状态信息。ServletContext随着程序的启动而创建，随着程序的停止而销毁。通俗点说，我们可以往这个ServletContext域对象中“存东西”，然后也可以在别的地方中“取出来”。</p>
<p>我们知道，Spring容器可以通过：</p>
<p>ApplicationContext ctx=new ClassPathXmlApplicationContext(“配置文件的路径”）;</p>
<p>显示地实例化一个Spring IOC容器。也可以像下面一样，在web.xml中注册Spring IOC容器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">context</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line">        classpath:applicationContext.xml</span><br><span class="line">    &lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<p>其中的监听器类【org.springframework.web.context.ContextLoaderListener】实现了ServletContextListener接口，能够监听ServletContext的生命周期中的“初始化”和“销毁”。注意，这个【org.springframework.web.context.ContextLoaderListener】监听器类当然不是我们自己写的哦，是人家Spring团队写的，我们只要拿来用就行了。当然，别忘记导入相关的Jar包。（spring-web-4.2.4.RELEASE.jar）</p>
<p>那么，Spring团队给我们提供的这个监听器类是如何实现：当ServletContext初始化后，Spring IOC容器也能跟着初始化的呢？怀着好奇心，让我们再来看一看【org.springframework.web.context.ContextLoaderListener】的内部实现情况吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注下面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------------------------重点关注上面这里哦！-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，【org.springframework.web.context.ContextLoaderListener】这个类实现了ServletContextListener接口中的两个方法，其中，当ServletContext初始化后， public void contextInitialized(ServletContextEvent event)方法被调用，接下来执行initWebApplicationContext(event.getServletContext())方法，但是我们发现这个方法并没有在这个类中声明</p>
<p>分析到这一步，我们发现Spring容器在这个方法中被实例化了。接下来，就让我们整理一下整体的思路：</p>
<p>当Servlet容器启动时，ServletContext对象被初始化，然后Servlet容器调用web.xml中注册的监听器的public void contextInitialized(ServletContextEvent event)方法，而在监听器中，调用了this.initWebApplicationContext(event.getServletContext())方法，在这个方法中实例化了Spring IOC容器。即ApplicationContext对象。</p>
<p>因此，当ServletContext创建时我们可以创建applicationContext对象，当ServletContext销毁时，我们可以销毁applicationContext对象。这样applicationContext就和ServletContext“共生死了”。</p>
<h2 id="原博客链接"><a href="#原博客链接" class="headerlink" title="原博客链接"></a>原博客链接</h2><p><a href="https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80292110?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase</a></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2020/07/09/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ol>
<li>Ctrl+Alt+B——进入方法</li>
<li>Ctrl+R——查找某个变量名或者方法名</li>
</ol>
]]></content>
      <categories>
        <category>快捷键</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2020/07/06/CSS/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Html和CSS、JavaScript的关系，学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言。下面我们就来了解下这三门技术都是用来实现什么的：</p>
<ol>
<li>HTML是网页内容的载体，是名词。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。</li>
<li>CSS样式是表现。就像网页的外衣，是形容词。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。</li>
<li>JavaScript是用来实现网页上的特效效果，是动词。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。</li>
</ol>
<h1 id="CSS定义"><a href="#CSS定义" class="headerlink" title="CSS定义"></a>CSS定义</h1><p>层叠样式表全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。属性和属性值用冒号分隔开，以分号结尾(这些符号都是英文的)。</p>
<p>使用CSS样式的一个好处是通过定义某个样式，可以让不同网页位置的文字有着统一的字体、字号或者颜色等。</p>
<h2 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h2><p>从CSS 样式代码插入的形式来看基本可以分为：内联式、嵌入式和外部式三种</p>
<h2 id="内联式css样式"><a href="#内联式css样式" class="headerlink" title="内联式css样式"></a>内联式css样式</h2><p>就是把css代码直接写在现有的HTML标签中，如下面代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;p style="color:red"&gt;这里文字是红色。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- css样式代码要写在style=""双引号中，如果有多条css样式代码设置可以写在一起，分号隔开。如下代码：--&gt;</span><br><span class="line">&lt;p style="color:red;font-size:12px"&gt;这里文字是红色。&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入式css样式，"><a href="#嵌入式css样式，" class="headerlink" title="嵌入式css样式，"></a>嵌入式css样式，</h2><p>就是可以把css样式表放到head中用<style type="text/css"></style>标签包裹起来。如下面代码实现把三个<span>标签中的文字设置为红色。</p>
<p>嵌入式css样式必须写在<style></style>之间，并且一般情况下嵌入式css样式写在<head></head>之间。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">        <span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span><br><span class="line">        ...此处写<span class="selector-tag">CSS</span>样式</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="外部式css样式"><a href="#外部式css样式" class="headerlink" title="外部式css样式"></a>外部式css样式</h2><p>外联式：就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在<head>内（注意不是在<style>标签内）使用<link>标签将css样式文件链接到HTML文件内，如下面代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、css样式文件名称以有意义的英文字母命名，如 main.css。<br>2、rel=”stylesheet” ，type=”text/css” 是固定写法不可修改。<br>3、<link>标签位置一般写在<head>标签之内。</p>
<p>如果非要写在<style>标签，可以这样</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">        <span class="keyword">@import</span> <span class="string">"My.css"</span>; 此处注意<span class="selector-class">.css</span>文件的路径</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="样式的应用顺序："><a href="#样式的应用顺序：" class="headerlink" title="样式的应用顺序："></a>样式的应用顺序：</h2><ul>
<li>行内样式优先级最高</li>
<li>针对相同的样式属性，不同的样式属性将以合并的方式呈现</li>
<li>相同样式并且相同属性，呈现方式在<head>中的顺序决定，后面会覆盖前面属性</li>
<li>!important 指定样式规则应用最优先</li>
</ul>
<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，形式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> &#123;<span class="attribute">property</span>: value;<span class="attribute">property</span>: value;<span class="attribute">property</span>: value;<span class="attribute">property</span>: value;&#125;</span><br></pre></td></tr></table></figure>

<p>在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><h4 id="1-标签选择器"><a href="#1-标签选择器" class="headerlink" title="1 标签选择器"></a>1 标签选择器</h4><p>标签选择器其实就是html代码中的标签。如的&lt; html&gt;、&lt; body&gt;、&lt; h1&gt;、&lt; p&gt;、&lt; img&gt;。</p>
<p>例如下面代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">color</span>:black;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">color</span>:silver;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;h1&gt;这是 heading 1&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;这是 heading 2&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;这是一段普通的段落。&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>例如，如果您想把很多元素显示为灰色，可以使用类似如下的规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span>, <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">em</span> </span><br><span class="line">&#123;<span class="attribute">font</span>: <span class="number">28px</span> Verdana; <span class="attribute">color</span>: white; <span class="attribute">background</span>: black;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-类选择器"><a href="#2-类选择器" class="headerlink" title="2 类选择器"></a>2 类选择器</h4><p>匹配所有class属性中包含info的元素，（类名不能以数字开头，类名要区分大小写。）</p>
<p><strong>在 CSS 中，类选择器以一个点号显示：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名 &#123;<span class="attribute">text-align</span>: center&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、英文圆点开头<br>2、其中类选器名称可以任意起名（但不要起中文噢）<br>使用方法：</p>
<p>第一步：使用合适的标签把要修饰的内容标记起来，如下：</p>
<p>第二步：使用class=”类选择器名称”，为标签设置一个类，如下：</p>
<p>第三步：设置类选器css样式，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.stress</span>&#123;<span class="attribute">color</span>:red;&#125;<span class="comment">/*类前面要加入一个英文圆点*/</span></span><br><span class="line">&lt;span&gt;胆小如鼠&lt;/span&gt;</span><br><span class="line">&lt;span class="stress"&gt;胆小如鼠&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-ID选择器"><a href="#3-ID选择器" class="headerlink" title="3 ID选择器"></a>3 ID选择器</h4><p>使用id属性来调用样式，在一个网页中id值唯一（是W3C规范而不是规则，不会报错）。</p>
<p>语法：#ID名{样式}（ID名不能以数字开头)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#Mycolor</span> &#123;<span class="attribute">color</span>: yellow&#125;</span><br><span class="line">&lt;h3 id="Mycolor"&gt;H3&lt;/h3&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-类和ID选择器的区别"><a href="#4-类和ID选择器的区别" class="headerlink" title="4 类和ID选择器的区别"></a>4 类和ID选择器的区别</h4><p>相同点：可以应用于任何元素</p>
<p>不同点：</p>
<p>1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">下面代码是正确的：</span><br><span class="line">&lt;p&gt;三年级时，我还是一个&lt;span class="stress"&gt;胆小如鼠&lt;/span&gt;的小女孩，上课从来不敢回答老师提出的问题，生怕回答错了老师会批评我。就一直没有这个&lt;span class="stress"&gt;勇气&lt;/span&gt;来回答老师提出的问题。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span>而下面代码是错误的：<span class="selector-tag">--</span>&gt;</span><br><span class="line"> &lt;p&gt;三年级时，我还是一个&lt;span id="stress"&gt;胆小如鼠&lt;/span&gt;的小女孩，上课从来不敢回答老师提出的问题，生怕回答错了老师会批评我。就一直没有这个&lt;span id="stress"&gt;勇气&lt;/span&gt;来回答老师提出的问题。&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span>下面的代码是正确的<span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.stress</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bigsize</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;到了&lt;span class="stress bigsize"&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span>下面的代码是不正确的<span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-id">#stressid</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#bigsizeid</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;到了&lt;span id="stressid bigsizeid"&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-通用选择器"><a href="#5-通用选择器" class="headerlink" title="5 通用选择器"></a>5 通用选择器</h4><p>通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中任意标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p><img src="/../images/CSS/image-20200705184339230.png" alt="image-20200705184339230"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.<span class="selector-attr">[title]</span> &amp; <span class="selector-tag">P</span><span class="selector-attr">[title]</span></span><br><span class="line">        设置所有具有<span class="selector-tag">title</span>属性的标签元素；</span><br><span class="line">        设置所有具有<span class="selector-tag">title</span>属性的<span class="selector-tag">P</span>标签元素。</span><br><span class="line"><span class="selector-attr">[title]</span></span><br><span class="line">&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title]</span></span><br><span class="line">    &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;div title&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;p title&gt;hello&lt;/p&gt;</span><br><span class="line">2.<span class="selector-attr">[title=mk]</span></span><br><span class="line">        设置所有<span class="selector-tag">title</span>属性等于“<span class="selector-tag">mk</span>”的标签元素。 </span><br><span class="line"><span class="selector-attr">[title=<span class="string">"mk"</span>]</span></span><br><span class="line">&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;p title="mk"&gt;mk&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">2.<span class="selector-attr">[title~=mk]</span></span><br><span class="line">　　设置所有<span class="selector-tag">title</span>属性具有多个空格分隔的值、其中一个值等于“<span class="selector-tag">mk</span>”的标签元素。</span><br><span class="line"><span class="selector-attr">[title~=<span class="string">"mk"</span>]</span></span><br><span class="line">&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">  </span><br><span class="line">&lt;p title="mk Jenny"&gt;Mk&lt;/p&gt;</span><br><span class="line">&lt;p title="Jenny mk"&gt;Mk&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line"> 4.<span class="selector-attr">[title|=mk]</span></span><br><span class="line">        设置所有<span class="selector-tag">title</span>属性具有多个连字号分隔（<span class="selector-tag">hyphen-separated</span>）的值、其中一个值以"<span class="selector-tag">mk</span>"开头的标签元素。</span><br><span class="line">        例：<span class="selector-tag">lang</span>属性："<span class="selector-tag">en</span>"、"<span class="selector-tag">en-us</span>"、"<span class="selector-tag">en-gb</span>"等等</span><br><span class="line"><span class="selector-attr">[title|=<span class="string">"mk"</span>]</span></span><br><span class="line">&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">  </span><br><span class="line">&lt;p title="mk-Jenny"&gt;mk&lt;/p&gt;</span><br><span class="line"> 5.<span class="selector-attr">[title^=Nick]</span></span><br><span class="line">        设置属性值以指定值开头的每个标签元素。</span><br><span class="line"><span class="selector-attr">[title^=<span class="string">"mk"</span>]</span></span><br><span class="line">    &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;p title="mkJenny"&gt;mk&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line"> 6.<span class="selector-attr">[title$=Nick]</span></span><br><span class="line">        设置属性值以指定值结尾的每个标签元素。</span><br><span class="line"><span class="selector-attr">[title$=<span class="string">"mk"</span>]</span></span><br><span class="line">    &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;p title="Jenny mk"&gt;mk&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line"> 7.<span class="selector-attr">[title*=Nick]</span></span><br><span class="line">        设置属性值中包含指定值的每个元素</span><br><span class="line"><span class="selector-attr">[title*=<span class="string">"mk"</span>]</span></span><br><span class="line">    &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;p title="SmkJenny"&gt;mk&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><h4 id="1-多元素组合选择器"><a href="#1-多元素组合选择器" class="headerlink" title="1 多元素组合选择器"></a>1 多元素组合选择器</h4><p>同时匹配两个或多个标签，用逗号隔开</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>，<span class="selector-tag">a</span>，<span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">&lt;p&gt;段落&lt;/p&gt;</span><br><span class="line">&lt;a&gt;link&lt;/a&gt;</span><br><span class="line">&lt;div&gt;kuai&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-后代元素选择器"><a href="#2-后代元素选择器" class="headerlink" title="2 后代元素选择器"></a>2 后代元素选择器</h4><p> <strong>后代选择器（descendant selector）又称为包含选择器。后代选择器可以选择作为某元素后代的元素。</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">匹配所有<span class="selector-tag">div</span>标签里嵌套的<span class="selector-tag">P</span>标签，之间用空格分隔。</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">  </span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;p&gt;pppppp&lt;/p&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;p&gt;pppppp&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-子代元素选择器"><a href="#3-子代元素选择器" class="headerlink" title="3 子代元素选择器"></a>3 子代元素选择器</h4><p>　<strong>与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素子元素的元素。</strong>　</p>
<p>即，它不能选择多重嵌套的子标签进行样式更改，只能更改指定的嵌套位置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">匹配所有<span class="selector-tag">div</span>标签里嵌套的子<span class="selector-tag">P</span>标签，之间用&gt;分隔。</span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">  </span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;p&gt;div&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;div&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-毗邻元素选择器"><a href="#4-毗邻元素选择器" class="headerlink" title="4 毗邻元素选择器"></a>4 毗邻元素选择器</h4><p>　　 匹配所有紧随div标签之后的同级标签P，之间用+分隔（只能匹配一个）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> + <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line">  </span><br><span class="line">&lt;div&gt;div&lt;/div&gt;</span><br><span class="line">&lt;p&gt;ppp&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h3><p>它允许给html不存在的标签设置样式，比如给html中一个标签元素鼠标滑过的状态设置字体颜色：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line">这行代码会使被&lt;a&gt;&lt;/a&gt;标签包裹的文字内容中的“胆小如鼠”字体颜色在鼠标滑过时变为红色</span><br></pre></td></tr></table></figure>

<p><strong>1. link、hover、active、visited</strong></p>
<ul>
<li>a:link（未访问的链接状态）,用于定义了常规的链接状态。 </li>
<li>a:visited（已访问过的链接状态）,可以看出已经访问过的链接。</li>
<li>a:hover（鼠标放在链接上的状态）,用于产生视觉效果。</li>
<li>a:active（在链接上按下鼠标时的状态）。</li>
</ul>
<p>当为链接的不同状态设置样式时，请按照以下次序规则：</p>
<ul>
<li>a:hover 必须位于 a:link 和 a:visited 之后</li>
<li>a:active 必须位于 a:hover 之后</li>
</ul>
<p><strong>2.</strong> <strong>before、after</strong></p>
<ul>
<li>P:before 在每个<p>元素的内容之前插入内容;</li>
<li>P:after 在每个<p>元素的内容之后插入内容。</li>
</ul>
<h1 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h1><h2 id="1-颜色属性："><a href="#1-颜色属性：" class="headerlink" title="1. 颜色属性："></a>1. 颜色属性：</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a><strong>color</strong></h3><ul>
<li>HEX（十六进制色：color: #FFFF00 –&gt; 缩写：#FF0）</li>
<li>RGB（红绿蓝，使用方式：color:rgb(255,255,0)或者color:rgb(100%,100%,0%)）</li>
<li>RGBA（红绿蓝透明度，A是透明度在0~1之间取值。使用方式：color:rgba(255,255,0,0.5)）</li>
<li>HSL（CSS3有效,H表示色调，S表示饱和度，L表示亮度，使用方式：color:hsl(360,100%,50%)）</li>
<li>HSLA（和HSL相似，A表示Alpha透明度，取值0~1之间。）</li>
</ul>
<h3 id="transparent"><a href="#transparent" class="headerlink" title="transparent"></a><strong>transparent</strong></h3><ul>
<li>全透明，使用方式：color: transparent</li>
</ul>
<h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a><strong>opacity</strong></h3><ul>
<li>元素的透明度，语法：opacity: 0.5;</li>
<li>属性值在0.0到1.0范围内，0表示透明，1表示不透明。</li>
<li>filter滤镜属性（只适用于早期的IE浏览器，语法：filter:alpha(opacity:20);）。</li>
</ul>
<h2 id="2-字体属性"><a href="#2-字体属性" class="headerlink" title="2. 字体属性:"></a>2. 字体属性:</h2><p><img src="/../images/CSS/image-20200705203844882.png" alt="image-20200705203844882"></p>
<h3 id="font-style-用于规定斜体文本"><a href="#font-style-用于规定斜体文本" class="headerlink" title="font-style: 用于规定斜体文本"></a><strong>font-style: 用于规定斜体文本</strong></h3><ul>
<li>normal  文本正常显示</li>
<li>italic  文本斜体显示</li>
<li>oblique  文本倾斜显示</li>
</ul>
<h3 id="font-weight-设置文本的粗细"><a href="#font-weight-设置文本的粗细" class="headerlink" title="font-weight: 设置文本的粗细"></a><strong>font-weight: 设置文本的粗细</strong></h3><ul>
<li>normal（默认）</li>
<li>bold（加粗）</li>
<li>bolder（相当于<strong>和<b>标签）</li>
<li>lighter （常规）</li>
<li>100 ~ 900 整百（400=normal，700=bold）</li>
</ul>
<h3 id="font-size-设置字体的大小"><a href="#font-size-设置字体的大小" class="headerlink" title="font-size: 设置字体的大小"></a><strong>font-size: 设置字体的大小</strong></h3><ul>
<li>默认值：medium</li>
<li><absolute-size>可选参数值：xx-small、 x-small、 small、 medium、 large、 x-large、 xx-large</li>
<li><relative-size>相对于父标签中字体的尺寸进行调节。可选参数值：smaller、 larger</li>
<li><percentage>百分比指定文字大小。</li>
<li><length>用长度值指定文字大小，不允许负值。</li>
</ul>
<h3 id="font-family：字体名称"><a href="#font-family：字体名称" class="headerlink" title="font-family：字体名称"></a><strong>font-family：字体名称</strong></h3><ul>
<li>使用逗号隔开多种字体（优先级从前向后，如果系统中没有找到当前字体，则往后面寻找）</li>
</ul>
<h3 id="font：简写属性"><a href="#font：简写属性" class="headerlink" title="font：简写属性"></a><strong>font：简写属性</strong></h3><ul>
<li>语法：font：字体大小/行高 字体;（字体要在最后）</li>
</ul>
<h2 id="3-文本属性"><a href="#3-文本属性" class="headerlink" title="3. 文本属性:"></a>3. 文本属性:</h2><p><img src="/../images/CSS/image-20200705203626058.png" alt="image-20200705203626058"> </p>
<h3 id="white-space-设置元素中空白的处理方式"><a href="#white-space-设置元素中空白的处理方式" class="headerlink" title="white-space: 设置元素中空白的处理方式"></a><strong>white-space: 设置元素中空白的处理方式</strong></h3><ul>
<li>normal：默认处理方式。</li>
<li>pre：保留空格，当文字超出边界时不换行</li>
<li>nowrap：不保留空格，强制在同一行内显示所有文本，直到文本结束或者碰到br标签</li>
<li>pre-wrap：保留空格，当文字碰到边界时换行</li>
<li>pre-line：不保留空格，保留文字的换行，当文字碰到边界时换行</li>
</ul>
<h3 id="direction-规定文本的方向"><a href="#direction-规定文本的方向" class="headerlink" title="direction: 规定文本的方向"></a><strong>direction: 规定文本的方向</strong></h3><ul>
<li>ltr 默认，文本方向从左到右。</li>
<li>rtl 文本方向从右到左。</li>
</ul>
<h3 id="text-align-文本的水平对齐方式"><a href="#text-align-文本的水平对齐方式" class="headerlink" title="text-align: 文本的水平对齐方式"></a><strong>text-align:</strong> <strong>文本的水平对齐方式</strong></h3><ul>
<li>left</li>
<li>center</li>
<li>right</li>
</ul>
<h3 id="line-height-文本行高"><a href="#line-height-文本行高" class="headerlink" title="line-height: 文本行高"></a><strong>line-height:</strong> <strong>文本行高</strong></h3><ul>
<li>normal 默认</li>
</ul>
<h3 id="vertical-align-文本-所在行高的垂直对齐方式"><a href="#vertical-align-文本-所在行高的垂直对齐方式" class="headerlink" title="vertical-align: \文本*所在行高的垂直对齐方式*"></a><strong>vertical-align: \</strong>文本*<em>所在行高的垂直对齐方式*</em></h3><ul>
<li>baseline 默认</li>
<li>sub 垂直对齐文本的下标，和<sub>标签一样的效果</li>
<li>super 垂直对齐文本的上标，和<sup>标签一样的效果</li>
<li>top 对象的顶端与所在容器的顶端对齐</li>
<li>text-top 对象的顶端与所在行文字顶端对齐</li>
<li>middle 元素对象基于基线垂直对齐</li>
<li>bottom 对象的底端与所在行的文字底部对齐</li>
<li>text-bottom 对象的底端与所在行文字的底端对齐</li>
</ul>
<h3 id="text-indent-文本缩进"><a href="#text-indent-文本缩进" class="headerlink" title="text-indent: 文本缩进"></a><strong>text-indent: 文本缩进</strong></h3><h3 id="letter-spacing-添加字母之间的空白"><a href="#letter-spacing-添加字母之间的空白" class="headerlink" title="letter-spacing: 添加字母之间的空白"></a><strong>letter-spacing: 添加字母之间的空白</strong></h3><h3 id="word-spacing-添加每个单词之间的空白"><a href="#word-spacing-添加每个单词之间的空白" class="headerlink" title="word-spacing: 添加每个单词之间的空白"></a><strong>word-spacing: 添加每个单词之间的空白</strong></h3><h3 id="text-transform-属性控制文本的大小写"><a href="#text-transform-属性控制文本的大小写" class="headerlink" title="text-transform: 属性控制文本的大小写"></a><strong>text-transform: 属性控制文本的大小写</strong></h3><ul>
<li>capitalize 文本中的每个单词以大写字母开头。</li>
<li>uppercase 定义仅有大写字母。</li>
<li>lowercase 定义仅有小写字母。</li>
</ul>
<h3 id="text-overflow-文本溢出样式"><a href="#text-overflow-文本溢出样式" class="headerlink" title="text-overflow: 文本溢出样式"></a><strong>text-overflow:</strong> <strong>文本溢出样式</strong></h3><ul>
<li>clip 修剪文本。</li>
<li>ellipsis 显示省略符号…来代表被修剪的文本。</li>
<li>string 使用给定的字符串来代表被修剪的文本</li>
</ul>
<h3 id="text-decoration-文本的装饰"><a href="#text-decoration-文本的装饰" class="headerlink" title="text-decoration: 文本的装饰"></a><strong>text-decoration: 文本的装饰</strong></h3><ul>
<li>none 默认。</li>
<li>underline 下划线。</li>
<li>overline 上划线。</li>
<li>line-through 中线。</li>
</ul>
<h3 id="text-shadow：文本阴影"><a href="#text-shadow：文本阴影" class="headerlink" title="text-shadow：文本阴影"></a><strong>text-shadow：文本阴影</strong></h3><ul>
<li>第一个参数是左右位置</li>
<li>第二个参数是上下位置</li>
<li>第三个参数是虚化效果</li>
<li>第四个参数是颜色</li>
<li>text-shadow: 5px 5px 5px #888;</li>
</ul>
<h3 id="word-wrap：自动换行"><a href="#word-wrap：自动换行" class="headerlink" title="word-wrap：自动换行"></a><strong>word-wrap：自动换行</strong></h3><ul>
<li>word-wrap: break-word;</li>
</ul>
<h2 id="4-背景属性"><a href="#4-背景属性" class="headerlink" title="4. 背景属性"></a>4. 背景属性</h2><p><img src="/../images/CSS/image-20200705203749036.png" alt="image-20200705203749036"></p>
<h3 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color: 背景颜色"></a><strong>background-color:</strong> <strong>背景颜色</strong></h3><h3 id="background-image-设置图像为背景"><a href="#background-image-设置图像为背景" class="headerlink" title="background-image 设置图像为背景"></a><strong>background-image 设置图像为背景</strong></h3><ul>
<li><p>url(“<a href="http://images.cnblogs.com/cnblogs_com/suoning/845162/o_ns.png&quot;" target="_blank" rel="noopener">http://images.cnblogs.com/cnblogs_com/suoning/845162/o_ns.png&quot;</a>);  图片地址</p>
</li>
<li><p>background-image:linear-gradient(green,blue,yellow,red,black); 颜色渐变效果</p>
</li>
</ul>
<h3 id="background-position-设置背景图像的位置坐标"><a href="#background-position-设置背景图像的位置坐标" class="headerlink" title="background-position 设置背景图像的位置坐标"></a><strong>background-position 设置背景图像的位置坐标</strong></h3><ul>
<li>background-position: center center; 图片置中，x轴center，y轴center</li>
<li>1px -195px  截取图片某部分，分别代表坐标x，y轴</li>
</ul>
<h3 id="background-repeat-设置背景图像不重复平铺"><a href="#background-repeat-设置背景图像不重复平铺" class="headerlink" title="background-repeat 设置背景图像不重复平铺"></a><strong>background-repeat 设置背景图像不重复平铺</strong></h3><ul>
<li><ul>
<li>no-repeat 设置图像不重复，常用</li>
<li>round 自动缩放直到适应并填充满整个容器</li>
<li>space 以相同的间距平铺且填充满整个容器</li>
</ul>
</li>
</ul>
<h3 id="background-attachment-背景图像是否固定或者随着页面的其余部分滚动"><a href="#background-attachment-背景图像是否固定或者随着页面的其余部分滚动" class="headerlink" title="background-attachment 背景图像是否固定或者随着页面的其余部分滚动"></a><strong>background-attachment 背景图像是否固定或者随着页面的其余部分滚动</strong></h3><h3 id="background-简写"><a href="#background-简写" class="headerlink" title="background 简写"></a><strong>background 简写</strong></h3><ul>
<li>background: url(“o_ns.png”) no-repeat 0 -196px;</li>
<li>background: url(“o_ns.png”) no-repeat center bottom 15px;</li>
<li>background: url(“o_ns.png”) no-repeat left 30px bottom 15px;</li>
</ul>
<h2 id="5-列表属性"><a href="#5-列表属性" class="headerlink" title="5. 列表属性"></a>5. 列表属性</h2><p><img src="/../images/CSS/image-20200705204458622.png" alt="image-20200705204458622"></p>
<h3 id="list-style-type-列表项标志的类型"><a href="#list-style-type-列表项标志的类型" class="headerlink" title="list-style-type: 列表项标志的类型"></a><strong>list-style-type: 列表项标志的类型</strong></h3><ul>
<li>none 去除标志</li>
<li>decimal-leading-zero;  02.</li>
<li>square;  方框</li>
<li>circle;  空心圆</li>
<li>upper-alph; &amp; disc; 实心圆</li>
</ul>
<h3 id="list-style-image：将图象设置为列表项标志"><a href="#list-style-image：将图象设置为列表项标志" class="headerlink" title="list-style-image：将图象设置为列表项标志"></a><strong>list-style-image：将图象设置为列表项标志</strong></h3><h3 id="list-style-position：列表项标志的位置"><a href="#list-style-position：列表项标志的位置" class="headerlink" title="list-style-position：列表项标志的位置"></a><strong>list-style-position：列表项标志的位置</strong></h3><ul>
<li>inside</li>
<li>outside</li>
</ul>
<h3 id="list-style：缩写"><a href="#list-style：缩写" class="headerlink" title="list-style：缩写"></a><strong>list-style：缩写</strong></h3><h2 id="页面布局："><a href="#页面布局：" class="headerlink" title="页面布局："></a>页面布局：</h2><h3 id="1-边框"><a href="#1-边框" class="headerlink" title="1. 边框"></a>1. 边框</h3><p><img src="/../images/CSS/image-20200705204716733.png" alt="image-20200705204716733"></p>
<h3 id="border-style：边框样式"><a href="#border-style：边框样式" class="headerlink" title="border-style：边框样式"></a><strong>border-style：边框样式</strong></h3><ul>
<li>solid 默认，实线</li>
<li>double 双线</li>
<li>dotted 点状线条</li>
<li>dashed 虚线</li>
</ul>
<h3 id="border-color：边框颜色"><a href="#border-color：边框颜色" class="headerlink" title="border-color：边框颜色"></a>border-color：边框颜色</h3><h3 id="border-width：边框宽度"><a href="#border-width：边框宽度" class="headerlink" title="border-width：边框宽度"></a><strong>border-width：边框宽度</strong></h3><h3 id="border-radius：圆角"><a href="#border-radius：圆角" class="headerlink" title="border-radius：圆角"></a><strong>border-radius：圆角</strong></h3><ul>
<li>1个参数：四个角都应用</li>
<li>2个参数：第一个参数应用于 左上、右下；第二个参数应用于 左下、右上</li>
<li>3个参数：第一个参数应用于 左上；第二个参数应用于 左下、右上；第三个参数应用于右下</li>
<li>4个参数：左上、右上、右下、左下（顺时针</li>
</ul>
<h3 id="border-简写"><a href="#border-简写" class="headerlink" title="border: 简写"></a><strong>border: 简写</strong></h3><ul>
<li>border: 2px yellow solid;</li>
</ul>
<h3 id="box-shadow：边框阴影"><a href="#box-shadow：边框阴影" class="headerlink" title="box-shadow：边框阴影"></a><strong>box-shadow：边框阴影</strong></h3><ul>
<li>第一个参数是左右位置</li>
<li>第二个参数是上下位置</li>
<li>第三个参数是虚化效果</li>
<li>第四个参数是颜色</li>
<li>box-shadow: 10px 10px 5px #888;</li>
</ul>
<h1 id="不常用的属性："><a href="#不常用的属性：" class="headerlink" title="不常用的属性："></a>不常用的属性：</h1><p>查看官方文档对应属性</p>
<h1 id="CSS的继承、层叠和特殊性。"><a href="#CSS的继承、层叠和特殊性。" class="headerlink" title="CSS的继承、层叠和特殊性。"></a>CSS的继承、层叠和特殊性。</h1><h2 id="1继承性"><a href="#1继承性" class="headerlink" title="1继承性"></a>1继承性</h2><p>CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。<br>但注意有一些css样式是不具有继承性的。如border:1px solid red;</p>
<h2 id="2权值"><a href="#2权值" class="headerlink" title="2权值"></a>2权值</h2><p>根据权值来判断使用哪个css样式。浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。下面是权值的规则：<br>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure>


<p>注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低</p>
<h2 id="3层叠"><a href="#3层叠" class="headerlink" title="3层叠"></a>3层叠</h2><p>我们来思考一个问题：如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？好，这一小节中的层叠帮你解决这个问题。<br>层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。<br>所以前面的css样式优先级就不难理解了：<br>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</p>
<h2 id="4重要性"><a href="#4重要性" class="headerlink" title="4重要性"></a>4重要性</h2><p>我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用!important来解决。<br>如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line">&lt;p class="first"&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>这时 p 段落中的文本会显示的red红色。注意：!important要写在分号的前面</p>
<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><h2 id="1元素分类"><a href="#1元素分类" class="headerlink" title="1元素分类"></a>1元素分类</h2><p>在讲解CSS布局之前，我们需要提前知道一些知识，在CSS中，html中的标签元素大体被分为三种不同的类型：</p>
<p>块状元素、内联元素和内联块状元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">常用的块状元素有：</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br><span class="line">常用的内联元素有：</span><br><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br><span class="line">常用的内联块状元素有：</span><br><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2元素分类–块级元素"><a href="#2元素分类–块级元素" class="headerlink" title="2元素分类–块级元素"></a>2元素分类–块级元素</h2><p>什么是块级元素？在html中&lt; div&gt;、 &lt; p&gt;、&lt; h1&gt;、&lt; form&gt;、&lt; ul&gt; 和 &lt; li&gt;就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将行内元素a转换为块状元素，从而使用a元素具有块状元素特点。<br>a{display:block;}<br>块级元素特点：<br>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。<br>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>
<h2 id="3元素分类–行内元素"><a href="#3元素分类–行内元素" class="headerlink" title="3元素分类–行内元素"></a>3元素分类–行内元素</h2><p>在html中，&lt; span&gt;、&lt; a&gt;、&lt; label&gt;、&lt; input&gt;、 &lt; img&gt;、 &lt; strong&gt; 和&lt; em&gt;就是典型的行内元素（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为行内元素。<br>行内元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高及顶部和底部边距不可设置；<br>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</p>
<h2 id="4元素分类–内联块状元素"><a href="#4元素分类–内联块状元素" class="headerlink" title="4元素分类–内联块状元素"></a>4元素分类–内联块状元素</h2><p>内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。(css2.1新增)，&lt; img&gt;、&lt; input&gt;标签就是这种内联块状标签。<br>inline-block元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p>
<h1 id="CSS框模型"><a href="#CSS框模型" class="headerlink" title="CSS框模型"></a>CSS框模型</h1><p><strong>CSS 框模型 (Box Model) 规定了元素框处理元素内容、[内边距]、[边框]和 [外边距]的方式。</strong></p>
<p>元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<p><strong>提示：</strong>背景应用于由内容和内边距、边框组成的区域。</p>
<p>内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的 margin 和 padding 设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设</p>
<p><img src="/../images/CSS/image-20200705211243112.png" alt="image-20200705211243112"></p>
<p><img src="/../images/CSS/image-20200705212214750.png" alt="image-20200705212214750"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">盒模型<span class="selector-tag">--</span>边框（一）</span><br><span class="line">盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</span><br><span class="line">如下面代码为<span class="selector-tag">div</span>来设置边框粗细为2<span class="selector-tag">px</span>、样式为实心的、颜色为红色的边框：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;</span><br><span class="line">&#125;</span><br><span class="line">上面是<span class="selector-tag">border</span>代码的缩写形式，可以分开写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">注意：</span><br><span class="line">1、<span class="selector-tag">border-style</span>（边框样式）常见样式有：</span><br><span class="line">dashed（虚线）| dotted（点线）| solid（实线）。</span><br><span class="line">2、<span class="selector-tag">border-color</span>（边框颜色）中的颜色可设置为十六进制颜色，如:</span><br><span class="line">border-color:#888;//前面的#号不要忘掉。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">盒模型<span class="selector-tag">--</span>边框（二）</span><br><span class="line">现在有一个问题，如果有想为<span class="selector-tag">p</span>标签单独设置下边框，而其它三边都不设置边框样式怎么办呢？<span class="selector-tag">css</span>样式中允许只为一个方向的边框设置样式：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-bottom</span>:<span class="number">1px</span> solid red;&#125;</span><br><span class="line">同样可以使用下面代码实现其它三边上、右、左边框的设置：</span><br><span class="line"><span class="selector-tag">border-top</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">border-right</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>; </span><br><span class="line"><span class="selector-tag">border-left</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line"></span><br><span class="line">盒模型<span class="selector-tag">--</span>边界</span><br><span class="line">元素与其它元素之间的距离可以使用边界（<span class="selector-tag">margin</span>）来设置。边界也是可分为上、右、下、左。如下代码：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br><span class="line">也可以分开写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">margin-right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">margin-left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">如果上下左右的边界都为10<span class="selector-tag">px</span>;可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">如果上下边界一样为10<span class="selector-tag">px</span>，左右一样为20<span class="selector-tag">px</span>，可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br><span class="line">总结一下：<span class="selector-tag">padding</span>和<span class="selector-tag">margin</span>的区别，<span class="selector-tag">padding</span>在边框里，<span class="selector-tag">margin</span>在边框外。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">盒模型<span class="selector-tag">--</span>填充</span><br><span class="line">元素内容与边框之间是可以设置距离的，称之为填充。填充也可分为上、右、下、左。如下代码：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br><span class="line">顺序一定不要搞混。可以分开写上面代码：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">padding-top</span>:<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">padding-right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">padding-bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">padding-left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">如果上、右、下、左的填充都为10<span class="selector-tag">px</span>;可以这么写</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">如果上下填充一样为10<span class="selector-tag">px</span>，左右一样为20<span class="selector-tag">px</span>，可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">盒模型代码简写</span><br><span class="line">还记得在讲盒模型时外边距(<span class="selector-tag">margin</span>)、内边距(<span class="selector-tag">padding</span>)和边框(<span class="selector-tag">border</span>)设置上下左右四个方向的边距是按照顺时针方向设置的：上右下左。具体应用在<span class="selector-tag">margin</span>和<span class="selector-tag">padding</span>的例子如下：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 15<span class="selector-tag">px</span> 12<span class="selector-tag">px</span> 14<span class="selector-tag">px</span>;<span class="comment">/*上设置为10px、右设置为15px、下设置为12px、左设置为14px*/</span></span><br><span class="line">通常有下面三种缩写方法:</span><br><span class="line">1、如果<span class="selector-tag">top</span>、<span class="selector-tag">right</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span>的值相同，如下面代码：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span>;</span><br><span class="line">可缩写为：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span>;</span><br><span class="line">2、如果<span class="selector-tag">top</span>和<span class="selector-tag">bottom</span>值相同、<span class="selector-tag">left</span>和 <span class="selector-tag">right</span>的值相同，如下面代码：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</span><br><span class="line">可缩写为：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 20<span class="selector-tag">px</span>;</span><br><span class="line">3、如果<span class="selector-tag">left</span>和<span class="selector-tag">right</span>的值相同，如下面代码：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 20<span class="selector-tag">px</span> 30<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</span><br><span class="line">可缩写为：</span><br><span class="line"><span class="selector-tag">margin</span><span class="selector-pseudo">:10px</span> 20<span class="selector-tag">px</span> 30<span class="selector-tag">px</span>;</span><br><span class="line">注意：<span class="selector-tag">padding</span>、<span class="selector-tag">border</span>的缩写方法和<span class="selector-tag">margin</span>是一致的。</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">颜色值缩写</span><br><span class="line">关于颜色的<span class="selector-tag">css</span>样式也是可以缩写的，当你设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。</span><br><span class="line">例子1：</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#000000</span>;&#125;</span><br><span class="line">可以缩写为：</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: <span class="number">#000</span>;&#125;</span><br><span class="line">例子2：</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: <span class="number">#336699</span>;&#125;</span><br><span class="line">可以缩写为：</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: <span class="number">#369</span>;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CSS布局模型-定位"><a href="#CSS布局模型-定位" class="headerlink" title="CSS布局模型(定位)"></a>CSS布局模型(定位)</h1><p>清楚了CSS 盒模型的基本概念、 盒模型类型， 我们就可以深入探讨网页布局的基本模型了。CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。<br>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）<br>2、浮动模型 (Float)<br>3、层模型（Layer）</p>
<h2 id="1流动模型（一）"><a href="#1流动模型（一）" class="headerlink" title="1流动模型（一）"></a>1流动模型（一）</h2><p>流动（Flow）：自上而下。<br>先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。<br>流动布局模型具有2个比较典型的特征：</p>
<p>第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。</p>
<p>第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p>
<h2 id="2浮动模型（二）"><a href="#2浮动模型（二）" class="headerlink" title="2浮动模型（二）"></a>2浮动模型（二）</h2><p>块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。任何元素在默认情况下是不能浮动的，但可以用CSS定义为浮动，如div、p、table、img等元素都可以被定义为浮动。如下代码可以实现两个div元素一行显示。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>注意：设置浮动的同时一定要先设置块状元素的宽度，且需要浮动的几个元素宽度加起来一定要小于容器元素的宽度。</p>
<h2 id="3什么是层模型？"><a href="#3什么是层模型？" class="headerlink" title="3什么是层模型？"></a>3什么是层模型？</h2><p>什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。<br>如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。<br>层模型有三种形式：<br>1、绝对定位(position: absolute)<br>2、相对定位(position: relative)<br>3、固定定位(position: fixed)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">CSS</span> <span class="selector-tag">position</span> 属性</span><br><span class="line">通过使用 <span class="selector-tag">position</span> 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">position</span> 属性值的含义：</span><br><span class="line"><span class="selector-tag">static</span></span><br><span class="line">元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。</span><br><span class="line"><span class="selector-tag">relative</span></span><br><span class="line">元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"><span class="selector-tag">absolute</span></span><br><span class="line">元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</span><br><span class="line"><span class="selector-tag">fixed</span></span><br><span class="line">元素框的表现类似于将 <span class="selector-tag">position</span> 设置为 <span class="selector-tag">absolute</span>，不过其包含块是视窗本身。</span><br></pre></td></tr></table></figure>

<p>1，层模型–绝对定位（相对于父类）<br>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。<br>如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2，层模型–相对定位（相对于以前）<br>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。<br>如下代码实现相对于以前位置向下移动50px，向右移动100px;</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>3，层模型–固定定位（相对于网页窗口）<br>固定住某一坐标。<br>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed?属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Relative与Absolute组合使用"><a href="#Relative与Absolute组合使用" class="headerlink" title="Relative与Absolute组合使用"></a>Relative与Absolute组合使用</h2><p>小伙伴们学习了12-6小节的相对定位的方法：使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，大家有没有想过可不可以相对于其它元素进行定位呢？答案是肯定的，当然可以。使用position:relative来帮忙，但是必须遵守下面规范：</p>
<p>1、参照定位的元素必须是相对定位元素的前辈元素：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div id="box1"&gt;&lt;!--参照定位的元素--&gt;</span><br><span class="line">    &lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2、参照定位的元素必须加入position:relative;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样box2就可以相对于父元素box1定位了(这里注意参照物就不是浏览器了，而可以自由设置了）</p>
<h1 id="参考链接及其文档"><a href="#参考链接及其文档" class="headerlink" title="参考链接及其文档"></a>参考链接及其文档</h1><p><a href="https://blog.csdn.net/qiushi_1990/article/details/40260447?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qiushi_1990/article/details/40260447?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
<p><a href="https://www.w3cschool.cn/css/dict" target="_blank" rel="noopener">https://www.w3cschool.cn/css/dict</a></p>
<p><a href="https://www.w3school.com.cn/cssref/pr_class_float.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/pr_class_float.asp</a></p>
<p><a href="https://www.cnblogs.com/caoyc/p/5757005.html" target="_blank" rel="noopener">https://www.cnblogs.com/caoyc/p/5757005.html</a></p>
<p>官方文档</p>
<p>链接：<a href="https://pan.baidu.com/s/1nDuFor3KZryIjIv-4PIiHg" target="_blank" rel="noopener">https://pan.baidu.com/s/1nDuFor3KZryIjIv-4PIiHg</a><br>提取码：x0r0</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>maven安装</title>
    <url>/2020/07/07/maven%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="1、去官网下载bin-zip包，3-4-x版本就行，太新了有bug"><a href="#1、去官网下载bin-zip包，3-4-x版本就行，太新了有bug" class="headerlink" title="1、去官网下载bin.zip包，3.4.x版本就行，太新了有bug"></a>1、去官网下载bin.zip包，3.4.x版本就行，太新了有bug</h4><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p>
<h4 id="2、第二步，解压文件包"><a href="#2、第二步，解压文件包" class="headerlink" title="2、第二步，解压文件包"></a>2、第二步，解压文件包</h4><p> 1.apache-maven-3.5.2-bin.zip   直接解压到指定安装路径。</p>
<p> 2.apache-maven-3.5.2-src.zip   maven源码包。</p>
<h4 id="3、第三步，配置环境变量，类似jdk环境配置"><a href="#3、第三步，配置环境变量，类似jdk环境配置" class="headerlink" title="3、第三步，配置环境变量，类似jdk环境配置"></a>3、第三步，配置环境变量，类似jdk环境配置</h4><p>1.创建MAVEN_HOME环境变量，指向maven的安装目录。</p>
<p>2.并将%MAVEN_HOME%\bin追加到PATH路径中。</p>
<p>3.调试是否安装成功，在cmd中输入 mvn -version</p>
<h4 id="4、第四步，将本地仓库（jar包目录）配置到指定路径（-可以不进行配置，默认在C盘）"><a href="#4、第四步，将本地仓库（jar包目录）配置到指定路径（-可以不进行配置，默认在C盘）" class="headerlink" title="4、第四步，将本地仓库（jar包目录）配置到指定路径（*可以不进行配置，默认在C盘）"></a>4、第四步，将本地仓库（jar包目录）配置到指定路径（*可以不进行配置，默认在C盘）</h4><p> 在maven解压目录中，conf的目录中修改settings.xml文件（D:\maven-3.5.2\conf\settings.xml）</p>
<p>可以添加新的仓库路径&lt; localRepository&gt;D:\maven-3.5.2\repository&lt; /localRepository&gt;<br><img src="../images/maven%E5%AE%89%E8%A3%85/20180125104049378.png" alt="img"></p>
<h4 id="5、第五步，配置中央仓库的镜像：（换成了阿里的，比较稳定）"><a href="#5、第五步，配置中央仓库的镜像：（换成了阿里的，比较稳定）" class="headerlink" title="5、第五步，配置中央仓库的镜像：（换成了阿里的，比较稳定）"></a>5、第五步，配置中央仓库的镜像：（换成了阿里的，比较稳定）</h4><p>setting.xml文件中Ctrl+R找mirrors，在里面加这个</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>         </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>安装教程</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlBug</title>
    <url>/2020/07/08/mysqlBug/</url>
    <content><![CDATA[<h1 id="修改mysql数据库的编码格式"><a href="#修改mysql数据库的编码格式" class="headerlink" title="修改mysql数据库的编码格式"></a>修改mysql数据库的编码格式</h1><h2 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h2><p>.  Cause: java.sql.SQLException: Incorrect string value: ‘\xE9\x84\xA2\xE5\xAF\x92’ for column ‘name…</p>
<p>后来查看了mysql数据库的编码格式发现不对于是有了下面的解决方案</p>
<h2 id="1-："><a href="#1-：" class="headerlink" title="(1)："></a>(1)：</h2><p>进入mysql的安装目录，找到my-default.ini或者my.ini配置文件，你可以将my-default.ini修改成my.ini，影响不大的；</p>
<h2 id="2-："><a href="#2-：" class="headerlink" title="(2)："></a>(2)：</h2><p>我的my.ini只有一个[mysqld]标签，其他均处于注释状态，我们在my.ini里面做两件事</p>
<p>​        在[mysqld]标签下添加：character-set-server=utf8</p>
<p>​        增加一个[client]标签，并且在[client]标签下添加：default-character-set=utf8</p>
<h2 id="3-："><a href="#3-：" class="headerlink" title="(3)："></a>(3)：</h2><p>到任务列表中重启mysql服务；</p>
<h2 id="4-："><a href="#4-：" class="headerlink" title="(4)："></a>(4)：</h2><p>进入dos界面，登录数据库，输入命令：show variables like “%char%”；如果dos界面出现的下图所示结果，说明你修改mysql编码成功啦！</p>
<p><img src="../images/mysqlBug/image-20200708002604436.png" alt="image-20200708002604436"></p>
<h2 id="5-相关命令"><a href="#5-相关命令" class="headerlink" title="(5)相关命令"></a>(5)相关命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br><span class="line">mysql -u root -p</span><br><span class="line">show variables like <span class="string">'char%'</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Bug</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>javax.annotation不可见</title>
    <url>/2020/07/08/javax-annotation%E4%B8%8D%E5%8F%AF%E8%A7%81/</url>
    <content><![CDATA[<h3 id="java-程序包-javax-annotation-不可见-Resource注解无法使用-【解决方法】"><a href="#java-程序包-javax-annotation-不可见-Resource注解无法使用-【解决方法】" class="headerlink" title="java: 程序包 javax.annotation 不可见,@Resource注解无法使用 【解决方法】"></a>java: 程序包 javax.annotation 不可见,@Resource注解无法使用 【解决方法】</h3><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a><strong>方法：</strong></h3><p>这是JDK9 出现的问题，降低版本设置为JDK8问题就解决了。</p>
<p>1、Ctrl+Alt+s 快捷键或者（鼠标右击File，再选择Settings）进入idea设置Settings页面,更改java Compiler的jdk到1.8</p>
<p>2、进入Project Structure的Project和modules都改改jdk</p>
<h3 id="欧克了"><a href="#欧克了" class="headerlink" title="欧克了"></a>欧克了</h3>]]></content>
      <categories>
        <category>Bug</category>
        <category>程序包problem</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>在插入图像前</title>
    <url>/2020/07/02/%E5%9C%A8%E6%8F%92%E5%85%A5%E5%9B%BE%E5%83%8F%E5%89%8D/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;add&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>提交前</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库时区问题</title>
    <url>/2020/07/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>You must configure either the server or JDBC driver (via the serverTimezone configuration property)</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在连接字符串后面加上<strong>?serverTimezone=UTC</strong></p>
<p>其中UTC是统一标准世界时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完整的连接字符串示例：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?serverTimezone&#x3D;UTC</span><br><span class="line"></span><br><span class="line">或者还有另一种选择：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8，这个是解决中文乱码输入问题</span><br><span class="line"></span><br><span class="line">当然也可以和上面的结合:jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Bug</category>
        <category>timezone</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>web.xml配置详解</title>
    <url>/2020/07/08/web-xml%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>客户端404</title>
    <url>/2020/07/08/%E5%AE%A2%E6%88%B7%E7%AB%AF404/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>客户端404 The origin server did not find a current representation for the target resou</p>
<p><img src="/../images/%E5%AE%A2%E6%88%B7%E7%AB%AF404/20200201162659355.png" alt="img"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>改下tomcat的路径，一般开发中直接改成斜线就可以了</p>
<p><img src="/../images/%E5%AE%A2%E6%88%B7%E7%AB%AF404/image-20200708135257509.png" alt="image-20200708135257509"></p>
]]></content>
      <categories>
        <category>Bug</category>
        <category>404</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式</title>
    <url>/2020/06/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>某遥控器提供了一些按键，使用户可以自定义按键功能，如功能键FunctionButton可用于调出菜单（ShowMenu），也可用于打开帮助界面（DisplayHelp），也可用于打开机顶盒（OpenSTB）。用户可以通过修改配置文件来改变按键的用途。</p>
<p>请使用设计模式来设计该系统，画出类图，并在图中标出类的关键方法和属性，使得按键类与功能类之间解耦，相同的按键可以对应不同的功能。（15’)</p>
<h4 id="答：命令模式类图："><a href="#答：命令模式类图：" class="headerlink" title="答：命令模式类图："></a>答：命令模式类图：</h4><p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200619211724978.png" alt="image-20200619211724978"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>现需要开发一个地震监测报警系统，如果接收到相关监测机构发来的预警数据，系统将作出反应，将信号传递给响应设备，如广播自动播放报警信息、逃生指示灯亮起、安全门锁打开、电梯自动停用等，每一种响应设备的行为由专门的程序来控制。</p>
<p>为支持将来引入新类型的响应设备，请采用设计模式来设计。画出类图，并在图中标出类的关键方法和属性。(15’)</p>
<h4 id="答：观察者模式类图："><a href="#答：观察者模式类图：" class="headerlink" title="答：观察者模式类图："></a>答：观察者模式类图：</h4><p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200619205140185.png" alt="image-20200619205140185"></p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>苹果与小米的手机都有短信（SendMessage）和通话（Call）的功能。有三种功能模块：蓝牙（Bluetooth）、GPS定位（GPS）与摄像头（Camera），可以任意的安装在手机上。蓝牙模块会给手机增加连接（Connect）功能；GPS给手机增加方位（Location）属性；摄像头可增加带视频的通话功能（CallWithVideo）。</p>
<p>请选择合适的设计模式解决该问题，画出类图，并在图中标出类的关键方法和属性。（15’）</p>
<h4 id="答：装饰者模式类图："><a href="#答：装饰者模式类图：" class="headerlink" title="答：装饰者模式类图："></a>答：装饰者模式类图：</h4><p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200620210800044.png" alt="image-20200620210800044"></p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>在面向对象编程中往往提倡尽量不使用case语句和if语句等条件语句。有哪几种模式可以避免使用case等条件语句？选择其中一种设计模式举例说明，写出使用模式之前和使用模式之后的代码实现，并解释它是如何避免的。(20’)</p>
<h4 id="答："><a href="#答：" class="headerlink" title="答："></a><strong>答：</strong></h4><p>（1）策略模式<strong>、</strong>工厂模式、状态模式、命令模式</p>
<p>（2）举例说明&lt;策略模式&gt;</p>
<p>a.使用模式之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个贩卖各类书籍的电子商务网站的购物车（Shopping Cart）系统</span></span><br><span class="line"><span class="comment">对所有的教材类图书实行每本1元的折扣</span></span><br><span class="line"><span class="comment">对连环画类图书提供每本7%的促销折扣</span></span><br><span class="line"><span class="comment">对非教材类的计算机图书有3%的折扣</span></span><br><span class="line"><span class="comment">对其余的图书没有折扣*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Book text = <span class="keyword">new</span> Book();</span><br><span class="line">        text.setBookName(<span class="string">"TextBook"</span>);</span><br><span class="line">        text.setPrice(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">double</span> currentPrice=text.performDiscount();</span><br><span class="line">        System.out.println(currentPrice);</span><br><span class="line"></span><br><span class="line">        Book comic = <span class="keyword">new</span> Book();</span><br><span class="line">        comic.setBookName(<span class="string">"ComicBook"</span>);</span><br><span class="line">        comic.setPrice(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">double</span> currentPrice1=comic.performDiscount();</span><br><span class="line">        System.out.println(currentPrice1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>  price;</span><br><span class="line">        String bookName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setBookName</span><span class="params">(String bookName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">performDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(bookName.equalsIgnoreCase(<span class="string">"TextBook"</span>))&#123;</span><br><span class="line">                <span class="comment">//ComicBook ComputerBook OtherBook</span></span><br><span class="line">                <span class="keyword">this</span>.price=price-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bookName.equalsIgnoreCase((<span class="string">"Comicbook"</span>)))&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price*(<span class="number">1</span>-<span class="number">0.07</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bookName.equalsIgnoreCase((<span class="string">"ComputerBook"</span>)))&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price*(<span class="number">1</span>-<span class="number">0.03</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.price=price;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.使用模式之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComputerBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a ComputerBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ComicBook ComputerBook OtherBook</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComicBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComicBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a ComicBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Textbook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Textbook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a Textbook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OtherBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        discount = <span class="keyword">new</span> Discount4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a OtherBook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>  price;</span><br><span class="line">        Discount  discount;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">performDiscount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discount.calculate(<span class="keyword">this</span>.price);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setDiscount</span><span class="params">(Discount discount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discount = discount;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount1</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price * (<span class="number">1</span>-<span class="number">0.03</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount2</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span>   price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price * (<span class="number">1</span> - <span class="number">0.07</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount3</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount4</span>  <span class="title">implement</span>  <span class="title">Discount</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>   <span class="keyword">double</span>  <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>    price;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        Book  mt = <span class="keyword">new</span>  Textbook();</span><br><span class="line">        mt.setPrice(<span class="number">50</span>);</span><br><span class="line">        currentPrice=mt.performDiscount();</span><br><span class="line">        system.out.println(“折后价：” + currentPrice);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.解释：</p>
<p>在使用策略模式之前，我在Book类里直接计算不同的书籍折扣后的价格，在计算过程中Book类为了分辨是哪种书籍而产生了很多的if-else语句。</p>
<p>使用策略模式之后，我把计算折扣的算法部分取出并“封装”起来，定义了折扣的算法族，让它们之间可以互相替换，让算法的变化独立于使用算法的客户，好让其他部分不会受到影响。Book类只需要根据相应的书籍对象要求计算折扣，不再需要理会计算的具体过程，实际计算折扣由具体的Discount类来实现，这就除去了原先Book类的if-else语句，并使代码变化引起的不经意后果变少，系统变得更有弹性。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>选一个你曾经做过的大作业，用一种或多种设计模式对其进行重新设计。首先，描述问题以及你原本的解决方案。然后，论述选择哪（几）个设计模式，为什么选择它（们）。最后，给出重设计后的解决方案。（解决方案可以画类图并写部分关键代码，如有必要，可加文字解释）（35’）</p>
<h4 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h4><p><strong>（1)</strong></p>
<h5 id="大作业题目介绍："><a href="#大作业题目介绍：" class="headerlink" title="大作业题目介绍："></a><strong>大作业题目介绍：</strong></h5><p>机票订购管理系统：主要实现用户信息维护、机票订购、航班查询、退票、改签及后台对用户信息、机票、航班、客机进行相关管理的功能。成员分为系统管理员和普通用户两种用户角色，系统管理员授予普通用户相应权限，用户根据需求自己订购机票。</p>
<p><strong>（2）</strong>在系统设计中，我主要遇到了2个问题，分别使用迭代器模式+工厂模式以及状态模式重构</p>
<h5 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a><strong>问题1</strong>：</h5><p>在机票订购管理系统中，管理员经常需要查询机票信息，检查是否有余票或增加当前起飞飞机的机票退票信息等，在对客户表进行增删查改时也经常需要进行遍历操作；用户自己在订购机票时也要查询机票信息，这样就会遇到很多次遍历的代码，需要我把这些代码汇集起来多次使用。</p>
<h5 id="原本的解决方案1："><a href="#原本的解决方案1：" class="headerlink" title="原本的解决方案1："></a>原本的解决方案1：</h5><p>为了复用遍历的代码，减少冗余，我设计了一个抽象的数据集合DatatList，把存储机票和用户等数据的类作为其子类：</p>
<p>DatatList类结构如图：</p>
<p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200620212457778.png" alt="image-20200620212457778"></p>
<p>DataList原先关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> locate1; <span class="comment">//正向遍历的位置  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> locate2; <span class="comment">//逆向遍历的位置  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataList</span><span class="params">(List objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIt</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIt</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(locate1 &lt; list.size()) &#123;</span><br><span class="line">            locate1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (locate1 == list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locate2 &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            locate2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (locate2 == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(locate1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(locate2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述类图和DataList代码中可以看出这个类的职责过重，它既负责遍历数据,又负责存储和管理数据。这种庞大的聚合类也将给测试和维护增加难度。</p>
<h5 id="重设计方案1："><a href="#重设计方案1：" class="headerlink" title="重设计方案1："></a><strong>重设计方案1：</strong></h5><p>（1）选择迭代器模式和工厂模式：</p>
<p>（2）选择原因：</p>
<p>我使用聚合对象来存储各个数据，聚合对象拥有两个职责：一是存储数据；二是遍历数据。如果我将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，就可以实现数据存储和数据遍历分离。所以，很明显迭代器模式可以解决问题一。</p>
<p>同时，因为在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式，这样的话，如果我之后需要增加一个新的具体聚合类，比如实现客户数据集合类相应的操纵，我就只用增加一个新的聚合子类和一个新的具体迭代器类即可，不用去修改原来已经设计好的类。</p>
<p>其模式结构如图所示：<br><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200620214554880.png" alt="image-20200620214554880"></p>
<p>部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//移至下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span></span>; <span class="comment">//判断是否为最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span></span>; <span class="comment">//移至上一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFirst</span><span class="params">()</span></span>; <span class="comment">//判断是否为第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNextItem</span><span class="params">()</span></span>; <span class="comment">//获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPreviousItem</span><span class="params">()</span></span>; <span class="comment">//获取上一个元素</span></span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象聚合类  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AObjectList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AObjectList</span><span class="params">(List objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objects;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">    <span class="comment">//声明创建迭代器对象的抽象工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//机票迭代器：具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketIterator</span> <span class="keyword">implements</span> <span class="title">AIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketList ticketList;</span><br><span class="line">    <span class="keyword">private</span> List tickets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor1; <span class="comment">//定义一个游标，用于记录正向遍历的位置  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor2; <span class="comment">//定义一个游标，用于记录逆向遍历的位置  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketIterator</span><span class="params">(TicketList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ticketList = list;</span><br><span class="line">        <span class="keyword">this</span>.tickets = list.getObjects(); <span class="comment">//获取集合对象  </span></span><br><span class="line">        cursor1 = <span class="number">0</span>; <span class="comment">//设置正向遍历游标的初始值  </span></span><br><span class="line">        cursor2 = products.size() -<span class="number">1</span>; <span class="comment">//设置逆向遍历游标的初始值  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...实现抽象迭代器的抽象方法</span></span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//机票信息数据类：具体聚合类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketList</span> <span class="keyword">extends</span> <span class="title">AObjectList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketList</span><span class="params">(List tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(tickets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现创建迭代器对象的具体工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TicketIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...other methods</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h5><p>在我的机票订购管理系统中，机票（Ticket)是系统的一个核心类，机票存在三种状态，且在不同状态下机票存在不同的行为</p>
<p>(1) 如果机票中余量大于等于0，为正常状态(RegularState)，此时用户既可以订票也可以退票；</p>
<p> (2) 如果机票中余量小于0，为SoldOutState售罄状态，但之后可能仍有票卖出，此时用户可以选择排队买票（等待），也可以退票。</p>
<p> (3) 如果账户中余量=-100，那么机票状态为锁定限制状态LimitiedState，此时用户只能退票，排队已经不允许了。这三种状态的转换需要一个专门的类来实现</p>
<h5 id="原本的解决方案2："><a href="#原本的解决方案2：" class="headerlink" title="原本的解决方案2："></a>原本的解决方案2：</h5><p>RegularState表示正常状态，SoldOutState表示售罄状态，LimitiedState表示受限状态，在这三种状态下账户对象拥有不同的行为，方法buy()订票，return()退票，queue()排队，stateCheck()用于在每一次操作后根据机票余量来判断是否要进行状态转换并实现状态转换。为了实现不同状态下对象的各种行为以及对象状态之间的相互转换，我设计了一个账户类Ticket</p>
<p>Ticket类结构如图：</p>
<p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200620223542510.png" alt="image-20200620223542510"></p>
<p>Ticket原先关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state; <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rest; <span class="comment">//余量</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退票操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取票操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state.equalsIgnoreCase(<span class="string">"ApproveState"</span>)) &#123;</span><br><span class="line">            stateCheck();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state.equalsIgnoreCase(<span class="string">"SoldOutState "</span>))&#123;</span><br><span class="line">            queue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//取款受限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态检查和转换操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="string">"ApproveState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest &gt; -<span class="number">100</span> &amp;&amp; rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="string">"SoldOutState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest == -<span class="number">100</span>) &#123;</span><br><span class="line">            state = <span class="string">"LimitState"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rest &lt; -<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">//操作受限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重设计方案2："><a href="#重设计方案2：" class="headerlink" title="重设计方案2："></a>重设计方案2：</h5><p>（1）问题二选择状态模式：</p>
<p>（2）选择原因：</p>
<p>上述代码问题很多，首先几乎每个方法中都包含状态判断语句，导致代码非常冗余；系统扩展性差，如果我要增加一种新的状态，比如飞机遇见预先检查出故障而导致的机票冻结状态，将要改大量代码，会很麻烦；最后stateCheck()方法包含大量的if…else if…else…语句用于进行状态转换，会导致后期代码测试难度大。</p>
<p>在状态模式中，我们将对象在每一个状态下的行为和状态转移语句封装在一个个状态类中，通过这些状态类来分散冗长的条件转移语句，让系统具有更好的灵活性和可扩展性。如果之后增加状态，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。所以很明显，使用状态模式会可以帮我彻底解决问题二。</p>
<p>其模式结构如图所示：</p>
<p><img src="../images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/image-20200620232340828.png" alt="image-20200620232340828"></p>
<p>部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//银行机票：环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketState state; <span class="comment">//维持一个对抽象状态对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> String user; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rest = <span class="number">0</span>; <span class="comment">//机票余量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ticket</span><span class="params">(String user,<span class="keyword">double</span> init)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> RegularState(<span class="keyword">this</span>); <span class="comment">//设置初始状态</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"机票初始数量为"</span> + init);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRest</span><span class="params">(<span class="keyword">double</span> rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rest = rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"机票数量"</span> + amount);</span><br><span class="line">        state.<span class="keyword">return</span>(amount); <span class="comment">//调用状态对象的return()方法</span></span><br><span class="line">        System.out.println(<span class="string">"现在余量为"</span>+ <span class="keyword">this</span>.rest);</span><br><span class="line">        System.out.println(<span class="string">"现在机票状态为"</span>+ <span class="keyword">this</span>.state.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.user + <span class="string">"取款"</span> + amount);</span><br><span class="line">        state.buy(amount); <span class="comment">//调用状态对象的buy()方法</span></span><br><span class="line">        System.out.println(<span class="string">"现在余量为"</span>+ <span class="keyword">this</span>.rest);</span><br><span class="line">        System.out.println(<span class="string">"现在机票状态为"</span>+ <span class="keyword">this</span>. state.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Ticket acc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">computeInterest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//售罄状态:具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoldOutState</span> <span class="keyword">extends</span> <span class="title">TicketState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">return</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() + amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() - amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.getRest() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> RegularState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (acc.getRest() == -<span class="number">100</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> LimitiedState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (acc.getRest() &lt; -<span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"操作受限！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//正常状态：具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularState</span> <span class="keyword">extends</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegularState</span><span class="params">(Ticket acc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegularState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        acc.setRest(acc.getRest() - amount);</span><br><span class="line">        stateCheck();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//受限状态：具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LimitiedState</span> <span class="keyword">extends</span> <span class="title">TicketState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitiedState</span><span class="params">(TicketState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acc = state.acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"受限，买票失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(acc.getRest() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> RegularState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(acc.getRest() &gt; -<span class="number">100</span>) &#123;</span><br><span class="line">            acc.setState(<span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/07/02/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC第一天"><a href="#SpringMVC第一天" class="headerlink" title="SpringMVC第一天"></a>SpringMVC第一天</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1三层架构和MVC"><a href="#1-1三层架构和MVC" class="headerlink" title="1.1三层架构和MVC"></a>1.1三层架构和MVC</h3><p>咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序</p>
<p>使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构</p>
<h4 id="1-1-1-三层架构"><a href="#1-1-1-三层架构" class="headerlink" title="1.1.1 三层架构"></a>1.1.1 三层架构</h4><p>表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型</p>
<p>业务层：处理公司具体的业务逻辑的</p>
<p>持久层：用来操作数据库的</p>
<h4 id="1-1-2-MVC模型"><a href="#1-1-2-MVC模型" class="headerlink" title="1.1.2 MVC模型"></a>1.1.2 MVC模型</h4><p>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。</p>
<p>Model：数据模型，JavaBean的类，用来进行数据封装。</p>
<p>View：指JSP、HTML用来展示数据给用户</p>
<p>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</p>
<p><img src="/../images/SpringMVC/image-20200702202459954.png" alt="image-20200702202459954"></p>
<h3 id="1-2-SpringMVC的基本概念"><a href="#1-2-SpringMVC的基本概念" class="headerlink" title="1.2 SpringMVC的基本概念"></a>1.2 SpringMVC的基本概念</h3><h4 id="1-2-1-SpringMVC的概述"><a href="#1-2-1-SpringMVC的概述" class="headerlink" title="1.2.1 SpringMVC的概述"></a>1.2.1 SpringMVC的概述</h4><p>是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。</p>
<p>使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的<br>SpringMVC框架或集成其他MVC开发框架.</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-SpringMVC的入门程序步骤"><a href="#2-1-SpringMVC的入门程序步骤" class="headerlink" title="2.1 SpringMVC的入门程序步骤"></a>2.1 SpringMVC的入门程序步骤</h3><p><img src="/../images/SpringMVC/image-20200702202536795.png" alt="image-20200702202536795"></p>
<h4 id="2-1-1环境搭建"><a href="#2-1-1环境搭建" class="headerlink" title="2.1.1环境搭建"></a>2.1.1环境搭建</h4><ol>
<li>创建webapp程序</li>
<li>加入键值对：archetypeCatalog——intenal</li>
<li>创建java和resource文件夹</li>
<li>复制pom.xml文件导入依赖</li>
<li>web.xml配置Servlet前端控制器</li>
<li>resource-&gt;new-&gt;xml配置文件-&gt;spring config（文件名springmvc-&gt;是spring框架的配置文件）</li>
</ol>
<h4 id="2-1-2项目服务器部署"><a href="#2-1-2项目服务器部署" class="headerlink" title="2.1.2项目服务器部署"></a>2.1.2项目服务器部署</h4><ol>
<li>tomcat配置server</li>
<li>Deployment-&gt;(+)-&gt;Artifact(exploded文件)-&gt;context路径配置（可以选择不配）-&gt;Apply</li>
</ol>
<h4 id="2-1-3程序编写"><a href="#2-1-3程序编写" class="headerlink" title="2.1.3程序编写"></a>2.1.3程序编写</h4><ol>
<li>index.jsp </li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href="hello"&gt;入门程序&lt;/a&gt;//超链接</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>控制器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类：<span class="meta">@Controller</span></span><br><span class="line">方法：<span class="meta">@RequestMapping</span>(path=<span class="string">"/hello"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置web.xml和springmvc.xml</li>
</ol>
<h4 id="2-1-4流程图解"><a href="#2-1-4流程图解" class="headerlink" title="2.1.4流程图解"></a>2.1.4流程图解</h4><p><img src="/../images/SpringMVC/image-20200702202625481.png" alt="image-20200702202625481"></p>
<h3 id="2-2入门案例的分析执行流程"><a href="#2-2入门案例的分析执行流程" class="headerlink" title="2.2入门案例的分析执行流程"></a>2.2入门案例的分析执行流程</h3><h4 id="2-2-1入门案例的分析执行流程"><a href="#2-2-1入门案例的分析执行流程" class="headerlink" title="2.2.1入门案例的分析执行流程"></a>2.2.1入门案例的分析执行流程</h4><p><img src="/../images/SpringMVC/image-20200702202644714.png" alt="image-20200702202644714"></p>
<ol>
<li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件.</li>
<li>开启了注解扫描，那么HelloController对象就会被创建</li>
<li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法</li>
<li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件</li>
<li>Tomcat服务器渲染页面，做出响应</li>
<li>SpringMVC官方提供图形</li>
</ol>
<h4 id="2-2-2-入门案例中的组件分析"><a href="#2-2-2-入门案例中的组件分析" class="headerlink" title="2.2.2 入门案例中的组件分析"></a>2.2.2 入门案例中的组件分析</h4><ol>
<li>前端控制器（DispatcherServlet）</li>
<li>处理器映射器（HandlerMapping）</li>
<li>处理器（Handler）</li>
<li>处理器适配器（HandlAdapter）</li>
<li>视图解析器（View Resolver）</li>
<li>视图（View）</li>
</ol>
<h3 id="2-3-RequestMapping注解"><a href="#2-3-RequestMapping注解" class="headerlink" title="2.3 RequestMapping注解"></a>2.3 RequestMapping注解</h3><ol>
<li><p>RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系</p>
</li>
<li><p>RequestMapping注解可以作用在方法和类上</p>
</li>
</ol>
<ul>
<li>作用在类上：第一级的访问目录</li>
<li>作用在方法上：第二级的访问目录</li>
<li>细节：路径可以不编写 / 表示应用的根目录开始</li>
<li>细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 /</li>
</ul>
<ol start="3">
<li>RequestMapping的属性</li>
</ol>
<ul>
<li>path 指定请求路径的url</li>
<li>value value属性和path属性是一样的</li>
<li>mthod 指定该方法的请求方式</li>
<li>params 指定限制请求参数的条件</li>
<li>headers 发送的请求中必须包含的请求头</li>
</ul>
<h2 id="第三章：请求参数的绑定"><a href="#第三章：请求参数的绑定" class="headerlink" title="第三章：请求参数的绑定"></a>第三章：请求参数的绑定</h2><h3 id="3-1绑定说明"><a href="#3-1绑定说明" class="headerlink" title="3.1绑定说明"></a>3.1绑定说明</h3><h4 id="3-1-1-请求参数的绑定说明"><a href="#3-1-1-请求参数的绑定说明" class="headerlink" title="3.1.1 请求参数的绑定说明"></a>3.1.1 请求参数的绑定说明</h4><ol>
<li>绑定机制</li>
</ol>
<ul>
<li>表单提交的数据都是k=v格式的 username=haha&amp;password=123</li>
<li>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</li>
<li>要求：提交表单的name和参数的名称是相同的</li>
</ul>
<ol start="2">
<li>支持的数据类型</li>
</ol>
<ul>
<li>基本数据类型和字符串类型</li>
<li>实体类型（JavaBean）</li>
<li>集合数据类型（List、map集合等）</li>
</ul>
<h4 id="3-1-2-基本数据类型和字符串类型"><a href="#3-1-2-基本数据类型和字符串类型" class="headerlink" title="3.1,2 基本数据类型和字符串类型"></a>3.1,2 基本数据类型和字符串类型</h4><ol>
<li>提交表单的name和参数的名称是相同的</li>
<li>区分大小写</li>
</ol>
<h4 id="3-1-3-实体类型（JavaBean）"><a href="#3-1-3-实体类型（JavaBean）" class="headerlink" title="3.1.3 实体类型（JavaBean）"></a>3.1.3 实体类型（JavaBean）</h4><ol>
<li>提交表单的name和JavaBean中的属性名称需要一致</li>
<li>如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：<br>address.name</li>
</ol>
<h4 id="3-1-4-给集合属性数据封装"><a href="#3-1-4-给集合属性数据封装" class="headerlink" title="3.1.4 给集合属性数据封装"></a>3.1.4 给集合属性数据封装</h4><p>JSP页面编写方式：list[0].属性</p>
<h4 id="3-1-5-请求参数中文乱码的解决"><a href="#3-1-5-请求参数中文乱码的解决" class="headerlink" title="3.1.5 请求参数中文乱码的解决"></a>3.1.5 请求参数中文乱码的解决</h4><p>在web.xml中配置Spring提供的过滤器类</p>
<h3 id="3-2-特殊情况"><a href="#3-2-特殊情况" class="headerlink" title="3.2 特殊情况"></a>3.2 特殊情况</h3><p>3.2.1 自定义类型转换器</p>
<ol>
<li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换。</p>
</li>
<li><p>如果想自定义数据类型转换，可以实现Converter的接口</p>
<ol>
<li>注册自定义类型转换器</li>
<li>在springmvc.xml配置文件中编写配置 </li>
</ol>
</li>
</ol>
<h2 id="第四章-注解"><a href="#第四章-注解" class="headerlink" title="第四章 注解"></a>第四章 注解</h2><h3 id="4-1-RequestParam注解"><a href="#4-1-RequestParam注解" class="headerlink" title="4.1 RequestParam注解"></a>4.1 RequestParam注解</h3><h4 id="4-1-1-作用"><a href="#4-1-1-作用" class="headerlink" title="4.1.1 作用"></a>4.1.1 作用</h4><p>把请求中的指定名称的参数传递给控制器中的形参赋值</p>
<h4 id="4-1-2-属性"><a href="#4-1-2-属性" class="headerlink" title="4.1.2 属性"></a>4.1.2 属性</h4><p>value：请求参数中的名称</p>
<p>required：请求参数中是否必须提供此参数，默认值是true，必须提供4.2 RequestBody注解</p>
<h3 id="4-2-RequestBody注解"><a href="#4-2-RequestBody注解" class="headerlink" title="4.2 RequestBody注解"></a>4.2 RequestBody注解</h3><h4 id="4-2-1-作用"><a href="#4-2-1-作用" class="headerlink" title="4.2.1 作用"></a>4.2.1 作用</h4><p>用于获取请求体的内容（注意：get方法不可以）</p>
<h4 id="4-2-2-属性"><a href="#4-2-2-属性" class="headerlink" title="4.2.2 属性"></a>4.2.2 属性</h4><h3 id="4-3-PathVaribale注解"><a href="#4-3-PathVaribale注解" class="headerlink" title="4.3 PathVaribale注解"></a>4.3 PathVaribale注解</h3><h4 id="4-3-1-作用"><a href="#4-3-1-作用" class="headerlink" title="4.3.1 作用"></a>4.3.1 作用</h4><p> 用于绑定url中的占位符。例如：请求url中 /delete/<strong>{id}</strong>，这个{id}就是url占位符。 url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。 </p>
<h4 id="4-3-2-属性"><a href="#4-3-2-属性" class="headerlink" title="4.3.2 属性"></a>4.3.2 属性</h4><p> value：用于指定url中占位符名称。</p>
<p> required：是否必须提供占位符。</p>
<h4 id="4-3-3-REST风格URL"><a href="#4-3-3-REST风格URL" class="headerlink" title="4.3.3 REST风格URL"></a>4.3.3 REST风格URL</h4><ol>
<li><p>请求路径一样，可以根据不同的请求方式去执行后台的不同方法</p>
</li>
<li><p>restful风格的URL优点：结构清晰\符合标准\易于理解\扩展方便</p>
</li>
<li><p>HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</strong></p>
</li>
<li><p>restful的示例： </p>
<table>
<thead>
<tr>
<th>/account/1 HTTP GET ：</th>
<th>得到 id = 1 的 account</th>
</tr>
</thead>
<tbody><tr>
<td>/account/1 HTTP DELETE：</td>
<td>删除 id = 1的 account</td>
</tr>
<tr>
<td>/account/1 HTTP PUT：</td>
<td>更新id = 1的 account</td>
</tr>
<tr>
<td>/account HTTP POST：</td>
<td>新增id = 1 account</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="/../images/SpringMVC/image-20200702202748227.png" alt="image-20200702202748227"></p>
<h4 id="4-3-4-基于HiddentHttpMethodFilter的示例"><a href="#4-3-4-基于HiddentHttpMethodFilter的示例" class="headerlink" title="4.3.4 基于HiddentHttpMethodFilter的示例"></a>4.3.4 基于HiddentHttpMethodFilter的示例</h4><p><strong>作用：</strong> 由于浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与DELETE 请求。</p>
<p> <strong>使用方法：</strong> 第一步：在web.xml中配置该过滤器。 第二步：请求方式必须使用post请求。 第三步：按照要求提供_method请求参数，该参数的取值就是我们需要的请求方式。</p>
<h3 id="4-4-RequestHeader注解"><a href="#4-4-RequestHeader注解" class="headerlink" title="4.4 RequestHeader注解"></a>4.4 RequestHeader注解</h3><h4 id="4-4-1-作用"><a href="#4-4-1-作用" class="headerlink" title="4.4.1 作用"></a>4.4.1 作用</h4><p>获取指定请求头的值</p>
<h4 id="4-4-2-属性"><a href="#4-4-2-属性" class="headerlink" title="4.4.2 属性"></a>4.4.2 属性</h4><p>value：请求头的名称</p>
<h3 id="4-5-CookieValue注解"><a href="#4-5-CookieValue注解" class="headerlink" title="4.5 CookieValue注解"></a>4.5 CookieValue注解</h3><h4 id="4-5-1-作用"><a href="#4-5-1-作用" class="headerlink" title="4.5.1 作用"></a>4.5.1 作用</h4><p>用于获取指定cookie的名称的值</p>
<h4 id="4-5-2-属性"><a href="#4-5-2-属性" class="headerlink" title="4.5.2 属性"></a>4.5.2 属性</h4><p>value：cookie的名称</p>
<h3 id="4-6-ModelAttribute注解"><a href="#4-6-ModelAttribute注解" class="headerlink" title="4.6 ModelAttribute注解"></a>4.6 ModelAttribute注解</h3><h4 id="4-6-1-作用"><a href="#4-6-1-作用" class="headerlink" title="4.6.1 作用"></a>4.6.1 作用</h4><p>出现在方法上：表示当前方法会在控制器方法执行前线执行。</p>
<p>出现在参数上：获取指定的数据给参数赋值。</p>
<h4 id="4-6-2-应用场景"><a href="#4-6-2-应用场景" class="headerlink" title="4.6.2 应用场景"></a>4.6.2 应用场景</h4><p>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据</p>
<h4 id="4-6-3-应用方式"><a href="#4-6-3-应用方式" class="headerlink" title="4.6.3 应用方式"></a>4.6.3 应用方式</h4><p>根据方法是否有返回值来确定两种方式，代码在笔记上</p>
<h3 id="4-7-SessionAttribute注解"><a href="#4-7-SessionAttribute注解" class="headerlink" title="4.7 SessionAttribute注解"></a>4.7 SessionAttribute注解</h3><h4 id="4-7-1作用"><a href="#4-7-1作用" class="headerlink" title="4.7.1作用"></a>4.7.1作用</h4><p>用于多次执行控制器方法间的参数共享(存入session域或者request中)</p>
<h4 id="4-7-2-属性"><a href="#4-7-2-属性" class="headerlink" title="4.7.2 属性"></a>4.7.2 属性</h4><p>value：指定存入属性的名称</p>
<h1 id="SpringMVC第二天"><a href="#SpringMVC第二天" class="headerlink" title="SpringMVC第二天"></a>SpringMVC第二天</h1><p>看随堂笔记吧</p>
<h2 id="异常抛出流程"><a href="#异常抛出流程" class="headerlink" title="异常抛出流程"></a>异常抛出流程</h2><p><img src="/../images/SpringMVC/image-20200702202725180.png" alt="image-20200702202725180"></p>
<h2 id="第四章：SpringMVC框架中的拦截器"><a href="#第四章：SpringMVC框架中的拦截器" class="headerlink" title="第四章：SpringMVC框架中的拦截器"></a>第四章：SpringMVC框架中的拦截器</h2><h2 id="4-1拦截器的概述"><a href="#4-1拦截器的概述" class="headerlink" title="4.1拦截器的概述"></a>4.1拦截器的概述</h2><ol>
<li><p>SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。</p>
</li>
<li><p>可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。</p>
</li>
<li><p>拦截器和过滤器的功能比较类似，有区别</p>
<p>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</p>
<p>拦截器是SpringMVC框架独有的。</p>
<p>过滤器配置了/*，可以拦截任何资源。</p>
<p>拦截器只会对控制器中的方法进行拦截。</p>
</li>
<li><p>拦截器也是AOP思想的一种实现方式</p>
</li>
<li><p>想要自定义拦截器，需要实现HandlerInterceptor接口。</p>
</li>
</ol>
<h2 id="4-2-HandlerInterceptor接口中的方法"><a href="#4-2-HandlerInterceptor接口中的方法" class="headerlink" title="4.2 HandlerInterceptor接口中的方法"></a>4.2 HandlerInterceptor接口中的方法</h2><ol>
<li>preHandle方法是controller方法执行前拦截的方法</li>
</ol>
<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>
<li>return false不放行，不会执行controller中的方法。</li>
</ul>
<ol start="2">
<li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。</li>
</ol>
<ul>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>
</ul>
<ol start="3">
<li>postHandle方法是在JSP执行后执行</li>
</ol>
<ul>
<li>request或者response不能再跳转页面了</li>
</ul>
<h1 id="SpringMVC第三天"><a href="#SpringMVC第三天" class="headerlink" title="SpringMVC第三天"></a>SpringMVC第三天</h1><h2 id="第一章：搭建整合环境"><a href="#第一章：搭建整合环境" class="headerlink" title="第一章：搭建整合环境"></a>第一章：搭建整合环境</h2><ol>
<li>搭建整合环境</li>
<li>整合说明：SSM整合可以使用多种方式，咱们会选择XML + 注解的方式</li>
<li>整合的思路</li>
</ol>
<ul>
<li>先搭建整合的环境</li>
<li>先把Spring的配置搭建完成</li>
<li>再使用Spring整合SpringMVC框架</li>
<li>最后使用Spring整合MyBatis框架</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理(school)</title>
    <url>/2020/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>\1.   计算机系统的组成</p>
<p>软件系统</p>
<p>硬件系统：五大部件；总线</p>
<p>冯·诺依曼思想</p>
<p>现代计算机的结构</p>
<p>\2.   总线：概念、特点、分类、结构</p>
<p>\3.   计算机系统的层次结构</p>
<p>\4.   软件与硬件的关系</p>
<p>\5.   计算机系统在速度、容量、价格方面的主要性能指标（MIPS，Mflops，CPI，CPU时间）</p>
<p>\6.   计算机系统的分类</p>
<p><strong>重点：</strong></p>
<p>计算机系统的组成的概念；各部件的作用；冯·诺依曼思想；计算机系统的层次结构的概念；软件与硬件逻辑上等效的概念；计算机系统主要性能指标的计算。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、简答</p>
<h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><p>\1.   数制及数制转换</p>
<p>\2.   带符号数的表示：原码、反码、补码、移码以及各种码制与真值之间的转换</p>
<p>\3.   定点数的表示格式和数据表示范围</p>
<p>浮点数的表示格式和数据表示范围、浮点数的规格化数、原码／补码的规格化规则</p>
<p>\4.   IEEE 754标准浮点数的表示格式（32位单精度）、与真值之间的转换规则</p>
<p>\5.   非数值符号的表示：字符的ASCII码、字符串的存放方法；汉字编码的关系、汉字字库的容量计算</p>
<p>\6.   数据长度与存储方式；C语言简单数据类型的长度与存储</p>
<p>\7.   奇偶校验码、海明校验码、循环校验码的编码方法和校验方法；海明校验码码长的计算公式、各种校验码的检错和纠错能力；校验码的检错、纠错能力与码距的关系。</p>
<p><strong>重点：</strong></p>
<p>原码、反码、补码、移码以及各种码制与真值之间的转换方法；浮点数的规格化数、最大、最小数的表示；IEEE 754标准浮点数的表示规则、表示格式、IEEE 754标准浮点数与真值之间的转换；奇偶校验码、海明校验码（检一纠一、检二纠一）、循环校验码的编码方法；校验码的检错、纠错能力与码距的关系、海明校验码码长的计算公式、循环校验码的编码方法和校验方法、生成多项式的特点及对生成多项式的要求。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、计算★</p>
<h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><p>\1.   定点补码加减运算规则、溢出判断方法、定点补码加减运算的逻辑电路、算术逻辑运算部件的工作原理</p>
<p>\2.   一位原码/补码的乘法运算规则以及乘法运算的硬件逻辑电路的结构和工作原理</p>
<p>\3.   一位原码/补码不恢复余数除法运算规则、布斯除法运算规则以及除法运算的硬件逻辑电路的结构和工作原理</p>
<p>\4.   浮点四则运算的方法和步骤</p>
<p>加减运算：求阶差、对阶、尾数加减、结果规格化、尾数的舍入规则</p>
<p>乘除运算：阶码加减、尾数乘除、结果规格化、尾数的舍入规则</p>
<p>\5.    逻辑运算、各类移位的移位规则</p>
<p>\6.    AM2901A（4位ALU）芯片的功能及应用</p>
<p><strong>重点：</strong></p>
<p>定点补码加减运算、溢出判断方法；一位原码、补码的乘法运算及硬件逻辑电路的结构；一位布斯除法的运算规则及除法运算的硬件逻辑电路；浮点四则运算的方法和步骤；算术、逻辑、循环移位的移位方法。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、计算★（结合定点加减乘除算法，进行浮点四则运算）</p>
<h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><p>\1.    存储器的基本组成：存储体、读写控制、地址寄存及译码电路、数据寄存器，</p>
<p>\2.    存储系统的层次结构，程序局部性原理</p>
<p>\3.    主存与CPU之间数据传送的控制方式：同步控制、异步控制</p>
<p>\4.    主存的主要性能指标：容量、速度（存取时间TA、存取周期TM、带宽的计算方法）、价格</p>
<p>\5.    半导体存储器的存储原理</p>
<p>SRAM、DRAM的存储原理；DRAM的刷新方式、如何计算DRAM的刷新周期</p>
<p>\6.    存储器与CPU的连接：芯片数的计算、地址、数据、控制线的连接、片选信号的产生、地址范围的确定（字扩展、位扩展）；当需要多种字长访存时的各种地址和片选信号的实现，数据的整数边界存储问题。</p>
<p>\7.    Cache的工作原理：Cache的命中率的计算，Cache－主存系统的平均访问时间的计算， </p>
<p>\8.    主存与Cache之间的三种地址映射方式的实现原理和特点； Cache容量的计算（数据Cache和标识Cache的容量计算）；Cache－主存系统的平均访问时间的计算；Cache命中率的计算。</p>
<p>\9.    辅助存储器</p>
<p>磁表面存储器的存储原理、各种记录方式的特点、各种记录方式的评价标准（自同步能力、编码效率）</p>
<p>磁盘的常用技术指标：容量、平均存取时间、数据传输率的计算</p>
<p>\10.  存储体系中单体多字并行存储器、多体交叉存储器的概念</p>
<p>多端口存储器、单体多字存储系统、多体交叉存储系统</p>
<p><strong>重点：</strong></p>
<p>存储器的基本组成；DRAM的刷新；主存的主要性能指标的计算；存储器与CPU的连接及整数边界存储；Cache容量的计算；三种地址映射方式下主存块与Cache块的对应关系；多体交叉存储器带宽的计算。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算、设计★（存储器与CPU的连接，多种字长访存时的各种地址和片选信号的实现）</p>
<h4 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h4><p>1． 指令的格式、指令中地址的格式、操作码的编码方式</p>
<p>根据操作码和地址码计算指令的条数</p>
<p>2． 寻址方式</p>
<p>各种寻址方式中有效地址的计算方法</p>
<p>3． 指令类型</p>
<p>完备的指令系统应具有的基本指令类型，各种指令的实现过程。</p>
<p>4． CISC和RISC系统的设计风格的特点</p>
<p>5． MIPS系统指令的三种格式及特点</p>
<p><strong>重点：</strong></p>
<p>指令格式；寻址方式；各种指令的实现过程；CISC和RISC系统的设计风格的特点。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、设计★（指令格式设计；寻址方式分析；指令功能实现）</p>
<h4 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h4><p>1． 控制器的功能</p>
<p>2． 指令的执行步骤</p>
<p>3． 控制器组成部件：PC、IR、ID、操作信号形成部件等</p>
<p>4． 控制器的组成方式：组合逻辑方式、微程序方式</p>
<p>5． 控制器的控制方式：同步控制、异步控制、联合控制</p>
<p>控制器的时序：指令周期、机器周期、节拍、脉冲</p>
<p>6． CPU的结构、CPU中的基本寄存器</p>
<p>7． 数据通路及指令流程分析</p>
<p>根据指令功能和CPU的数据通路结构写出指令流程、控制信号序列及一个指令周期的的访存次数</p>
<p>8． 组合逻辑控制器的组成方式</p>
<p>9． 微程序控制器</p>
<p>微程序控制基本概念：微命令、微操作、微指令、微程序、微周期、控制存储器</p>
<p>微程序控制器的组成方式</p>
<p>微指令的编译方式（微指令格式的设计方法）：直接控制法、最短编码法、字段直接编码法</p>
<p>微程序的顺序控制方式：初始微地址的形成方式；后继微地址的形成方式：增量方式、断定方式</p>
<p>10．  指令的执行方式：顺序方式、重叠方式、流水方式</p>
<p>11．  流水线的分类：操作部件级、指令级和处理机级；单功能流水线和多功能流水线；静态流水线和动态流水线；线性流水线和非线性流水线</p>
<p>12．  线性流水线的性能：流水线时空图，线性流水线的吞吐率、效率和加速比的计算。</p>
<p>13．  线性流水线的三种相关及处理。</p>
<p>14．  MIPS系统的处理器：数据通路及多选器的作用，常用MIPS指令流程分析（指令流程、微控制信号序列等），ALU指令、Load/Store指令、分支指令特点及五个阶段的操作，流水线处理等</p>
<p><strong>重点：</strong></p>
<p>控制器组成及组成方式；CPU中各寄存器的作用；指令流程分析；程序功能分析；微指令的编译方式；微地址的形成方式；指令的执行方式；流水线的分类；线性流水线的性能计算、流水线的三种相关问题及分析。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、设计★（指令流程及程序功能分析与实现；微指令格式设计；微程序的实现；线性流水线的性能分析）</p>
<h4 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h4><p>\1.   总线的分类</p>
<p>\2.   总线的性能：带宽、宽度、时钟频率、负载能力</p>
<p>\3.   总线上的设备分类：总线主设备和总线从设备；总线源设备和总线目的设备；</p>
<p>\4.   总线仲裁的方法：集中仲裁和分布仲裁；并行仲裁和串行仲裁；集中式总线控制器的仲裁方式</p>
<p>\5.   总线的数据传输类型</p>
<p>\6.   PCI和USB总线的基本知识。</p>
<p><strong>重点：</strong></p>
<p>总线上的设备分类；总线仲裁的方法；总线带宽的计算；PCI和USB总线的基本知识。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算。</p>
<h4 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h4><p>\1.    主机对外设控制的四个层次</p>
<p>用户界面、驱动程序、控制程序、I/O操作</p>
<p>\2.    输入设备—键盘</p>
<p>键盘的字符键和控制功能键、软件扫描键盘原理</p>
<p>\3.    输出设备—显示器</p>
<p>显示缓存–VRAM、色彩数量</p>
<h4 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h4><p>1． 主机与外设的连接方式</p>
<p>2． 接口的功能、组成、分类</p>
<p>3． I/O的寻址方式</p>
<p>4． I/O信息的传送方式</p>
<p>5． 中断的功能和工作过程</p>
<p>中断请求、中断响应的条件，中断屏蔽、中断禁止、中断判优的条件，中断响应过程，向量中断的实现过程，中断嵌套的原则及处理过程</p>
<p>6． 中断对流水线的影响及处理</p>
<p>7． MIPS系统的中断流水处理方法</p>
<p>8． DMA的功能和工作过程</p>
<p>DMAC的组成</p>
<p>DMA传送方式：CPU暂停方式、周期挪用方式、交替访存方式</p>
<p>DMA的接口类型</p>
<p>DMA控制方式下的数据传送过程：DMA预处理、数据交换操作、DMA后处理</p>
<p>DMA与中断的比较</p>
<p>9． I/O通道控制方式的基本概念</p>
<p>10．      通道的类型：字节多路通道、选择通道、数组多路通道</p>
<p>11．  I/O通道的工作原理</p>
<p><strong>重点：</strong></p>
<p>接口的功能；中断的功能和工作过程；向量中断的实现过程；DMA的功能和工作过程。中断、DMA方式下数据传输的特点及性能计算；通道的类型。</p>
<p><strong>出题形式：</strong></p>
<p>填空、选择、判断、问答、计算、设计★（中断及DMA的功能和实现）</p>
<p>主要参考资料</p>
<p>\1. 《计算机组成原理》（修订版，2016）—教材</p>
<p>\2. 《计算机组成与设计 硬件/软件接口》（原书第5版， MIPS系统） —pdf文件</p>
<p>​      （第2章、第4章）</p>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>无法找到applicationContext-*.xml</title>
    <url>/2020/07/08/%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0applicationContext-xml/</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>用Maven搭建spring、springmvc、mybatis时，运行报错：</p>
<p>org.springframework.beans.factory.BeanDefinitionStoreException: Could not resolve bean definition resource pattern<br>[classpath:spring/applicationContext-*.xml]; nested exception is java.io.FileNotFoundException: class path resource [spring/] cannot be resolved to URL because it does not exist</p>
<p>意思是说：<br>无法找到applicationContext-*.xml这个配置文件，因为这些文件不存在</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们知道，maven在扫描java文件夹时，不会扫描其中的.xml文件，因为它默认是扫描java文件的，这样mapper.xml就会丢失而导致报错，所以我们会在pom文件中添加这样的配置：</p>
<p>pom.xml中添加这样的语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       由于修改了默认的resource目录，导致src/main/resources的所有文件都不能被扫描，因此还要配多一个</span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Bug</category>
        <category>配置文件</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo迁移</title>
    <url>/2020/07/02/hexo%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h4 id="怎么把环境文件托管到github"><a href="#怎么把环境文件托管到github" class="headerlink" title="怎么把环境文件托管到github"></a>怎么把环境文件托管到github</h4><ol>
<li><p>github创建hexo分支，setting——branches——设置hexo为默认分支，切换到hexo分支，git clone仓库到本地</p>
</li>
<li><p>此时本地会多出一个username.github.io文件夹，命令行cd进去，删除除了.git`以外的所有文件夹</p>
</li>
<li><p>把之前我们写的除了  .deploy_git  以外的所有博客源文件全部复制过来。这里应该说一句，复制过来的源文件应该有一个  .gitignore ,用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules&#x2F;</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行git add -A把工作区的变化（包括已删除的文件）提交到暂存区（ps:因为git add .提交的变化不包括已删除的文件）。</p>
</li>
<li><p>命令行git commit -m “add branch”提交。</p>
</li>
<li><p>命令行git push origin hexo推送到远程hexo分支。此时刷下github，如果正常操作，刷新可以知道hexo分支应该已经被清空了。</p>
</li>
<li><p>复制本地username.github.io文件夹中.git文件夹到hexo项目根目录下。此时，hexo项目已经变成了和远程hexo分支关联的本地仓库了。</p>
</li>
<li><p>而username.github.io文件夹的使命到此为止，你可以把它删掉，因为我们只是把它作为一个“中转站”的角色。</p>
</li>
<li><p>以后每次发布新文章或修改网站样式文件时，git add 然后 git commit -m “description”  然后git push origin hexo即可把环境文件推送到hexo分支。然后再`hexo g -d发布网站并推送静态文件到master分支。</p>
<p>每次发布代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;xxxx&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，hexo的环境文件已经全部托管在github的hexo分支了。</p>
<h4 id="新电脑中的环境搭建"><a href="#新电脑中的环境搭建" class="headerlink" title="新电脑中的环境搭建"></a>新电脑中的环境搭建</h4><ul>
<li><p>一样的，跟之前的环境搭建一样，</p>
<ul>
<li>安装git</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<ul>
<li>设置git全局邮箱和用户名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourgithubname&quot;</span><br><span class="line">git config --global user.email &quot;yourgithubemail&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置ssh key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#命令行进入用户主目录</span><br><span class="line">ssh-keygen -t rsa -C &quot;username@example.com&quot;</span><br><span class="line">#输入邮箱后一路回车</span><br><span class="line">#找到该目录下.ssh文件夹，可以看到id_rsa（私钥）和id_rsa.pub（公钥），复制公钥</span><br><span class="line">#生成后去github上settings——&gt;SSH and GPG keys,点击NEW SSH key然后title填个电脑名，把刚刚复制的粘贴到key中，点击add SHH key</span><br><span class="line">#验证是否成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@git.coding.net #(有coding平台的话)</span><br></pre></td></tr></table></figure>

<ul>
<li>安装nodejs</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>

<ul>
<li>安装hexo  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>但是已经不需要初始化了</p>
</li>
<li><p>clone远程仓库到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:username&#x2F;username.github.io.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后进入克隆到的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd xxx.github.io</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>生成，部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一切正常，此时打开浏览器输入<a href="http://localhost:4000/已经可以看到博客正常运行了。" target="_blank" rel="noopener">http://localhost:4000/已经可以看到博客正常运行了。</a></p>
</li>
<li><p>然后开始写新博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;博客名字&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写完了要记得源文件上传一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;xxxx&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在两台电脑上的同步操作"><a href="#在两台电脑上的同步操作" class="headerlink" title="在两台电脑上的同步操作"></a>在两台电脑上的同步操作</h4><p>至此，迁移工作已完成，在两台电脑之间的同步操作如下：</p>
<ul>
<li>git pull从远程hexo分支拉取最新的环境文件到本地，可以理解为svn的更新操作。比如在公司写了博客，回家在电脑上也要写需要先执行这一步操作。</li>
<li>文章写完，要发布时，也需要先提交环境文件，再发布文章。按以下顺序执行命令：</li>
<li>git add .、git commit -m “some descrption”、git push origin hexo、hexo g -d</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;已经编辑过的电脑上，有clone文件夹了，就只用加个git pull</span><br><span class="line">git pull</span><br><span class="line">git add .</span><br><span class="line">git commit –m &quot;xxxx&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2020/07/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第二章-C-C-快速入门"><a href="#第二章-C-C-快速入门" class="headerlink" title="第二章 C/C++快速入门"></a>第二章 C/C++快速入门</h2><h3 id="2-1-基本数据类型及输入输出"><a href="#2-1-基本数据类型及输入输出" class="headerlink" title="2.1 基本数据类型及输入输出"></a>2.1 基本数据类型及输入输出</h3><h4 id="2-1-2-变量类型及输入输出"><a href="#2-1-2-变量类型及输入输出" class="headerlink" title="2.1.2 变量类型及输入输出"></a>2.1.2 变量类型及输入输出</h4><table>
<thead>
<tr>
<th>类型</th>
<th>取值范围</th>
<th>占用字节</th>
<th>格式符</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>10的9次方以内整数</td>
<td>4字节（32位）</td>
<td>%d</td>
</tr>
<tr>
<td>long long</td>
<td>10的10次方~10的18次方</td>
<td>8字节（64位）</td>
<td>%lld</td>
</tr>
<tr>
<td>float</td>
<td>6~7位有效精度</td>
<td>32字节</td>
<td>%f</td>
</tr>
<tr>
<td>double</td>
<td>15~16位有效精度</td>
<td>64字节</td>
<td>%lf</td>
</tr>
<tr>
<td>char</td>
<td>-128~127</td>
<td>-128~127</td>
<td>%c(字符串%s不加&amp;)</td>
</tr>
<tr>
<td>bool</td>
<td>0/1</td>
<td>0/1</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-1-3-注意事项："><a href="#2-1-3-注意事项：" class="headerlink" title="2.1.3 注意事项："></a>2.1.3 注意事项：</h4><ol>
<li>整型</li>
</ol>
<p>long long赋值后要加LL；</p>
<p>整型加unsigned表示无符号，会把法术范围挪到正数上来；</p>
<ol start="2">
<li>浮点型</li>
</ol>
<p>用double，放弃float；</p>
<ol start="3">
<li>char型</li>
</ol>
<p>ASCII码——0<del>9（48</del>57)、A<del>Z(65</del>90)、a<del>z(97</del>122) 小写字母比大写大32；</p>
<p>输出字符串格式scanf(“%s”,str);</p>
<h4 id="2-1-4-三种实用输出格式"><a href="#2-1-4-三种实用输出格式" class="headerlink" title="2.1.4 三种实用输出格式"></a>2.1.4 三种实用输出格式</h4><ol>
<li><p>%md</p>
<p>不足m位的int变量右对齐输出，高位<strong>空格</strong>补齐；如果本身超过m位，则保持原样</p>
</li>
<li><p>%0md</p>
<p>不足m位的int变量右对齐输出，高位<strong>加0</strong>补齐；如果本身超过m位，则保持原样</p>
</li>
<li><p>%.mf</p>
<p>浮点数保留m位小数输出</p>
</li>
</ol>
<h4 id="2-1-5-getchar-putchar和typedef"><a href="#2-1-5-getchar-putchar和typedef" class="headerlink" title="2.1.5 getchar/putchar和typedef"></a>2.1.5 getchar/putchar和typedef</h4><ol>
<li>gerchar()——输入单个字符（一般用来识别换行符）</li>
<li>putchar()——输出单个字符</li>
<li>typedef long long LL;——起别名</li>
</ol>
<h3 id="2-2-常用math函数"><a href="#2-2-常用math函数" class="headerlink" title="2.2 常用math函数"></a>2.2 常用math函数</h3><p>$$<br>fabs(double x)——取绝对值<br>$$</p>
<p>$$<br>pow(double r，double p)——r的p次方<br>$$</p>
<p>$$<br>floor(double x) /  ceil(double x)——向/下上取整<br>$$</p>
<p>$$<br>pow(double r，double p)——返回r^p<br>$$</p>
<p>$$<br>sqrt(double x)——算术平方根<br>$$</p>
<p>$$<br>log(double x)——取e的对数（log_ab=log_eb/log_ea）<br>$$</p>
<p>$$<br>sin(double x)/cos(double x)  / tan(double x) /asin(double x)  /  acos(double x)   /atan(double x) 正余弦<br>$$</p>
<p>$$<br>round(double x)——四舍五入<br>$$</p>
<h3 id="2-3-结构体（struct）的使用"><a href="#2-3-结构体（struct）的使用" class="headerlink" title="2.3 结构体（struct）的使用"></a>2.3 结构体（struct）的使用</h3><h4 id="2-3-1-格式"><a href="#2-3-1-格式" class="headerlink" title="2.3.1 格式"></a>2.3.1 格式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 类型名&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除自己外的所有数据类型</span></span><br><span class="line"></span><br><span class="line">&#125;结构体变量名；</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2访问方法"><a href="#2-3-2访问方法" class="headerlink" title="2.3.2访问方法"></a>2.3.2访问方法</h4><p>“.”（普通变量）or”-&gt;’’（指针</p>
<h4 id="2-3-3-初始化"><a href="#2-3-3-初始化" class="headerlink" title="2.3.3 初始化"></a>2.3.3 初始化</h4><p>结构体内部可以自定义初始化函数，示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studenInfo</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line">studenInfo(<span class="keyword">int</span> _id,<span class="keyword">char</span> _gender)&#123;</span><br><span class="line">id=_id;</span><br><span class="line">gender=_gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以简化为一行</span></span><br><span class="line"><span class="comment">//studenInfo(int _id,char _gender):id(_id),gender(_gender)&#123;&#125;</span></span><br><span class="line">&#125;stu,*p；</span><br></pre></td></tr></table></figure>

<h3 id="2-4-memset赋值"><a href="#2-4-memset赋值" class="headerlink" title="2.4 memset赋值"></a>2.4 memset赋值</h3><p>对每个元素赋相同的值（0/-1）</p>
<p>格式：memset（a，-1，sizeof（a））；</p>
<h3 id="2-5-补充"><a href="#2-5-补充" class="headerlink" title="2.5 补充"></a>2.5 补充</h3><h4 id="2-5-1-浮点数的比较"><a href="#2-5-1-浮点数的比较" class="headerlink" title="2.5.1 浮点数的比较"></a>2.5.1 浮点数的比较</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>；</span><br><span class="line">#define Equ(a,b) (<span class="built_in">fabs</span>((a)-(b))&lt;(eps))</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-各种复杂度"><a href="#2-5-2-各种复杂度" class="headerlink" title="2.5.2 各种复杂度"></a>2.5.2 各种复杂度</h4><ol>
<li><p>时间复杂度<br>$$<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(n^2)<br>$$</p>
<p>$$<br>ps:两个for循环的n不能超过1000，因为空间复杂度运算次数n^2不能超过10^7<br>$$</p>
<p>ps:两个for循环的n不能超过1000，因为空间复杂度不能超过</p>
</li>
<li><p>空间复杂度</p>
<p>看数组大小或者其他数据结构大小</p>
</li>
<li><p>编码复杂度</p>
<p>算法冗长，复杂度就大</p>
</li>
</ol>
<h2 id="第三章-入门：入门模拟"><a href="#第三章-入门：入门模拟" class="headerlink" title="第三章 入门：入门模拟"></a>第三章 入门：入门模拟</h2><h3 id="3-1-简单模拟"><a href="#3-1-简单模拟" class="headerlink" title="3.1 简单模拟"></a>3.1 简单模拟</h3><p>题目怎么说就·怎么做，不涉及算法</p>
<h3 id="3-2-查找元素"><a href="#3-2-查找元素" class="headerlink" title="3.2 查找元素"></a>3.2 查找元素</h3><p>给定元素，然后查找某个满足条件的元素。一般简单查找就是两个for遍历，查找算法第四章涉及</p>
<h3 id="3-3-图形输出"><a href="#3-3-图形输出" class="headerlink" title="3.3 图形输出"></a>3.3 图形输出</h3><ol>
<li><p>找规律输出</p>
</li>
<li><p>定义二维数组输出</p>
</li>
</ol>
<h3 id="3-4-日期处理"><a href="#3-4-日期处理" class="headerlink" title="3.4 日期处理*"></a>3.4 日期处理*</h3><p>平年闰年/大月小月问题，需要细心</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断闰年函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>)<span class="comment">//整除400或者整除4但不整除100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-进制转换"><a href="#3-5-进制转换" class="headerlink" title="3.5 进制转换*"></a>3.5 进制转换*</h3><ol>
<li>P进制转换成十进制</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公式法</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>,pro=<span class="number">1</span>;<span class="comment">//y为最后十进制数，pro为每次的倍数</span></span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">y=y+(x%<span class="number">10</span>)*pro;<span class="comment">//获得每次x的个位数</span></span><br><span class="line">x=x/<span class="number">10</span>;<span class="comment">//去掉x的个位数</span></span><br><span class="line">pro=pro*P;<span class="comment">//倍数增长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>十进制转换成Q进制</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除基取余法</span></span><br><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>],num=<span class="number">0</span>;<span class="comment">//z存放Q进制y的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">z[num++]=y%Q;</span><br><span class="line">y=y/Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>)<span class="comment">//商不为0时才循环，z数组从高位到低位为q进制数</span></span><br></pre></td></tr></table></figure>



<h3 id="3-6-字符串处理"><a href="#3-6-字符串处理" class="headerlink" title="3.6 字符串处理"></a>3.6 字符串处理</h3><h4 id="3-6-1-相关函数"><a href="#3-6-1-相关函数" class="headerlink" title="3.6.1 相关函数"></a>3.6.1 相关函数</h4><p>仔细分析输入输出格式，会有一些细节和边界情况，积累经验，熟练相关函数</p>
<table>
<thead>
<tr>
<th>gets</th>
<th>ges(str)</th>
<th>puts</th>
<th>puts(str)</th>
</tr>
</thead>
<tbody><tr>
<td>strcmp(str1,str2)</td>
<td>比较字符串大小（1&lt;2(-))</td>
<td>strcpy(ste1,str2)</td>
<td>复制2—&gt;1</td>
</tr>
<tr>
<td>strcat(str1,str2)</td>
<td>str2拼接到str1后面</td>
<td>strlen(str)</td>
<td>字符个数</td>
</tr>
</tbody></table>
<h4 id="3-6-2-sscanf和sprintf"><a href="#3-6-2-sscanf和sprintf" class="headerlink" title="3.6.2 sscanf和sprintf"></a>3.6.2 sscanf和sprintf</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,n);</span><br><span class="line"><span class="comment">//可以复杂一点，格式和scanf/printf差不多</span></span><br></pre></td></tr></table></figure>

<h2 id="第四章-入门：算法初步"><a href="#第四章-入门：算法初步" class="headerlink" title="第四章 入门：算法初步"></a>第四章 入门：算法初步</h2><h3 id="4-1-排序"><a href="#4-1-排序" class="headerlink" title="4.1 排序"></a>4.1 排序</h3><h4 id="4-1-1-选择排序"><a href="#4-1-1-选择排序" class="headerlink" title="4.1.1 选择排序"></a>4.1.1 选择排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i从[0,n-1]枚举，待排序部分[i,n-1],从小到大，选出最小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,i&lt;n,i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,j&lt;n,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])</span><br><span class="line">                k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];<span class="comment">//交换位置</span></span><br><span class="line">        a[i]=a[k];</span><br><span class="line">        a[k]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-冒泡排序"><a href="#4-1-2-冒泡排序" class="headerlink" title="4.1.2 冒泡排序"></a>4.1.2 冒泡排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相邻元素比较，从小到大，有序输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                            <span class="keyword">int</span> temp=a[j];<span class="comment">//交换位置</span></span><br><span class="line">                            a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                            a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                        &#125;<span class="comment">//左边数更大就换  </span></span><br><span class="line">                &#125; </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-插入排序"><a href="#4-1-3-插入排序" class="headerlink" title="4.1.3 插入排序"></a>4.1.3 插入排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组无序部分插入已有序部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> key=a[i];</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;a[j<span class="number">-1</span>]))&#123;</span><br><span class="line">                        a[j]=a[j<span class="number">-1</span>];<span class="comment">//数组后移</span></span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j]=key;<span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4归并排序"><a href="#4-1-4归并排序" class="headerlink" title="4.1.4归并排序"></a>4.1.4归并排序</h4><p>2-路归并排序思想:——将序列不断两两分组,组内单独排序,然后不断合并.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//将数组的[L1,R1]与[L2,R2]区间合井为有序区间(此处L2即为R1 +1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1,j=L2;<span class="comment">//i指向A[L1],j指向A[L2]</span></span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp临时存放合并后的数组，index为下标    </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= R1&amp;&amp;j&lt;=R2)&#123;</span><br><span class="line">       <span class="keyword">if</span>(A[i] &lt;= A[j]) &#123;</span><br><span class="line">           temp[index++] = A[i++];<span class="comment">//将A[i]加入序列temp</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           temp[index++] = A[j++];<span class="comment">//将A[j]加入序列temp</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= R1) temp[index++] = A[i++]; <span class="comment">//将[L1, R1]的剩余元素加人</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= R2) temp[index++] = A[j++]; <span class="comment">//将[L2, R2]的剩余元素加入</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        A[L1+i]=temp[i];<span class="comment">//将合并后的序列赋值回数组A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//取中点</span></span><br><span class="line">        mergeSort(A,left,mid);<span class="comment">//递归</span></span><br><span class="line">        mergeSort(A,mid+<span class="number">1</span>,right);<span class="comment">//递归</span></span><br><span class="line">        merge(A,left,mid,mid+<span class="number">1</span>,right);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-5快速排序"><a href="#4-1-5快速排序" class="headerlink" title="4.1.5快速排序"></a>4.1.5快速排序</h4><p>把A[1]存入temp,让A[1]左边数都比他小,右边数都比他大的问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=A[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp) right--;</span><br><span class="line">        A[left]=A[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">        quickSort(A,left,pos<span class="number">-1</span>);</span><br><span class="line">        quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//反复递归排序直到全部有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###</p>
<h4 id="4-1-4-排序题和sort函数的应用"><a href="#4-1-4-排序题和sort函数的应用" class="headerlink" title="4.1.4 排序题和sort函数的应用"></a>4.1.4 排序题和sort函数的应用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">编写bool cmp()函数</span><br><span class="line">sort(首地址，尾地址的下一个，cmp)</span><br></pre></td></tr></table></figure>

<h3 id="4-2散列"><a href="#4-2散列" class="headerlink" title="4.2散列"></a>4.2散列</h3><h4 id="4-2-1散列-hash-定义和整数散列"><a href="#4-2-1散列-hash-定义和整数散列" class="headerlink" title="4.2.1散列(hash)定义和整数散列"></a>4.2.1散列(hash)定义和整数散列</h4><p>将元素通过一个函数转换为整数,时该整数可以尽量唯一的代表这个元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>key是整数:</p>
<p>1.直接定址法 2.平方取中法 3. 除留余数法</p>
<p>冲突三种方法:</p>
<p>1.线性探查法 2.平方探查法 3.链地址法</p>
<h4 id="4-2-2字符串hash初步"><a href="#4-2-2字符串hash初步" class="headerlink" title="4.2.2字符串hash初步"></a>4.2.2字符串hash初步</h4><p>举例:将二维坐标P映射成整数H(P)=x*Range+y;</p>
<p>字符串hash是指将字符串S映射成整数 A<del>Z=0</del>25,a<del>z=26</del>51,整数52~62或者直接拼接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]&lt;=<span class="string">'A'</span>&amp;&amp;S[i]&gt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">            id=id*<span class="number">52</span>+(S[i]-<span class="string">'A'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S[i]&lt;=<span class="string">'a'</span>&amp;&amp;S[i]&gt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">            id=id*<span class="number">52</span>+(S[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3递归"><a href="#4-3递归" class="headerlink" title="4.3递归"></a>4.3递归</h3><h4 id="4-3-1-分治"><a href="#4-3-1-分治" class="headerlink" title="4.3.1 分治"></a>4.3.1 分治</h4><p>分解——–解决———合并</p>
<h4 id="4-3-2-递归"><a href="#4-3-2-递归" class="headerlink" title="4.3.2 递归"></a>4.3.2 递归</h4><ol>
<li><p>递归边界:分解的尽头</p>
</li>
<li><p>递归式:将原问题分解成子问题的手段</p>
</li>
<li><p>相关问题:———全排列——n皇后问题</p>
</li>
</ol>
<h3 id="4-4贪心"><a href="#4-4贪心" class="headerlink" title="4.4贪心"></a>4.4贪心</h3><p>——–考虑当前状态下局部最优</p>
<p>总的来说,贪心是用来解决一类最优化问题,并希望由局部最优解来推得全局最优解的算法思想.贪心算法适用的问题一定满足最优子结构性质,即一个问题的最优解可以由子问题的最优解有效构造出来.</p>
<h3 id="4-5二分"><a href="#4-5二分" class="headerlink" title="4.5二分"></a>4.5二分</h3><h4 id="4-5-1二分查找"><a href="#4-5-1二分查找" class="headerlink" title="4.5.1二分查找"></a>4.5.1二分查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//a[]严格递增,一般采用非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;x)&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[n]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,binarySearch(a,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:如果二分上界超过int数据一半,可能溢出,此时用mid=left+(right-left)/2代替mid=(left+right)/2</p>
<h4 id="4-5-2二分法拓展"><a href="#4-5-2二分法拓展" class="headerlink" title="4.5.2二分法拓展"></a>4.5.2二分法拓展</h4><p>求近似平方根问题/装水问题/木棒切割问题</p>
<h4 id="4-5-3快速幂"><a href="#4-5-3快速幂" class="headerlink" title="4.5.3快速幂"></a>4.5.3快速幂</h4><p>快速幂又叫二分幂,基于以下事实:<br>$$<br>1.如果b是偶数,那么a^b=a*a^{b-1}<br>$$</p>
<p>$$<br>2.如果b是奇数,那么a^b=a^{b/2}*a^{b/2}<br>$$</p>
<ol>
<li>快速幂的递归写法,时间复杂度O(logb)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) <span class="comment">//可以用if(b&amp;1)代替</span></span><br><span class="line">        <span class="keyword">return</span> a*binaryPow(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mul=binaryPow(a,b/<span class="number">2</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul*mul%m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速幂的迭代写法(效率差异不高):</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">//求a^b%m</span></span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=ans*a%m;</span><br><span class="line">        &#125;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6two-points"><a href="#4-6two-points" class="headerlink" title="4.6two points"></a>4.6two points</h3><h4 id="4-6-1-概念"><a href="#4-6-1-概念" class="headerlink" title="4.6.1 概念"></a>4.6.1 概念</h4><p>利用问题本身和序列特性,使用两个下标i,j对序列进行扫描(同向或反向),从而以较低复杂度(一般是O(n))解决问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a[n]递增序列,正整数M,求a[i]+a[j]=M,two points思想示例</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j]==m)&#123;</span><br><span class="line">        ptintf(<span class="string">"%d %d\n"</span>,i,j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j]&lt;m)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//序列合并问题在下一小节有递归和非递归实现</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-2归并排序"><a href="#4-6-2归并排序" class="headerlink" title="4.6.2归并排序"></a>4.6.2归并排序</h4><p>2-路归并排序思想:——将序列不断两两分组,组内单独排序,然后不断合并.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//将数组的[L1,R1]与[L2,R2]区间合井为有序区间(此处L2即为R1 +1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1,j=L2;<span class="comment">//i指向A[L1],j指向A[L2]</span></span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp临时存放合并后的数组，index为下标    </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= R1&amp;&amp;j&lt;=R2)&#123;</span><br><span class="line">       <span class="keyword">if</span>(A[i] &lt;= A[j]) &#123;</span><br><span class="line">           temp[index++] = A[i++];<span class="comment">//将A[i]加入序列temp</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           temp[index++] = A[j++];<span class="comment">//将A[j]加入序列temp</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= R1) temp[index++] = A[i++]; <span class="comment">//将[L1, R1]的剩余元素加人</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= R2) temp[index++] = A[j++]; <span class="comment">//将[L2, R2]的剩余元素加入</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        A[L1+i]=temp[i];<span class="comment">//将合并后的序列赋值回数组A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//取中点</span></span><br><span class="line">        mergeSort(A,left,mid);<span class="comment">//递归</span></span><br><span class="line">        mergeSort(A,mid+<span class="number">1</span>,right);<span class="comment">//递归</span></span><br><span class="line">        merge(A,left,mid,mid+<span class="number">1</span>,right);<span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-3快速排序"><a href="#4-6-3快速排序" class="headerlink" title="4.6.3快速排序"></a>4.6.3快速排序</h4><p>把A[1]存入temp,让A[1]左边数都比他小,右边数都比他大的问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=A[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp) right--;</span><br><span class="line">        A[left]=A[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=Partition(A,left,right);</span><br><span class="line">        quickSort(A,left,pos<span class="number">-1</span>);</span><br><span class="line">        quickSort(A,pos+<span class="number">1</span>,right);<span class="comment">//反复递归排序直到全部有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-4生成随机数"><a href="#4-6-4生成随机数" class="headerlink" title="4.6.4生成随机数"></a>4.6.4生成随机数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//程序必备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//随机数必备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//随机数必备</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(null));<span class="comment">//main方法第一句,生成随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,rand());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li><p>生成的是[0,RAND_MAX]范围内整数,如果想输出[a,b]范围内,需要使用rand()%(b-a+1)+a;显然rand()%(b-a+1)的范围是[0,b-a],再加上a就是[a,b]</p>
</li>
<li><p>想生成更大范围的随机数</p>
<p>(int)(round(1.0<em>rand()/RAND_MAX</em>(b-a)+a)</p>
</li>
</ol>
<h3 id="4-7其他高效技巧与算法"><a href="#4-7其他高效技巧与算法" class="headerlink" title="4.7其他高效技巧与算法"></a>4.7其他高效技巧与算法</h3><h4 id="4-7-1打表"><a href="#4-7-1打表" class="headerlink" title="4.7.1打表"></a>4.7.1打表</h4><ol>
<li>在程序中一次性计算出所有需要用到的结果,之后的查询直接取这些结果;</li>
<li>在程序B中分一次或多次计算出所有需要用到的结果,写在程序A中结果集中,然后在程序A中就可以直接使用这些结果;</li>
<li>先暴力计算小范围数据,再找规律.</li>
</ol>
<h4 id="4-7-2-活用递推"><a href="#4-7-2-活用递推" class="headerlink" title="4.7.2 活用递推"></a>4.7.2 活用递推</h4><p>一种思想,细心考虑找出题目中递推关系.</p>
<h4 id="4-7-3随机选择算法"><a href="#4-7-3随机选择算法" class="headerlink" title="4.7.3随机选择算法"></a>4.7.3随机选择算法</h4><p>原理:类似于随即快速排序算法,</p>
<p>问题:从一个无序数组中求得第K大的数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=A[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[right]&gt;temp) right--;</span><br><span class="line">        A[left]=A[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;A[left]&lt;=temp) left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) <span class="keyword">return</span> a[left];</span><br><span class="line">    <span class="keyword">int</span> p=randPartition(a,left,right);</span><br><span class="line">    <span class="keyword">int</span> M=p-left+<span class="number">1</span>;<span class="comment">//主元是a[p],第p-left+1大的数</span></span><br><span class="line">    <span class="keyword">if</span>(K==M) <span class="keyword">return</span> a[p]</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K&lt;M)&#123;</span><br><span class="line">        randSelect(a,left,p<span class="number">-1</span>,K);<span class="comment">//往左找</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        randSelect(a,p+<span class="number">1</span>,right,K-M);<span class="comment">//往右找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第五章-入门：数学问题"><a href="#第五章-入门：数学问题" class="headerlink" title="第五章 入门：数学问题"></a>第五章 入门：数学问题</h2><h3 id="5-1简单数学"><a href="#5-1简单数学" class="headerlink" title="5.1简单数学"></a>5.1简单数学</h3><p>掌握简单的数理逻辑,就是些水题,ccf第一题那种.</p>
<h3 id="5-2最大公约数与最小公倍数"><a href="#5-2最大公约数与最小公倍数" class="headerlink" title="5.2最大公约数与最小公倍数"></a>5.2最大公约数与最小公倍数</h3><h4 id="5-2-1最大公约数"><a href="#5-2-1最大公约数" class="headerlink" title="5.2.1最大公约数"></a>5.2.1最大公约数</h4><p>——————–实现原理:欧几里得算法(辗转相除法)</p>
<ol>
<li>递归式:        gcd(a,b)=gcd(b,a%b)</li>
<li>递归边界:     gcd(a,0)=a</li>
<li>代码实现:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更简洁的写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2最小公倍数"><a href="#5-2-2最小公倍数" class="headerlink" title="5.2.2最小公倍数"></a>5.2.2最小公倍数</h4><ol>
<li>公式:a*b/d</li>
<li>代码实现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d=gcd(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(a*b/d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3分数的四则运算"><a href="#5-3分数的四则运算" class="headerlink" title="5.3分数的四则运算"></a>5.3分数的四则运算</h3><p>所谓的分数的四则运算是指,给定两个分数的分子和分母,求他们加减乘除的结果</p>
<h4 id="5-3-1分数的表示和化简"><a href="#5-3-1分数的表示和化简" class="headerlink" title="5.3.1分数的表示和化简."></a>5.3.1分数的表示和化简.</h4><ol>
<li><p>分数的表示——-对个分数来说， 最简洁的写法就是写成假分数的形式， 即无论分子比分母大或者小，都保留其原数。因此可以使用一个结构体来存储这种只有分子和分母的分数:</p>
<p>于是就可以定义Fraction 类型的变量来表示分数，或者定义数组来表示一堆分数。其中需要对这种表示制订三项规则:</p>
<pre><code>①使down为非负数。如果分数为负，那么令分子up为负即可。
②如果该分数恰为0，那么规定其分子为0，分母为1。
③分子和分母没有除了1以外的公约数。</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>&#123;</span><span class="comment">//分数</span></span><br><span class="line"><span class="keyword">int</span> up, down;<span class="comment">//分子、分母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分数的化简——-分数的化简主要用来使Fraction变量满足分数表示的三项规定，因此化简步骤也分为以下三步:</p>
<pre><code>①如果分母down为负数，那么令分子up和分母down都变为相反数。
②如果分子up为0，那么令分母down为1.
③约分:求出分子绝对值与分母绝对值的最大公约数d,然后令分子分母同时除以d.
 代码如下:</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">reduction</span> <span class="params">(Fraction result)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(result.down &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//分母为负数，令分子和分母都变为相反数</span></span><br><span class="line">result.up = -result.up;</span><br><span class="line">result.down = - result.down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果分子为0,令分母为1</span></span><br><span class="line"><span class="keyword">if</span> (result.up == <span class="number">0</span>) &#123;</span><br><span class="line">result.down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果分子不为0，进行约分</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> d=gcd(<span class="built_in">abs</span> (result .up), <span class="built_in">abs</span> (result dow)); <span class="comment">//分子分母的最大公约数</span></span><br><span class="line">result.up /= d;<span class="comment">//约去最大公约数</span></span><br><span class="line">result.down /= d;</span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-3-2分数的四则运算"><a href="#5-3-2分数的四则运算" class="headerlink" title="5.3.2分数的四则运算"></a>5.3.2分数的四则运算</h4><ol>
<li>加减:</li>
</ol>
<p>result=(f1.up*f2.down+f1.down*f2.up)/(f1.down*f2.down)</p>
<p>result=(f1.up*f2.down-f1.down*f2.up)/(f1.down*f2.down)</p>
<ol start="2">
<li>乘除</li>
</ol>
<p>result=(f1.up*f2.up)/(f1.down*f2.down)</p>
<p>result=(f1.up*f2.down)/(f1.down*f2.up)</p>
<ol start="3">
<li>ps:必须当心判断除数不为0</li>
</ol>
<h4 id="5-3-3分数的输出"><a href="#5-3-3分数的输出" class="headerlink" title="5.3.3分数的输出"></a>5.3.3分数的输出</h4><ol>
<li><p>分数的输出根据题目的要求进行，但是大体上有以下几个注意点:<br>①输出分数前，先化简<br>②如果分数r的分母down为1,该分数是整数,一般来说题目会要求直接输出分子而省略分母。<br>③如果分数r的分子up的绝对值&gt;分母down (想一想分子为什么要取绝对值? )，说明该分数是假分数，此时应按带分数的形式输出，即整数部分为r.up /r.down,分子部分为<br>abs(r.up) % r.down,分母部分为r.down.<br>④以上均不满足时说明分数r是真分数，按原样输出即可。</p>
</li>
<li><p>以下是一个输出示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span> <span class="params">(Fraction r)</span> </span>&#123;</span><br><span class="line"><span class="comment">//输出分数,先分数化简</span></span><br><span class="line">r=reduction(r) ;</span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">if</span>(r.down==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld"</span>, r.up) ;</span><br><span class="line"><span class="comment">//假分数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up) &gt; r.down) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d/%d"</span>, r.up / r.down, <span class="built_in">abs</span>(r.up) %r.down, r.down) ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//真分数</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d%d"</span>, r.up,r.down) ;</span><br><span class="line"><span class="comment">/*强调一点:由于分数的乘法和除法的过程中可能使分子或分母超过int型表示范围，因</span></span><br><span class="line"><span class="comment">此一般情况下，分子和分母应当使用long long型来存储。*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-4素数"><a href="#5-4素数" class="headerlink" title="5.4素数"></a>5.4素数</h3><p><strong>1不是素数,也不是合数</strong></p>
<h4 id="5-4-1素数判断"><a href="#5-4-1素数判断" class="headerlink" title="5.4.1素数判断"></a>5.4.1素数判断</h4><p>如果存在被整除的数，一定有一个小于sqrt(n),一个大于sqrt(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2素数表"><a href="#5-4-2素数表" class="headerlink" title="5.4.2素数表"></a>5.4.2素数表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n为10的5次方以内的范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> Prime[maxn],pNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            Prime[pNum++]=i;</span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-3埃氏筛法"><a href="#5-4-3埃氏筛法" class="headerlink" title="5.4.3埃氏筛法:"></a>5.4.3埃氏筛法:</h4><p>————如果要求更大的数，则启用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n为10的5次方以内的范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> Prime[maxn],pNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            Prime[pNum++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;maxn;j+=i)&#123;</span><br><span class="line">                <span class="comment">//筛去所有i的倍数，循环条件不能写成j&lt;=maxn</span></span><br><span class="line">                p[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-质因子分解"><a href="#5-5-质因子分解" class="headerlink" title="5.5 质因子分解"></a>5.5 质因子分解</h3><p>————将一个正整数分解成一个或多个质数的乘积的形式,分解步骤：</p>
<ol>
<li><p>创建一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,cnt;<span class="comment">//x_质因子，cnt_其个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];<span class="comment">//fac数组开到10就可以了，不论题目</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举1~sqrt(n)所有质因子p，判断是否是n的质因子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;<span class="comment">//如果是质因子</span></span><br><span class="line">    fac[num].x=prime[i];<span class="comment">//增加质因子</span></span><br><span class="line">    fac[num].cnt=<span class="number">0</span>;<span class="comment">//初始化个数</span></span><br><span class="line">    <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">        fac[num].cnt++;<span class="comment">//计算个数</span></span><br><span class="line">        n/=prime[i];</span><br><span class="line">    &#125;</span><br><span class="line">    num++;<span class="comment">//检查下一个质因子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述步骤结束后仍然大于1，还有个大于sqrt(n)的质因子n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;<span class="comment">//无法被除尽</span></span><br><span class="line">    fac[num].x=n;<span class="comment">//把n放进去</span></span><br><span class="line">    fac[num++].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-6大整数运算"><a href="#5-6大整数运算" class="headerlink" title="5.6大整数运算"></a>5.6大整数运算</h3><p>———–定义：高精度的整数，就是无法用基础数据类型存储其精度的整数</p>
<h4 id="5-6-1大整数的存储"><a href="#5-6-1大整数的存储" class="headerlink" title="5.6.1大整数的存储"></a>5.6.1大整数的存储</h4><ol>
<li>定义一个整数数组存储，高位存高位，低位存低位的顺序存储，为了方便获取长度，一般定义一个结构体：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    bign()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//每次结构体变量被定义都会自动初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>但每次输入大整数一般用字符串先读入，然后再把字符串另存为bign结构体。由于char数组读入会翻转，高位存低位，低位存高位的顺序存储，即我们需要再翻转回来</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;<span class="comment">//逆着赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果要比较两个大整数大小的规则：1.判断len大小；2.从高到低比较数字大小。</li>
</ol>
<h4 id="5-6-2大整数的四则运算"><a href="#5-6-2大整数的四则运算" class="headerlink" title="5.6.2大整数的四则运算"></a>5.6.2大整数的四则运算</h4><p>类似于列竖式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高精度加法</span></span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]+b.d[i]+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;<span class="comment">//个位为结果</span></span><br><span class="line">        carry=temp/<span class="number">10</span>；<span class="comment">//10位为进位</span></span><br><span class="line">    &#125;<span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意point：这个模板针对非负整数，如果有单个负数，可以转换时去负号，用减法</span></span><br><span class="line"><span class="comment">//如果都是负数，取绝对值用加法，然后结果加上负数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.d[i]&lt;b.d[i])&#123;<span class="comment">//不够减</span></span><br><span class="line">            a.d[i+<span class="number">1</span>]--;<span class="comment">//向高位借位</span></span><br><span class="line">            a.d[i]+=<span class="number">10</span>;<span class="comment">//加10</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.d[c.len++]=a.d[i]-b.d[i];<span class="comment">//减法结果为当前位结果</span></span><br><span class="line">        <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;<span class="comment">//去除最高位的0且至少保留一位最低位</span></span><br><span class="line">            c.len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意point：使用sub前比较两个数的大小，如果被减数小于减数，则调换数组相减，结果加上负号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高精度与低精度乘法</span></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++]==temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;whiel(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry=carry/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">////高精度与低精度除法</span></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b，<span class="keyword">int</span> &amp;r)</span></span>&#123;<span class="comment">//r为余数</span></span><br><span class="line">    bign c;</span><br><span class="line">    c.len=a.len;<span class="comment">//被除数与商位数一一对应，长度相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">        <span class="keyword">if</span>(r&lt;b) c.d[i]=<span class="number">0</span><span class="comment">//不够除</span></span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//够除</span></span><br><span class="line">             c.d[i]=r/b;</span><br><span class="line">             r=r%b;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;<span class="comment">//去除最高位的0且至少保留一位最低位</span></span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7扩展欧几里得算法"><a href="#5-7扩展欧几里得算法" class="headerlink" title="5.7扩展欧几里得算法"></a>5.7扩展欧几里得算法</h3><p>暂时不学，有需要再回来</p>
<h3 id="5-8组合数"><a href="#5-8组合数" class="headerlink" title="5.8组合数"></a>5.8组合数</h3><h4 id="5-8-1关于n-的一个问题"><a href="#5-8-1关于n-的一个问题" class="headerlink" title="5.8.1关于n!的一个问题"></a>5.8.1关于n!的一个问题</h4><p>$$<br>n!中有（n/p+n/p^2+n/p^3+…)个质因子<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n!中有多少个质因子p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        ans+=n/p;</span><br><span class="line">        n/=p;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个可以推广计算<strong>n!的末尾有多少个0（等于n!中因子10的个数）</strong></p>
<p>一个概念：</p>
<p><strong>n！中质因子p的个数，实际上等于1~n中p的倍数的个数n/p加上n/p！中质因子p的个数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因此得出cal的递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n&lt;p) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//n&lt;p时，不可能再存在质因子</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n/p+cal(n/p,p)<span class="comment">//返回n/p！中质因子p的个数**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-8-2组合数的计算"><a href="#5-8-2组合数的计算" class="headerlink" title="5.8.2组合数的计算"></a>5.8.2组合数的计算</h4><p>方法一：根据定义式计算——暴力破解，容易溢出，忽略</p>
<p>方法二：根据递推式计算<br>$$<br>递归公式：C_n^m=C_{n-1}^m+C_{n-1}^{m-1}<br>$$</p>
<p>$$<br>递归边界：C_n^0=C_n^n=1<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long LL;</span></span><br><span class="line">LL res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n,LL m)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];<span class="comment">//记录已经计算过的C[n][m],防止重复计算</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res[n][m]=C(n<span class="number">-1</span>,m)+C(n<span class="number">-1</span>,m<span class="number">-1</span>);<span class="comment">//赋值并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：定义式变形</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long LL;</span></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n,LL m)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=ans*(n-m+<span class="number">1</span>)/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-8-2-组合数-p的计算"><a href="#5-8-2-组合数-p的计算" class="headerlink" title="5.8.2 组合数%p的计算"></a>5.8.2 组合数%p的计算</h4><ol>
<li>方法一：通过递推式(只要在源代码合适的地方对p取模就行)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> long long LL;</span></span><br><span class="line">LL res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n,LL m)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(res[n][m]!=<span class="number">0</span>) <span class="keyword">return</span> res[n][m];<span class="comment">//记录已经计算过的C[n][m],防止重复计算</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res[n][m]=C(n<span class="number">-1</span>,m)+C(n<span class="number">-1</span>,m<span class="number">-1</span>)%p;<span class="comment">//赋值并返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二：根据定义式(原理P186，比较复杂，看书吧)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用筛法得到素数表prime,注意表中最大素数不得小于n</span></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="comment">//计算C(n,m)%p</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//遍历不超过n的所有质数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt;= n;i++) &#123;</span><br><span class="line"><span class="comment">//计算C(n,m)中prime[i]的指数c，cal (n,k)为n!中含质因子k的个数</span></span><br><span class="line"><span class="keyword">int</span> C = cal(n, prime[i]) - cal (m, prime[i]) -cal(n - m, prime[i]);</span><br><span class="line"><span class="comment">//快速幂计算prime[i]^c%p</span></span><br><span class="line">ans = ans * binaryPow(prime[i], C，p)%p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>方法四：lucas定理（需要结合方法2使用）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> C(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;<span class="comment">//原理没看，代码不长可以死记，或者看书189页</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>方法数据范围</li>
</ol>
<table>
<thead>
<tr>
<th>示例</th>
<th>n</th>
<th>m</th>
<th>p</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>case1</td>
<td>&lt;=10^4</td>
<td>&lt;=10^4</td>
<td>&lt;=10^9</td>
<td>方法一</td>
</tr>
<tr>
<td>case2</td>
<td>&lt;=10^6</td>
<td>&lt;=10^6</td>
<td>&lt;=10^9</td>
<td>方法二</td>
</tr>
<tr>
<td>case3</td>
<td>&lt;=10^18</td>
<td>&lt;=10^18</td>
<td>&lt;=10^9(p是素数)</td>
<td>方法四</td>
</tr>
</tbody></table>
<p>方法三太长了，以后再看，一般情况下方法一就够用了。</p>
<h2 id="第六章-C-标准模板库STL"><a href="#第六章-C-标准模板库STL" class="headerlink" title="第六章 C++标准模板库STL"></a>第六章 C++标准模板库STL</h2><p>———————————————<strong><em>（Standard Template Library）</em></strong></p>
<p>———————————————–#include&lt;stdlib.h&gt;//标准库函数</p>
<h3 id="6-1vector"><a href="#6-1vector" class="headerlink" title="6.1vector"></a>6.1vector</h3><h4 id="6-1-1-定义"><a href="#6-1-1-定义" class="headerlink" title="6.1.1 定义"></a>6.1.1 定义</h4><p>中文译名：“向量”，容易理解的叫法：“变长数组”，即“长度根据需要自动改变的数组”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="comment">//基本数据类型举例</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>[arraySize];</span><br><span class="line"><span class="comment">//注意：typename是STL容器是，&gt;&gt;之间必须加空格，举例</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vi;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2元素访问"><a href="#6-1-2元素访问" class="headerlink" title="6.1.2元素访问"></a>6.1.2元素访问</h4><ol>
<li><p>下标访问 </p>
<p>范围0~v.size-1,比如v[0],v[1]等</p>
</li>
<li><p>迭代器访问</p>
<p>迭代器iterator类似于指针,通过*it来访问</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vi.<span class="built_in">begin</span>();</span><br><span class="line">it++;it--;</span><br><span class="line"><span class="comment">//*(it+1)等价于vi[i]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：<ol>
<li>vi.begin()指向首地址，vi.end()指向尾地址下一个空地址，因为美国人习惯左闭右开</li>
<li>只有vector和string中，才允许vi.begin()+3这种整数加迭代器的写法</li>
</ol>
</li>
</ol>
<h4 id="6-1-3常用函数"><a href="#6-1-3常用函数" class="headerlink" title="6.1.3常用函数"></a>6.1.3常用函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vi.push_back(x);<span class="comment">//尾部添加元素</span></span><br><span class="line">vi.pop_back(x);<span class="comment">//删除尾元素</span></span><br><span class="line">vi.<span class="built_in">size</span>();<span class="comment">//获得元素个数</span></span><br><span class="line">vi.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">vi.insert(it,x);<span class="comment">//向it位置插入x</span></span><br><span class="line">vi.erase(it);<span class="comment">//删除迭代器为it位置的元素</span></span><br><span class="line">vi.erase(first,last)<span class="comment">//删除[first,last)范围内的所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="6-1-4常见用途"><a href="#6-1-4常见用途" class="headerlink" title="6.1.4常见用途"></a>6.1.4常见用途</h4><ol>
<li>存储数据</li>
<li>用邻接表存储图——10.2.2节</li>
</ol>
<h3 id="6-2set"><a href="#6-2set" class="headerlink" title="6.2set"></a>6.2set</h3><h4 id="6-2-1定义"><a href="#6-2-1定义" class="headerlink" title="6.2.1定义"></a>6.2.1定义</h4><p>中文译名：“集合”，即“内部自动有序且不含重复元素的容器”，字面理解可知set内元素自动递增，且自动去除重复元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="comment">//基本数据类型举例</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>[arraySize];</span><br><span class="line"><span class="comment">//注意：typename是STL容器是，&gt;&gt;之间必须加空格，举例</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; st;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2元素访问"><a href="#6-2-2元素访问" class="headerlink" title="6.2.2元素访问"></a>6.2.2元素访问</h4><p>只能用迭代器访问，不支持*（it+i）来访问，只能枚举</p>
<h4 id="6-2-3常用函数"><a href="#6-2-3常用函数" class="headerlink" title="6.2.3常用函数"></a>6.2.3常用函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">st.<span class="built_in">size</span>();<span class="comment">//获得元素个数</span></span><br><span class="line">st.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">st.insert(x);<span class="comment">//插入x</span></span><br><span class="line">st.<span class="built_in">find</span>(x);<span class="comment">//返回对应值为x的迭代器</span></span><br><span class="line"><span class="comment">//删除单个元素-------------------------------------------------</span></span><br><span class="line">st.erase(st.<span class="built_in">find</span>(x));<span class="comment">//删除迭代器为it位置的元素，可以搭配find(x)</span></span><br><span class="line">st.erase(x);<span class="comment">//直接删除值为x的set元素</span></span><br><span class="line"><span class="comment">//删除多个元素-------------------------------------------------</span></span><br><span class="line">st.erase(first,last)<span class="comment">//删除[first,last)范围内的所有元素，可以搭配find(x)</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-4常见用途"><a href="#6-2-4常见用途" class="headerlink" title="6.2.4常见用途"></a>6.2.4常见用途</h4><p>自动去重以及升序排序。</p>
<p>延申：set元素唯一，不唯一用multiset。另外C++ 11中·增加了unordered_set,只去重不排序。</p>
<h3 id="6-3string"><a href="#6-3string" class="headerlink" title="6.3string"></a>6.3string</h3><h4 id="6-3-1定义"><a href="#6-3-1定义" class="headerlink" title="6.3.1定义"></a>6.3.1定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;//注意和string.h不一样</span></span></span><br><span class="line"><span class="built_in">string</span> str=<span class="string">"str"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2元素访问"><a href="#6-3-2元素访问" class="headerlink" title="6.3.2元素访问"></a>6.3.2元素访问</h4><ol>
<li><p>通过下标访问和迭代器访问都可以，而且迭代器可支持直接+i；</p>
</li>
<li><p>读入与输出一般cin/cout，如果想用printf，可以str.c_str(）将string类型强制转换为字符数组。</p>
</li>
</ol>
<h4 id="6-3-3常用函数"><a href="#6-3-3常用函数" class="headerlink" title="6.3.3常用函数"></a>6.3.3常用函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> +;<span class="comment">//字符串拼接，str1+str+2</span></span><br><span class="line">compare <span class="keyword">operator</span>：包括==,!=,&lt;,&lt;=,&gt;,&gt;=<span class="comment">//按字典序比较</span></span><br><span class="line">str.<span class="built_in">size</span>() / str.length();<span class="comment">//字符串长度</span></span><br><span class="line"></span><br><span class="line">str.insert();<span class="comment">//插入</span></span><br><span class="line">str.insert(pos,<span class="built_in">string</span>);<span class="comment">//pos位置插入string</span></span><br><span class="line">str.insert(it,it2,it3);<span class="comment">//[it2,it3)位置字符串插入it位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除单个元素-------------------------------------------------</span></span><br><span class="line">str.erase(it);<span class="comment">//删除迭代器为it位置的元素</span></span><br><span class="line"><span class="comment">//删除多个元素-------------------------------------------------</span></span><br><span class="line">str.erase(first,last);<span class="comment">//删除[first,last)范围内的所有子串</span></span><br><span class="line">str.erase(pos,length);<span class="comment">//pos插入位，length删除长度</span></span><br><span class="line">    </span><br><span class="line">str.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">str.substr(pos,len);<span class="comment">//返回pos位置长度为len的字符串</span></span><br><span class="line">str.<span class="built_in">find</span>(str);<span class="comment">//寻找字符串str,没找到返回string:npos;</span></span><br><span class="line">str.<span class="built_in">find</span>(str，pos);<span class="comment">//寻找pos开始往后的字符串str,没找到返回string:npos;</span></span><br><span class="line"><span class="built_in">string</span>:npos;<span class="comment">//常数，-1</span></span><br><span class="line"></span><br><span class="line">str.replace(pos,len,str2);<span class="comment">//把pos位置开始长度为len的字符串替换为str2</span></span><br><span class="line">str.replace(it1,it2,str2);<span class="comment">//把[it1，it2)的字符串替换成str2</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4map"><a href="#6-4map" class="headerlink" title="6.4map"></a>6.4map</h3><h4 id="6-2-1定义-1"><a href="#6-2-1定义-1" class="headerlink" title="6.2.1定义"></a>6.2.1定义</h4><p>中文译名：“映射”，即“将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）”，map会以键值从小到大排序，键值对唯一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt; name;<span class="comment">//将typename1（键key）映射到typename2（值value）</span></span><br><span class="line"><span class="comment">//基本数据类型举例</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;,<span class="built_in">string</span>&gt; mp;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2元素访问-1"><a href="#6-2-2元素访问-1" class="headerlink" title="6.2.2元素访问"></a>6.2.2元素访问</h4><ol>
<li><p>下标：mp[key]</p>
</li>
<li><p>迭代器：it-&gt;first访问key，it-second访问value</p>
</li>
</ol>
<h4 id="6-2-3常用函数-1"><a href="#6-2-3常用函数-1" class="headerlink" title="6.2.3常用函数"></a>6.2.3常用函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mp.<span class="built_in">find</span>(key);<span class="comment">//寻找键值为key的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除单个元素-------------------------------------------------</span></span><br><span class="line">mp.erase(it);<span class="comment">//删除迭代器为it位置的元素</span></span><br><span class="line">mp.erase(key);<span class="comment">//删除key对应的元素</span></span><br><span class="line"><span class="comment">//删除多个元素-------------------------------------------------</span></span><br><span class="line">mp.erase(first,last);<span class="comment">//删除[first,last)范围内的所有子串</span></span><br><span class="line">    </span><br><span class="line">mp.<span class="built_in">size</span>();<span class="comment">//获得映射对数</span></span><br><span class="line">mp.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-4常见用途-1"><a href="#6-2-4常见用途-1" class="headerlink" title="6.2.4常见用途"></a>6.2.4常见用途</h4><ol>
<li>字符串与整数映射题目</li>
<li>判断大整数或者其他类型数据是否存在的题目，把map当bool数组用</li>
<li>字符串和字符串的映射</li>
<li>延申：map元素唯一，不唯一用multimap。另外C++ 11中·增加了unordered_map,只映射不排序。</li>
</ol>
<h3 id="6-5queue"><a href="#6-5queue" class="headerlink" title="6.5queue"></a>6.5queue</h3><h4 id="6-2-1定义-2"><a href="#6-2-1定义-2" class="headerlink" title="6.2.1定义"></a>6.2.1定义</h4><p>先进先出，类似排队，队首指针front，队尾指针rear</p>
<h4 id="6-2-2元素访问-2"><a href="#6-2-2元素访问-2" class="headerlink" title="6.2.2元素访问"></a>6.2.2元素访问</h4><ol>
<li>队首指针front——队首元素，初始-1</li>
<li>队尾指针rear——队尾元素，初始-1</li>
</ol>
<h4 id="6-2-3常用函数-2"><a href="#6-2-3常用函数-2" class="headerlink" title="6.2.3常用函数"></a>6.2.3常用函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先进先出，类似排队，队首指针front，队尾指针rear</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;Type&gt; q; <span class="comment">//其中Type为数据类型（如 int，float,char等）</span></span><br><span class="line">q.push(item)           <span class="comment">//q[++rear];         将item压入队列尾部  </span></span><br><span class="line">q.pop()                <span class="comment">//front++;           删除队首元素，但不返回  </span></span><br><span class="line">q.front()              <span class="comment">//q[front+1];        返回队首元素，但不删除  </span></span><br><span class="line">q.back()               <span class="comment">//q[rear];           返回队尾元素，但不删除  </span></span><br><span class="line">q.<span class="built_in">size</span>()               <span class="comment">//return rear-front; 返回队列中元素的个数  </span></span><br><span class="line">q.empty()              <span class="comment">//if(front==rear)&#123;&#125;; 检查队列是否为空，如果为空返回true，否则返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-4常见用途-2"><a href="#6-2-4常见用途-2" class="headerlink" title="6.2.4常见用途"></a>6.2.4常见用途</h4><p>需要实现广度优先搜索时，不手动实现而是用queue做代替</p>
<p>注意：使用front()和pop()之前，必须用empty（）判断队列是否为空，否则可能因此出现错误。</p>
<h3 id="6-6priority-queue"><a href="#6-6priority-queue" class="headerlink" title="6.6priority_queue"></a>6.6priority_queue</h3><h4 id="6-4-1定义"><a href="#6-4-1定义" class="headerlink" title="6.4.1定义"></a>6.4.1定义</h4><p>优先队列，底层是堆，队首元素是优先级最高的那一个</p>
<h4 id="6-4-2元素访问"><a href="#6-4-2元素访问" class="headerlink" title="6.4.2元素访问"></a>6.4.2元素访问</h4><p>没有front()/back()函数，只能通过top()来访问队首元素</p>
<h4 id="6-4-3常用函数"><a href="#6-4-3常用函数" class="headerlink" title="6.4.3常用函数"></a>6.4.3常用函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先进先出，类似排队，队首指针front，队尾指针rear</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;Type&gt; q; <span class="comment">//其中Type为数据类型（如 int，float,char等）</span></span><br><span class="line">q.push(item)           <span class="comment">//q[++rear];         将item压入队列尾部  </span></span><br><span class="line">q.pop()                <span class="comment">//front++;           删除队首元素，但不返回  </span></span><br><span class="line">q.top()              <span class="comment">//q[front+1];        返回队首元素，但不删除  </span></span><br><span class="line">q.<span class="built_in">size</span>()               <span class="comment">//return rear-front; 返回队列中元素的个数  </span></span><br><span class="line">q.empty()              <span class="comment">//if(front==rear)&#123;&#125;; 检查队列是否为空，如果为空返回true，否则返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-4常见用途"><a href="#6-4-4常见用途" class="headerlink" title="6.4.4常见用途"></a>6.4.4常见用途</h4><p>解决一些贪心问题（9.8节），或者对Dijkstra算法进行优化</p>
<p>注意：使用top()之前，必须用empty（）判断队列是否为空，否则可能因此出现错误。</p>
<h4 id="6-4-5元素优先级的设置"><a href="#6-4-5元素优先级的设置" class="headerlink" title="6.4.5元素优先级的设置"></a>6.4.5元素优先级的设置</h4><ol>
<li>基础类型</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">priority_queue&lt;<span class="keyword">typename</span>,<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;,less&lt;<span class="keyword">typename</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//less&lt;typename&gt;表示数字大的优先级大，而greater&lt;typename&gt;表示数字小的优先级大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;,less&lt;<span class="keyword">double</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>结构体类型</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> operater &lt; (fruit f1,fruit f2)&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//此时水果价格低的，优先级高</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">    另一种方法看书，暂时准备只记这个</span><br></pre></td></tr></table></figure>

<p>可以推出：</p>
<p>如果基本数据类型或者其他STL容器，也可以通过同样的方式来定义优先级</p>
<p>如果结构体数据较为庞大，建议使用引用提供效率，此时要加上const和&amp;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> operater &lt; (<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2)&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//此时水果价格低的，优先级高</span></span><br></pre></td></tr></table></figure>

<h3 id="6-7stack"><a href="#6-7stack" class="headerlink" title="6.7stack"></a>6.7stack</h3><h4 id="6-7-1定义"><a href="#6-7-1定义" class="headerlink" title="6.7.1定义"></a>6.7.1定义</h4><p>栈，后进先出，类似盒子，栈顶指针TOP=-1</p>
<h4 id="6-7-2元素访问"><a href="#6-7-2元素访问" class="headerlink" title="6.7.2元素访问"></a>6.7.2元素访问</h4><p>s.top();</p>
<h4 id="6-7-3常用函数"><a href="#6-7-3常用函数" class="headerlink" title="6.7.3常用函数"></a>6.7.3常用函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后进先出，类似盒子，栈顶指针TOP=-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;Type&gt; s;<span class="comment">//其中Type为数据类型（如 int，float,char等）。</span></span><br><span class="line">s.push(item);       <span class="comment">//st[++TOP]=item;  将item压入栈顶  </span></span><br><span class="line">s.pop();            <span class="comment">//TOP--;           删除栈顶的元素，但不会返回  </span></span><br><span class="line">s.top();            <span class="comment">//return st[TOP];  返回栈顶的元素，但不会删除  </span></span><br><span class="line">s.<span class="built_in">size</span>();           <span class="comment">//return TOP+1;    返回栈中元素的个数  </span></span><br><span class="line">s.empty();          <span class="comment">//if(TOP==-1)&#123;&#125;;   检查栈是否为空，为空返回true，否则返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="6-7-4常见用途"><a href="#6-7-4常见用途" class="headerlink" title="6.7.4常见用途"></a>6.7.4常见用途</h4><p>模拟递归，防止栈内存溢出</p>
<h3 id="6-8pair"><a href="#6-8pair" class="headerlink" title="6.8pair"></a>6.8pair</h3><h4 id="6-8-1定义"><a href="#6-8-1定义" class="headerlink" title="6.8.1定义"></a>6.8.1定义</h4><p>“对”，实用的小玩意儿，把两个元素绑定成为一个元素——类似于内部有两个元素的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;//可以用utility</span></span></span><br><span class="line">pair&lt;typename1,typename2&gt; name;</span><br></pre></td></tr></table></figure>

<p>初始化方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">1. pair&lt;string,int&gt; p("haha",5);</span><br><span class="line">代码中想临时构建的话---------------------------------</span><br><span class="line"><span class="number">1.</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"haha"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="number">2.</span>make_pair(<span class="string">"haha"</span>,<span class="number">5</span>);<span class="comment">//自带的make_pair函数</span></span><br></pre></td></tr></table></figure>

<h4 id="6-8-2元素访问"><a href="#6-8-2元素访问" class="headerlink" title="6.8.2元素访问"></a>6.8.2元素访问</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.first();            p.second();</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3常用函数-3"><a href="#6-2-3常用函数-3" class="headerlink" title="6.2.3常用函数"></a>6.2.3常用函数</h4><p>compare operator:</p>
<p><font color="red"><strong>==/!=/&lt;/&lt;=/&gt;/&gt;=</strong></font>——————–直接比较first元素，不能比较大小就second</p>
<h4 id="6-2-4常见用途-3"><a href="#6-2-4常见用途-3" class="headerlink" title="6.2.4常见用途"></a>6.2.4常见用途</h4><ol>
<li>代替二元结构体及构造函数；</li>
<li>作为map键值对来给map插入。</li>
</ol>
<h3 id="6-9algorithm头文件下常用函数"><a href="#6-9algorithm头文件下常用函数" class="headerlink" title="6.9algorithm头文件下常用函数"></a>6.9algorithm头文件下常用函数</h3><h4 id="6-9-1max-min-abs"><a href="#6-9-1max-min-abs" class="headerlink" title="6.9.1max() / min() / abs()"></a>6.9.1max() / min() / abs()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="keyword">int</span>/<span class="keyword">double</span> x,<span class="keyword">int</span>/<span class="keyword">double</span> y);<span class="comment">//返回x，y中最大值</span></span><br><span class="line"><span class="built_in">min</span>(<span class="keyword">int</span>/<span class="keyword">double</span> x,<span class="keyword">int</span>/<span class="keyword">double</span> y);<span class="comment">//返回x，y中最小值</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="keyword">int</span> x);<span class="comment">//返回绝对值</span></span><br><span class="line"><span class="comment">//fabs(double x);返回浮点数绝对值，它在math头文件下</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-2swap"><a href="#6-9-2swap" class="headerlink" title="6.9.2swap()"></a>6.9.2swap()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swap(x,y);<span class="comment">//交换</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-3reverse"><a href="#6-9-3reverse" class="headerlink" title="6.9.3reverse()"></a>6.9.3reverse()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reverse(it1,it2);<span class="comment">//将数组指针在[it1,it2)的元素进行反转</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-4next-permutation"><a href="#6-9-4next-permutation" class="headerlink" title="6.9.4next_permutation()"></a>6.9.4next_permutation()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">next_permutation()<span class="comment">//给出一个序列在全排列中的下一个序列</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a,a+<span class="number">3</span>))</span><br><span class="line"><span class="comment">//memset到达全排列最后一个时会返回false，必须得用do while</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-5fill"><a href="#6-9-5fill" class="headerlink" title="6.9.5fill()"></a>6.9.5fill()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>()<span class="comment">//把某段区间赋值为相同的值</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fill</span>(a,a+<span class="number">10</span>,<span class="number">233</span>);<span class="comment">//a[0]~a[4]都赋值为233</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-6sort"><a href="#6-9-6sort" class="headerlink" title="6.9.6sort()"></a>6.9.6sort()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort(首地址，尾地址的下一个地址，cmp比较函数);<span class="comment">//默认递增排序</span></span><br><span class="line">cmp();<span class="comment">//cmp函数定义根据要比较的规则来写</span></span><br><span class="line">注意：容器的比较只涉及<span class="built_in">vector</span>，<span class="built_in">string</span>，<span class="built_in">deque</span>可以使用sort，因为<span class="built_in">set</span>和<span class="built_in">map</span>本身有序（红黑树实现）</span><br></pre></td></tr></table></figure>

<h4 id="6-9-7lower-bound-upper-bound"><a href="#6-9-7lower-bound-upper-bound" class="headerlink" title="6.9.7lower_bound() /  upper_bound()"></a>6.9.7lower_bound() /  upper_bound()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lower_bound(first,last,val);<span class="comment">//范围内大于等于val的第一个值的坐标（指针或者迭代器）</span></span><br><span class="line">upper_bound(first,last,val);<span class="comment">//范围内大于val的第一个值的坐标（指针或者迭代器）</span></span><br></pre></td></tr></table></figure>

<h2 id="第七章-提高：数据结构专题（1）"><a href="#第七章-提高：数据结构专题（1）" class="headerlink" title="第七章 提高：数据结构专题（1）"></a>第七章 提高：数据结构专题（1）</h2><h3 id="7-1栈stack"><a href="#7-1栈stack" class="headerlink" title="7.1栈stack"></a>7.1栈stack</h3><ol>
<li>数组实现栈时，TOP指针int型     2. 链表实现栈时，TOP指针int*型；</li>
<li>TOP指针始终指向栈最上方一个元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后进先出，类似盒子，栈顶指针TOP=-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;Type&gt; s;<span class="comment">//其中Type为数据类型（如 int，float,char等）。</span></span><br><span class="line">s.<span class="built_in">clear</span>();          <span class="comment">//return TOP=-1；  清空栈——注意！STL中没有实现栈的清空，需要自己写</span></span><br><span class="line">s.push(item);       <span class="comment">//st[++TOP]=item;  将item压入栈顶  </span></span><br><span class="line">s.pop();            <span class="comment">//TOP--;           删除栈顶的元素，但不会返回  </span></span><br><span class="line">s.top();            <span class="comment">//return st[TOP];  返回栈顶的元素，但不会删除  </span></span><br><span class="line">s.<span class="built_in">size</span>();           <span class="comment">//return TOP+1;    返回栈中元素的个数  </span></span><br><span class="line">s.empty();          <span class="comment">//if(TOP==-1)&#123;&#125;;   检查栈是否为空，为空返回true，否则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2队列queue"><a href="#7-2队列queue" class="headerlink" title="7.2队列queue"></a>7.2队列queue</h3><ol>
<li>队首指针front——队首元素前一个位置，初始-1</li>
<li>队尾指针rear——队尾元素，初始-1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先进先出，类似排队，队首指针front，队尾指针rear</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;Type&gt; q; <span class="comment">//其中Type为数据类型（如 int，float,char等）</span></span><br><span class="line">q.<span class="built_in">clear</span>();             <span class="comment">//front=clear=-1;    清空栈——注意！STL中没有实现栈的清空，需要自己写</span></span><br><span class="line">q.push(item)           <span class="comment">//q[++rear];         将item压入队列尾部  </span></span><br><span class="line">q.pop()                <span class="comment">//front++;           删除队首元素，但不返回  </span></span><br><span class="line">q.front()              <span class="comment">//q[front+1];        返回队首元素，但不删除  </span></span><br><span class="line">q.back()               <span class="comment">//q[rear];           返回队尾元素，但不删除  </span></span><br><span class="line">q.<span class="built_in">size</span>()               <span class="comment">//return rear-front; 返回队列中元素的个数  </span></span><br><span class="line">q.empty()              <span class="comment">//if(front==rear)&#123;&#125;; 检查队列是否为空，如果为空返回true，否则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3链表"><a href="#7-3链表" class="headerlink" title="7.3链表"></a>7.3链表</h3><h4 id="7-3-1链表概念"><a href="#7-3-1链表概念" class="headerlink" title="7.3.1链表概念"></a>7.3.1链表概念</h4><ul>
<li><p>不连续的由若干个结点连接成的表，每个结点代表一个元素，由数据域和指针域组成</p>
</li>
<li><p>分为有头结点和无头结点，我们一般创建的时有头结点的</p>
</li>
<li><p>头结点的数据域为空，指向的第一个结点保存第一个data</p>
</li>
</ul>
<img src="/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200629032529825.png" alt="image-20200629032529825" style="zoom: 25%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">    node* next;<span class="comment">//指针域</span></span><br><span class="line">&#125;;<span class="comment">//定义结点</span></span><br></pre></td></tr></table></figure>

<h4 id="7-3-2为链表node分配内存空间"><a href="#7-3-2为链表node分配内存空间" class="headerlink" title="7.3.2为链表node分配内存空间"></a>7.3.2为链表node分配内存空间</h4><p>1.new运算符（推荐）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">typename</span>* p=<span class="keyword">new</span> <span class="keyword">typename</span>;</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line">node* p=<span class="keyword">new</span> node;</span><br><span class="line"><span class="comment">//定义后要释放内存，否则可能造成内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span>(p);</span><br></pre></td></tr></table></figure>

<p>2.malloc函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">typename</span>* p=(<span class="keyword">typename</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">typename</span>));</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line">node * p=(node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"><span class="comment">//定义后要释放内存，否则可能造成内存泄漏</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<h4 id="7-3-3链表基本操作"><a href="#7-3-3链表基本操作" class="headerlink" title="7.3.3链表基本操作"></a>7.3.3链表基本操作</h4><ol>
<li>创建链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;//标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//标准库函数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    node *p,*pre,*head;<span class="comment">//p---临时结点，pre----临时结点的前置结点</span></span><br><span class="line">    head=<span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;next=null;</span><br><span class="line">    pre=head;<span class="comment">//把前置结点设置为头结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> node;</span><br><span class="line">        p-&gt;data=a[i];</span><br><span class="line">        p-&gt;next=null;</span><br><span class="line">        pre-&gt;next=p;<span class="comment">//前驱节点的指针域指向p</span></span><br><span class="line">        pre=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回创建完成的头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    node* L=create(a);</span><br><span class="line">    L=L-&gt;next;<span class="comment">//第一个结点才有数据</span></span><br><span class="line">    <span class="keyword">while</span>(L!=null)&#123;<span class="comment">//指针不指向空地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,L-&gt;data);</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">从头结点开始遍历查找就行，代码很简单</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>插入元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *head,<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//把x插入以head为头结点的链表的第pos位置上</span></span><br><span class="line">    node *p=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos<span class="number">-1</span>;i++)&#123;<span class="comment">//只到pos的前一个停下</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node *q=<span class="keyword">new</span> node;<span class="comment">//新建插入结点</span></span><br><span class="line">    q-&gt;data=x;<span class="comment">//数据x</span></span><br><span class="line">    q-&gt;next=p-&gt;next;<span class="comment">//新结点指向插入前原先pos位置的结点</span></span><br><span class="line">    p-&gt;next=q;<span class="comment">//前一个位置的结点指向新结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(node *head,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    node *p=head-&gt;next;</span><br><span class="line">    node *pre=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=null)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line">        pre-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(p);</span><br><span class="line">        p=pre-&gt;next;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-4静态链表"><a href="#7-3-4静态链表" class="headerlink" title="7.3.4静态链表"></a>7.3.4静态链表</h4><p>实现原理是hash，不需要头结点，其他和动态链表差不多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性表的静态链表存储结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">//游标，指向下一个数组下标，类似于指针域</span></span><br><span class="line">&#125;node[<span class="built_in">size</span>]</span><br><span class="line"><span class="comment">//要用到的时候再看细节</span></span><br></pre></td></tr></table></figure>



<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>
]]></content>
      <categories>
        <category>算法基础</category>
        <category>算法笔记1</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Error:Java不支持发行版本5</title>
    <url>/2020/07/08/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/</url>
    <content><![CDATA[<h3 id="Intellij-idea-报错：Error-java-不支持发行版本5，如下所示"><a href="#Intellij-idea-报错：Error-java-不支持发行版本5，如下所示" class="headerlink" title="Intellij idea 报错：Error : java 不支持发行版本5，如下所示"></a>Intellij idea 报错：Error : java 不支持发行版本5，如下所示</h3><p><img src="../images/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/20180904232438840.png" alt="img"></p>
<p> 本地运行用的是JDK9，测试Java的Stream操作，报错应该是项目编译配置使用的Java版本不对，需要检查一下项目及环境使用的Java编译版本配置。</p>
<h3 id="《1》"><a href="#《1》" class="headerlink" title="《1》"></a>《1》</h3><p>在Intellij中点击“File” –&gt;“Project Structure”，看一下“Project”和“Module”栏目中Java版本是否与本地一致：</p>
<p><img src="../images/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/20180904233036107.png" alt="img"></p>
<p><img src="../images/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/20180904233152909.png" alt="img"></p>
<p>如果不一致，改成本地使用的Java版本。</p>
<h3 id="《2》"><a href="#《2》" class="headerlink" title="《2》"></a>《2》</h3><p>点击“Settings”–&gt;“Bulid, Execution,Deployment”–&gt;“Java Compiler”，<strong>Target bytecode version</strong>设为本地Java版本。</p>
<p><img src="../images/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/201809042343056.png" alt="img"></p>
<h3 id="《3》"><a href="#《3》" class="headerlink" title="《3》"></a>《3》</h3><p>点击“Other Setting”–&gt;“Setting for new Project”–&gt;“Java Compiler”，Target bytecode version设为本地Java版本。（可以在Default Settings中把Project bytecode version 一劳永逸地配置成本地Java版本</p>
<p><img src="../images/Error-Java%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC5/image-20200708132242555.png" alt="image-20200708132242555"></p>
<h3 id="三步完成后就不报错啦！"><a href="#三步完成后就不报错啦！" class="headerlink" title="三步完成后就不报错啦！"></a>三步完成后就不报错啦！</h3>]]></content>
      <categories>
        <category>Bug</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/08/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="1、计算准备知识"><a href="#1、计算准备知识" class="headerlink" title="1、计算准备知识"></a>1、计算准备知识</h2><h3 id="等差数列："><a href="#等差数列：" class="headerlink" title="等差数列："></a>等差数列：</h3><p><strong>通项公式</strong></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20200801163028663.png" alt="image-20200801163028663"></p>
<p><strong>求和公式</strong></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20200801163225464.png" alt="image-20200801163225464"></p>
<h3 id="等比数列："><a href="#等比数列：" class="headerlink" title="等比数列："></a>等比数列：</h3><p><strong>通项公式</strong></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1b6ded94ad9a90fad17a2ee8b9c5d071.svg" alt="img"></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/dadfdcdd5bfb3859c3975d404111083c.svg" alt="img"></p>
<p><strong>求和公式</strong></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/0224b1630bb4efb692f7e4cf32902998.svg" alt="img"></p>
<p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/d4f111ae1c48bb57106711c323bdf46d.svg" alt="img"></p>
<h2 id="2、复杂度从大到小排序"><a href="#2、复杂度从大到小排序" class="headerlink" title="2、复杂度从大到小排序"></a>2、复杂度从大到小排序</h2><p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/20130920210031796.png" alt="img"></p>
<p>如图可知， 常见的算法时间复杂度由小到大依次为：</p>
<p><strong>Ο(1)＜Ο(log*2n*)＜Ο(n)＜Ο(nlog*2n*)＜Ο(*n*2)＜Ο(*n*3)＜…＜Ο(*2*n)＜Ο(n!)</strong></p>
<h2 id="3、常用的算法的时间复杂度和空间复杂度"><a href="#3、常用的算法的时间复杂度和空间复杂度" class="headerlink" title="3、常用的算法的时间复杂度和空间复杂度"></a>3、常用的算法的时间复杂度和空间复杂度</h2><p><img src="/../images/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/20130920172327687.png" alt="img"></p>
<p>参考链接：<a href="https://blog.csdn.net/zolalad/article/details/11848739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/zolalad/article/details/11848739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
]]></content>
      <categories>
        <category>基础</category>
        <category>时间复杂度</category>
      </categories>
      <tags>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记2</title>
    <url>/2020/08/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="第八章-提高：搜索专题"><a href="#第八章-提高：搜索专题" class="headerlink" title="第八章 提高：搜索专题"></a>第八章 提高：搜索专题</h2><h3 id="8-1深度优先搜索DFS"><a href="#8-1深度优先搜索DFS" class="headerlink" title="8.1深度优先搜索DFS"></a>8.1深度优先搜索DFS</h3><h4 id="8-1-1DFS概念、思路及实现方法"><a href="#8-1-1DFS概念、思路及实现方法" class="headerlink" title="8.1.1DFS概念、思路及实现方法"></a>8.1.1DFS概念、思路及实现方法</h4><ol>
<li><p>全称：“Depth First Search”</p>
</li>
<li><p>概念：是一种枚举所有路径以遍历所有情况的搜索方法。</p>
</li>
<li><p>思路：类似于走迷宫时，一条路一直往前走，走到死胡同折返到前一个岔路口选另一个结点继续往下走，如此往复知道走出迷宫；</p>
</li>
<li><p>实现方法：递归（在递归时系统调用系统栈存放递归每层的状态，所以本质是用栈实现。）</p>
</li>
</ol>
<h4 id="8-1-2代码格式及举例"><a href="#8-1-2代码格式及举例" class="headerlink" title="8.1.2代码格式及举例"></a>8.1.2代码格式及举例</h4><ol>
<li><p>举例题目：</p>
<p>有n件物品，每件物品重量w[i],价值c[i],选若干个物品放入容量为V的背包，求价值最高的组合,0&lt;n&lt;=30</p>
</li>
<li><p>代码示例</p>
</li>
</ol>
<h4 id="8-1-3相关问题及注意Point"><a href="#8-1-3相关问题及注意Point" class="headerlink" title="8.1.3相关问题及注意Point"></a>8.1.3相关问题及注意Point</h4><ol>
<li><p>相关问题：<strong>和迷宫三个关键点（岔路口—选择，死胡同—掉头边界，出口—最终解决方案）</strong></p>
<p>比如：给定一个序列，枚举这个序列的所有子序列（可以不连续），这个问题也等价于枚举从N个整数中选择K个数的所有方案。</p>
</li>
<li><p>注意：假设每个岔路口（选择点）都可以被选择多次的话，只要根据题目更改代码中选择index号岔路口的部分就行了</p>
</li>
</ol>
<h3 id="8-2广度优先搜索BFS"><a href="#8-2广度优先搜索BFS" class="headerlink" title="8.2广度优先搜索BFS"></a>8.2广度优先搜索BFS</h3><h4 id="8-2-1BFS概念、思路及实现方法"><a href="#8-2-1BFS概念、思路及实现方法" class="headerlink" title="8.2.1BFS概念、思路及实现方法"></a>8.2.1BFS概念、思路及实现方法</h4><ol>
<li><p>全称：“Breadth First Search”</p>
</li>
<li><p>概念：是一种按层次顺序以遍历所有情况的搜索方法。</p>
</li>
<li><p>思路：类似于迷宫时，一条路走到一个岔路口，就把这个岔路口的下一个节点都标记一下，然后再从下一层结点依次这么做，只到找到出口位置。像是石子投入水面，水纹以同心圆方式扩散开来。</p>
</li>
<li><p>实现方法：队列，先进后出</p>
</li>
</ol>
<h4 id="8-2-2代码格式及举例"><a href="#8-2-2代码格式及举例" class="headerlink" title="8.2.2代码格式及举例"></a>8.2.2代码格式及举例</h4><ol>
<li>代码模板：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//取出队首元素top；</span></span><br><span class="line">        <span class="comment">//访问队首元素；</span></span><br><span class="line">       <span class="comment">// 队首元素出队；</span></span><br><span class="line">       <span class="comment">// top下一层结点全部入队；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>举例题目：</li>
</ol>
<p>给出一个矩阵，矩阵元素0/1，称位置（x，y）与其上下左右四个位置是相邻的，若矩阵有若干个相邻的1，称这些1构成了一个块，求这个矩阵有几个块？</p>
<ol start="3">
<li>代码示例</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;<span class="comment">//增量数组</span></span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//竖着看，表示上下左右四个方向</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断（x，y）是否需要访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">    Node.x=x,Node.y=y;</span><br><span class="line">    q.push(Node);</span><br><span class="line">    inq[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        node top=q.front();<span class="comment">//取出队首元素</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//得到4个相邻位置</span></span><br><span class="line">            <span class="keyword">int</span> newx=topx+X[i];</span><br><span class="line">            <span class="keyword">int</span> newy=topy+Y[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(newx,newy))&#123;<span class="comment">//如果新位置需要访问</span></span><br><span class="line">                Node.x=newx,Node.y=newy;</span><br><span class="line">                q.push(Node);</span><br><span class="line">                inq[newx][newy]=<span class="number">1</span>;<span class="comment">//新结点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//读入矩阵</span></span><br><span class="line">    <span class="comment">//枚举位置</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//存放块数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="number">0</span>~n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="number">0</span>~m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果元素为且未入过队</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==<span class="number">1</span>&amp;&amp;inq[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans++;<span class="comment">//块数加一</span></span><br><span class="line">                BFS(x,y);<span class="comment">//访问整个块，该块所有q都标记inq</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3相关问题及注意point"><a href="#8-2-3相关问题及注意point" class="headerlink" title="8.2.3相关问题及注意point"></a>8.2.3相关问题及注意point</h4><ol>
<li><p>相关问题：求最少步数，最小路径，最低耗费时间等等</p>
</li>
<li><p>注意：队列实现时，要注意元素入队的push操作时创建了一个元素二点副本入队，因此对这个元素的修改不会影响本元素，如果题目要求改本身元素时，我们可以换个思路：即，把元素所在的数组下标入队，而不是元素本身。</p>
</li>
</ol>
<h2 id="第九章-提高：-数据结构专题-2"><a href="#第九章-提高：-数据结构专题-2" class="headerlink" title="第九章 提高： 数据结构专题 (2)"></a>第九章 提高： 数据结构专题 (2)</h2><h3 id="9-1树与二叉树"><a href="#9-1树与二叉树" class="headerlink" title="9.1树与二叉树"></a>9.1树与二叉树</h3><h4 id="9-1-1-树的定义与性质"><a href="#9-1-1-树的定义与性质" class="headerlink" title="9.1.1 树的定义与性质"></a>9.1.1 树的定义与性质</h4><ol>
<li>关键名词</li>
</ol>
<table>
<thead>
<tr>
<th>树（tree）</th>
<th>结点（node）</th>
<th>叶子结点（leaf）</th>
<th>根结点（noot）</th>
</tr>
</thead>
<tbody><tr>
<td>边（edge）</td>
<td>子结点（child）</td>
<td>子树（subtree）</td>
<td>空树（empty tree）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>树的层次（layer）</th>
<th>从根结点为第一层开始算，向下逐层加一，以此类推</th>
</tr>
</thead>
<tbody><tr>
<td>结点的度（degree）</td>
<td>结点的子树棵数</td>
</tr>
<tr>
<td>结点深度（depth）</td>
<td>从根节点（深度为1）自顶向下逐层累加</td>
</tr>
<tr>
<td>结点高度（height）</td>
<td>从最底层叶节点（高度为一）自底向上逐层累加</td>
</tr>
<tr>
<td>森林（forest）</td>
<td>若干棵树集合</td>
</tr>
</tbody></table>
<ol start="2">
<li>经常用来作为边界数据的性质：<ul>
<li>树可以没有结点，此时是空树(empty tree)</li>
<li>叶子节点度为0，当树中只有一个结点，root=leaf</li>
</ul>
</li>
</ol>
<h4 id="9-1-2二叉树的递归定义"><a href="#9-1-2二叉树的递归定义" class="headerlink" title="9.1.2二叉树的递归定义"></a>9.1.2二叉树的递归定义</h4><ol>
<li>要么二叉树没有根节点，是空树</li>
<li>要么二叉树由root，左子树、右子树组成，且左子树和右子树都是二叉树</li>
<li>特殊二叉树：<ul>
<li>满二叉树：每层结点个数都达到了当层最大结点数</li>
<li>完全二叉树：只有最底层没达到当层最大结点数,且最底层从左至右连续存在若干结点</li>
</ul>
</li>
<li>几个树的概念</li>
</ol>
<p>孩子节点、父亲结点、兄弟结点</p>
<p>祖先结点(包括父亲结点和自己)、子孙结点(包括孩子结点和自己）</p>
<h4 id="9-1-3二叉树的存储结构与基本操作"><a href="#9-1-3二叉树的存储结构与基本操作" class="headerlink" title="9.1.3二叉树的存储结构与基本操作"></a>9.1.3二叉树的存储结构与基本操作</h4><ol>
<li>二叉树的存储结构：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;      <span class="comment">//数据域</span></span><br><span class="line">    node* lchild;  <span class="comment">//指向左子树</span></span><br><span class="line">    node* rchild;  <span class="comment">//指向右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//建树前一般根结点不存在，所以地址设为null；</span></span><br><span class="line">node* root=null;</span><br></pre></td></tr></table></figure>

<p>二叉树的常用操作有几个，建立/查找/修改/插入/删除——其中删除对不同的二叉树差别比较大，这里就不介绍了；</p>
<ol start="2">
<li>新建结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    node* Node=<span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data=v;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=null;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查找并修改结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//死胡同，空树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)&#123;</span><br><span class="line">        root-&gt;data==newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild,x,newdata);<span class="comment">//往左子树递归</span></span><br><span class="line">    search(root-&gt;rchild,x,newdata);<span class="comment">//往右子树递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>插入节点</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insert函数要注意必须对根节点root使用引用，否则无法插入（对root本身修改）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)&#123;;<span class="comment">//空树，查找失败，插入</span></span><br><span class="line">        root=newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(由于二叉树性质，应该插在left subtree)&#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>二叉树创建</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    node* root=null;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>完全二叉树的存储结构</li>
</ol>
<p>$$<br>可以直接建立一个2^k大小的数组存放完全二叉树，其中k为二叉树的最大高度<br>$$</p>
<p>性质：</p>
<ol>
<li><p>完全二叉树任何一个编号为x的结点，它的左孩子编号一定是2x，右孩子编号一定是2x+1;</p>
</li>
<li><p>此外，该数组存放的顺序恰好为完全二叉树的层序遍历序列。</p>
</li>
<li><p>而判断某个结点是否为叶结点的标志为：该结点的左节点2x大于结点总个数n；</p>
</li>
<li><p>判断某个结点是否为空的标志：该结点下标大于结点总数</p>
</li>
</ol>
<h3 id="9-2二叉树的遍历"><a href="#9-2二叉树的遍历" class="headerlink" title="9.2二叉树的遍历"></a>9.2二叉树的遍历</h3><h4 id="9-2-1先序遍历"><a href="#9-2-1先序遍历" class="headerlink" title="9.2.1先序遍历"></a>9.2.1先序遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根节点——左子树——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最先访问根节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;lchild);</span><br><span class="line">    preOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2中序遍历"><a href="#9-2-2中序遍历" class="headerlink" title="9.2.2中序遍历"></a>9.2.2中序遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左子树——根节点——右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最先访问左子树</span></span><br><span class="line">    inOrder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    inOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3后序遍历"><a href="#9-2-3后序遍历" class="headerlink" title="9.2.3后序遍历"></a>9.2.3后序遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左子树——右子树——根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root-&gt;lchild);</span><br><span class="line">        postOrder(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-4层序遍历"><a href="#9-2-4层序遍历" class="headerlink" title="9.2.4层序遍历"></a>9.2.4层序遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历经常要求计算每个结点所处的层次，因此结构体可以直接添加一个layer变量</span></span><br><span class="line"><span class="comment">//二叉链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    node* lchild;  <span class="comment">//指向左子树</span></span><br><span class="line">    node* rchild;  <span class="comment">//指向右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;*node&gt; q;<span class="comment">//注意这里队列是存地址</span></span><br><span class="line">    root-&gt;layer=<span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        node* now=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);<span class="comment">//访问队首元素</span></span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild!=null)&#123;</span><br><span class="line">            now-&gt;lchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">            q.push(now-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild!=null)&#123;</span><br><span class="line">        now-&gt;rchild-&gt;layer=now-&gt;layer+<span class="number">1</span>;</span><br><span class="line">        q.push(now-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-5给定先序遍历序列和中序遍历序列，重建二叉树例题"><a href="#9-2-5给定先序遍历序列和中序遍历序列，重建二叉树例题" class="headerlink" title="9.2.5给定先序遍历序列和中序遍历序列，重建二叉树例题"></a>9.2.5给定先序遍历序列和中序遍历序列，重建二叉树例题</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FairIzwi-1595856115298)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200630164506472.png)]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前先序序列区间为[preL,preR]， 中序列区间为[inL,inR]，返回根结点地址</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//先序序列长度小于等于0时，直接返回</span></span><br><span class="line">        node* root = <span class="keyword">new</span> node; <span class="comment">//新建 一个新的结点，用来存放当前二又树的根结点</span></span><br><span class="line">        root-&gt;data = pre[preL]; <span class="comment">//新结点的数据域为根结点的值</span></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k = inL; k &lt;= inR; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[k]==pre[preL]) &#123; <span class="comment">//在中序序列中找到in[k] == pre[L]的结点</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> numLeft = k-inL; <span class="comment">//左子树的结点个数</span></span><br><span class="line">            <span class="comment">//左子树的先序区间为[preL+1, preL+numLeft], 中序区间为[inL, k-1]</span></span><br><span class="line">            <span class="comment">//返回左子树的根结点地址，赋值给root的左指针</span></span><br><span class="line">            root-&gt;lchild = create(preL + <span class="number">1</span>, preL + numLeft,inL, k - <span class="number">1</span>) ;</span><br><span class="line">            <span class="comment">//右子树的先序区间为[preL + numLeft + 1, preR], 中序区间为[k+1, inR]</span></span><br><span class="line">           </span><br><span class="line">            <span class="comment">//返回右子树的根结点地址，赋值给root的右指针</span></span><br><span class="line">            root-&gt;rchild = create(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">            <span class="comment">//返回根结点地址</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：只有中序序列可以和其他序列的任意一个来构建唯一的二叉树，其他无论是两两搭配还是三个一起上都不行，因为中序可以区分出左右子树。</strong></p>
<h4 id="9-2-6二叉树的静态实现"><a href="#9-2-6二叉树的静态实现" class="headerlink" title="9.2.6二叉树的静态实现"></a>9.2.6二叉树的静态实现</h4><p>就是把结点的左右指针域改成int型，所有对指针的操作都改为对数组下标的访问，了解一下即可，我还是喜欢指针。</p>
<h3 id="9-3树的遍历"><a href="#9-3树的遍历" class="headerlink" title="9.3树的遍历"></a>9.3树的遍历</h3><h4 id="9-3-1树的静态写法"><a href="#9-3-1树的静态写法" class="headerlink" title="9.3.1树的静态写法"></a>9.3.1树的静态写法</h4><p>一般意义上的树的结点是散乱而没有顺序的，所以我们不使用动态指针而是一个vector数组存放所有字节点的地址——即，考试遇到一般树使用静态写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;<span class="comment">//存放所有子节点的下标</span></span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"><span class="comment">//如果题目不涉及数据，这个结点结构体可以简化为：</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child[maxn];<span class="comment">//即图的邻接表示法在树的应用</span></span><br></pre></td></tr></table></figure>

<p>新建结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].child.<span class="built_in">clear</span>();<span class="comment">//清空子节点</span></span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2树的先根遍历"><a href="#9-3-2树的先根遍历" class="headerlink" title="9.3.2树的先根遍历"></a>9.3.2树的先根遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">        preOrder(Node[root].child[i]);<span class="comment">//递归访问所有子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-3树的层序遍历"><a href="#9-3-3树的层序遍历" class="headerlink" title="9.3.3树的层序遍历"></a>9.3.3树的层序遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历与二叉树的类似</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    NOde[root].layer=<span class="number">0</span>;<span class="comment">//根结点的层号为0（这里看题目吧）</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        <span class="keyword">int</span> front=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[front].data);<span class="comment">//访问队首元素</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[front].child.<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> child=Node[front].child[i];</span><br><span class="line">            Node[child].layer=Node[front].layer+<span class="number">1</span>;</span><br><span class="line">            q.push(child);<span class="comment">//将当前所有子节点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-4从树的遍历看DFS与BFS"><a href="#9-3-4从树的遍历看DFS与BFS" class="headerlink" title="9.3.4从树的遍历看DFS与BFS"></a>9.3.4从树的遍历看DFS与BFS</h4><ul>
<li><p>DFS与先根遍历——————– - 二者问题都可以相互转化。</p>
</li>
<li><p>BFS与层序遍历——————– - 二者问题都可以相互转化。</p>
</li>
</ul>
<h3 id="9-4二叉查找树-BST"><a href="#9-4二叉查找树-BST" class="headerlink" title="9.4二叉查找树(BST)"></a>9.4二叉查找树(BST)</h3><h4 id="9-4-1二叉查找树的定义"><a href="#9-4-1二叉查找树的定义" class="headerlink" title="9.4.1二叉查找树的定义"></a>9.4.1二叉查找树的定义</h4><p>“Binary Search Tree”,又叫二叉排序树、二叉搜索树</p>
<p>递归定义如下：</p>
<p>①要么二叉查找树是- -棵空树。</p>
<p>②要么二叉查找树由根结点、左子树、右子树组成，其中左子树和右子树都是二叉查找树，且左子树上所有结点的数据域&lt;=根结点的数据域，右子树上所有结点的数据域&gt;=根结点的数据域。</p>
<h4 id="9-4-2二叉查找树的基本操作"><a href="#9-4-2二叉查找树的基本操作" class="headerlink" title="9.4.2二叉查找树的基本操作"></a>9.4.2二叉查找树的基本操作</h4><ol>
<li><p>查找操作</p>
<p>①如果当前根结点root为空，说明查找失败，返回。<br>②如果需要查找的值x= root-&gt;data,说明查找成功，访问之。<br>③如果需要查找的值x&lt; root-&gt;data,说明应该往左子树查找，因此向root-&gt;lchild 递归。<br>④说明需要查找的值x&gt; root-&gt;data，则应该往右子树查找，因此向root-&gt;rchild递归。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//search函数查找二又查找树中数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span> <span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123; <span class="comment">//空树，查找失败</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"search failed\n"</span>) ;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == root-&gt;data)&#123; <span class="comment">//查找成功，访问之</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;d\n"</span><span class="string">", root-&gt;data);</span></span><br><span class="line"><span class="string">&#125; else if(x&lt; root-&gt;data) &#123; //如果 x比根结点的数据域小，说明x在左子树</span></span><br><span class="line"><span class="string">search (root-&gt;lchild, x); //往左子树搜索x </span></span><br><span class="line"><span class="string">&#125; else</span></span><br><span class="line"><span class="string">(//如果x比根结点的数据域大，说明x在右子树</span></span><br><span class="line"><span class="string">search (root-&gt;rchild,x);//往右子树搜索x</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insert函数将在二叉树中插入-一个数据域为x的新结点(注意参数root要加引用&amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line">if(root == NULL) [ //空树， 说明查找失败，也即插入位置</span><br><span class="line">root = newNode(x) ;</span><br><span class="line"><span class="comment">//新建结点， 权值为x</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x == root-&gt;data) &#123; <span class="comment">//查找成功， 说明结点已存在，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data)&#123; <span class="comment">//如果x比根结点的数据域小，说明x需要插在左子树</span></span><br><span class="line">insert (root-&gt;lchild, x); <span class="comment">//往左子树搜索 x</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果x比根结点的数据域大，说明x需要插在右子树</span></span><br><span class="line">insert (root-&gt;rchild, x); <span class="comment">//往右子树搜索x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">node* root = <span class="literal">NULL</span>; <span class="comment">// 新建根结点 root</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;<span class="number">1</span>&lt; n; i++) &#123;</span><br><span class="line">insert (root, data[i]);</span><br><span class="line"><span class="comment">//将data[0]~data[n-1]插入二叉查找树中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root; </span><br><span class="line"><span class="comment">//返回根结点</span></span><br><span class="line">&#125;<span class="comment">//和普通二叉树没有什么区别</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除操作</li>
</ol>
<ul>
<li><p><strong>前驱：需要删除的根节点的左子树中的最右结点：即比权值小的最大结点</strong></p>
</li>
<li><p><strong>后继：需要删除的根节点的右子树中的最左结点：即比权值大的最小结点</strong></p>
</li>
<li><p>做删除操作时，用这两种的某一个数据域覆盖根节点，并删除自身。</p>
</li>
</ul>
<p>下面两个函数用来寻找以root为根的树中最大或最小权值结点，用以辅助寻找结点的前驱和后继: .</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (root-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = root-&gt;rchild; <span class="comment">//不断往右， 直到没有右孩子</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找以root为根结点的树中的最小权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span>: </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(root-&gt;lchild!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = root-&gt;lchild;<span class="comment">//不断往左， 直到没有左孩子</span></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除操作的基本思路如下:</strong> </p>
<p>①如果当前结点root为空，说明不存在权值为给定权值x的结点，直接返回。</p>
<p>②如果当前结点root的权值恰为给定的权值x，开始删除<br>a)如果当前结点root不存在左右孩子，说明是叶子结点，直接删除。<br>b)如果当前结点root存在左孩子，那么在左子树中寻找结点前驱pre,然后让pre的数据覆盖root,接着在左子树中删除结点pre。<br>c)如果当前结点root存在右孩子，那么在右子树中寻找结点后继next, 然后让next的数据覆盖root,接着在右子树中删除结点next。</p>
<p>③如果当前结点root的权值大于给定的权值x,则在左子树中递归删除权值为x的结点。</p>
<p>④如果当前结点root的权值大于给定的权值x,则在右子树中递归删除权值为x的结点。<br>删除操作的代码如下(如果需要，可以在删除叶子结点的同时释放它的空间):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node*&amp;root，<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//删除以root为根结点的树中权值为x的结点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//不存在权值为x的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; data == x) &#123; <span class="comment">// 找到欲删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (root -&gt; lchild == <span class="literal">NULL</span> &amp;&amp; root -&gt; rchild == <span class="literal">NULL</span>) &#123; <span class="comment">//叶子结点直接删除</span></span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="comment">//把root地址设为NULL,父结点就引用不到它了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root -&gt; lchild != <span class="literal">NULL</span>) &#123;<span class="comment">//左子树不为空时</span></span><br><span class="line">                node * pre = findMax(root -&gt; lchild); <span class="comment">//找root前驱</span></span><br><span class="line">                root -&gt; data = pre -&gt; data;<span class="comment">//用前驱覆盖root</span></span><br><span class="line">                deleteNode(root -&gt; lchild, pre -&gt; data);<span class="comment">//在左子树中删除结点pre</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右子树不为空时</span></span><br><span class="line">                node * next = findMin(root -&gt; rchild);<span class="comment">// 找root后继</span></span><br><span class="line">                root -&gt; data = next -&gt; data; <span class="comment">//用后继覆盖root</span></span><br><span class="line">                deleteNode(root -&gt; rchild, next -&gt; data); <span class="comment">//在右子树中删除结点next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root -&gt; data &gt; x) &#123;</span><br><span class="line">                deleteNode(root -&gt; lchild, x); <span class="comment">//在左子树中删除x</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deleteNode(root -&gt; rchild, x); <span class="comment">//在右子树中删除x</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个有很多优化方式，只是最初的模板，之后刷leetcode时要注意</p>
<p>但是也要注意，总是优先删除前驱(或者后继)容易导致树的左右子树高度极度不平衡，使得二叉查找树退化成一条链。 解决这一问 题的办法有两种:</p>
<ul>
<li>一种是每次交替删除前驱或后继。</li>
<li>另一种是记录子树高度，总是优先在高度较高的一棵子树里删除结点。</li>
</ul>
<h4 id="9-4-3二叉查找树的性质"><a href="#9-4-3二叉查找树的性质" class="headerlink" title="9.4.3二叉查找树的性质"></a>9.4.3二叉查找树的性质</h4><p><strong>对二叉查找树进行中序遍历，遍历的结果是有序的。</strong></p>
<h3 id="9-5-平衡二叉树-AVL树"><a href="#9-5-平衡二叉树-AVL树" class="headerlink" title="9.5 平衡二叉树(AVL树)"></a>9.5 平衡二叉树(AVL树)</h3><h4 id="9-5-1平衡二叉树的定义"><a href="#9-5-1平衡二叉树的定义" class="headerlink" title="9.5.1平衡二叉树的定义"></a>9.5.1平衡二叉树的定义</h4><p><strong>AVL仍然是一颗平衡二叉树，但他所有结点左右子树的高度之差（平衡因子）的绝对值不超过1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要对每个结点都得到平衡因子，因此需要在树的结构中加入一一个变量height,</span></span><br><span class="line">structnode &#123;</span><br><span class="line">    <span class="keyword">int</span> V, <span class="built_in">height</span>;<span class="comment">//v为结点权值，height 为当前子树高度</span></span><br><span class="line">    node *lchild， *rchild;<span class="comment">//左右孩子结点地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这种定义下，如果需要新建一个结点，就可以采用如下写法:</span></span><br><span class="line"><span class="comment">//生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span> <span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        node*Node=<span class="keyword">new</span> node;</span><br><span class="line">        <span class="comment">//申请一个node型变量的地址空间</span></span><br><span class="line">        Node-&gt;v=v; <span class="comment">//结点权值为v</span></span><br><span class="line">        Node-&gt;<span class="built_in">height</span>=<span class="number">1</span>;<span class="comment">//结点高度初始为1</span></span><br><span class="line">        Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;<span class="comment">//初始状态下没有左右孩子</span></span><br><span class="line">        <span class="keyword">return</span> Node;</span><br><span class="line">        <span class="comment">//返回新建结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取以root为根结点的子树的当前height</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span> <span class="params">(node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;/ /空结点高度为<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;<span class="built_in">height</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算结点 root的平衡因子</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span> <span class="params">(node* root)</span></span>&#123;<span class="comment">//左子树高度减右子树高度</span></span><br><span class="line">        <span class="keyword">return</span> getHeight(root-&gt;<span class="number">1</span>child)一getHeight(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//更新结点root的height</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span> <span class="params">(node* root)</span></span>&#123;<span class="comment">//max(左孩子的height,右孩子的height)+1</span></span><br><span class="line">        root-&gt;<span class="built_in">height</span>.=<span class="built_in">max</span>(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-5-2平衡二义树的基本操作"><a href="#9-5-2平衡二义树的基本操作" class="headerlink" title="9.5.2平衡二义树的基本操作"></a>9.5.2平衡二义树的基本操作</h4><p><strong>包括插入、查找及建立，删除太复杂暂时不说</strong></p>
<ol>
<li>查找、建立和二叉树没区别</li>
</ol>
<ul>
<li>首先介绍一下左旋和右旋的概念</li>
</ul>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kltxjrLA-1595856115301)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200703203200793.png)]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋(Left Rotation)</span></span><br><span class="line"><span class="comment">/*1.让A的右子树◆成为B的左子树。</span></span><br><span class="line"><span class="comment">  2.让B成为A的右子树。</span></span><br><span class="line"><span class="comment">  3.将根结点设定为结点A。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">        node*temp=root-&gt;rchild;<span class="comment">//root指向结点A, temp 指向结点B</span></span><br><span class="line">        root-&gt;rchild=temp-&gt;lchild;<span class="comment">//步骤1</span></span><br><span class="line">        temp-&gt;lchild=root;<span class="comment">//步骤2</span></span><br><span class="line">        updateHeight(root);<span class="comment">//更新结点A的高度</span></span><br><span class="line">        updateHeight(temp);<span class="comment">//更新结点B的高度</span></span><br><span class="line">        root=temp;s <span class="comment">//步骤3</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CBkojdN9-1595856115303)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200703203551838.png)]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右旋(Right Rotation)</span></span><br><span class="line"><span class="comment">/*①让A的右子树◆成为B的左子树。</span></span><br><span class="line"><span class="comment">②让B成为A的右子树。</span></span><br><span class="line"><span class="comment">③将根结点设定为结点A。*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span> <span class="params">(node* &amp;root)</span></span>&#123;</span><br><span class="line">        node*temp=root-&gt;lchild; <span class="comment">//root 指向结点B，temp 指向结点A</span></span><br><span class="line">        root-&gt;lchild=temp-&gt;rchild;<span class="comment">//步骤1</span></span><br><span class="line">        temp-&gt;rchild二root;<span class="comment">//步骤2</span></span><br><span class="line">        updateHeight(root);<span class="comment">//更新结点B的高度</span></span><br><span class="line">        updateHeight(temp);</span><br><span class="line"><span class="comment">//更新结点A的高度</span></span><br><span class="line">        root=temp;<span class="comment">//步骤3</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>平衡二叉树的插入操作可能导致树的平衡因子失衡（&gt;=2）</strong></li>
</ul>
<p><strong>可以证明，只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡。</strong></p>
<ul>
<li><strong>失衡情况：LL，LR，RR，RL</strong></li>
</ul>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-85tqQPU0-1595856115305)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200703204207856.png)]</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1rtAUw7t-1595856115307)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200703204222130.png)]</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gbwgjaBt-1595856115308)(/../images/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20200703204252883.png)]</p>
<p>由于我们需要从插入的结点开始从下往上判断结点是否失衡，因此需要在每个insert函数之后更新当前子树的高度，并在这之后根据树型是LL型、LR型、RR型、RL型之一来进行平衡操作，代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入权值为v的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root = <span class="literal">NULL</span>)&#123; <span class="comment">//到达空结点</span></span><br><span class="line">        root=newNode(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(v&lt;root-&gt;v) &#123; <span class="comment">//v 比根结点的权值小</span></span><br><span class="line">        insert(root-&gt;lchild, v); <span class="comment">//往左子树插入</span></span><br><span class="line">        updateHeight(root); <span class="comment">//更新树高</span></span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root)== <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBalanceFactor (root-&gt;lchild)==<span class="number">1</span>) &#123;<span class="comment">//LL型</span></span><br><span class="line">              R(root) ;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor (root-&gt;lchild) == <span class="number">-1</span>) &#123;<span class="comment">//LR型</span></span><br><span class="line">                 L(root-&gt;lchi1d);</span><br><span class="line">                 R(root) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> (<span class="comment">//v比根结点的权值大</span></span><br><span class="line">        insert (root-&gt;rchild, v);<span class="comment">//往右子树插入</span></span><br><span class="line">        updateHeight (root);<span class="comment">//更新树高</span></span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor (root)==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor (root-&gt;rchild) = <span class="number">-1</span>) ( <span class="comment">//RR型</span></span><br><span class="line">        L(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getBalanceFactor (root-&gt;rchild) == <span class="number">1</span>)&#123; <span class="comment">//RL型</span></span><br><span class="line">        R(root-&gt;rchild);</span><br><span class="line">        L(root);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="9-6并查集"><a href="#9-6并查集" class="headerlink" title="9.6并查集"></a>9.6并查集</h3><h4 id="9-6-1并查集的定义"><a href="#9-6-1并查集的定义" class="headerlink" title="9.6.1并查集的定义"></a>9.6.1并查集的定义</h4><ol>
<li><p><strong>并查集是一种维护集合的数据结构，它的名字中“并”“查”“集”分别取自Union (合并)、Find (查找)、Set (集合)这3个单词。也就是说，并查集支持下面两个操作:</strong><br><strong>①合并:合并两个集合。</strong><br><strong>②查找:判断两个元素是否在一个集合。</strong></p>
</li>
<li><p><strong>实现方式：int father[N];</strong></p>
</li>
<li><p><strong>其中，fahter[i]表示元素i的父亲结点，而父亲结点本身也是这个集合内的元素(1≤i≤N)。例如father[1] = 2就表示元素1的父亲结点是元素2，以这种父系关系来表示元素所属的集合。</strong></p>
<p><strong>另外，如果father[i]=i,则说明元素i是该集合的根结点，但对同一个集合来说只存在-一个根结点，且将其作为所属集合的标识。</strong></p>
</li>
<li><p><strong>并查集产生的每一个集合都是一棵树</strong></p>
</li>
</ol>
<h4 id="9-6-2并查集的基本操作"><a href="#9-6-2并查集的基本操作" class="headerlink" title="9.6.2并查集的基本操作"></a>9.6.2并查集的基本操作</h4><ol>
<li>初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    father[i]=i;<span class="comment">//每个元素初始都是一个独立的集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找(根节点)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=father(x))&#123;</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>合并</li>
</ol>
<ul>
<li><p>先判断两个集合是否属于同一个集合</p>
</li>
<li><p>合并两个集合</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA=findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB=findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA!=faB)&#123;</span><br><span class="line">        father[faA]=faB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-3路径压缩-查找递归优化"><a href="#9-6-3路径压缩-查找递归优化" class="headerlink" title="9.6.3路径压缩(查找递归优化)"></a>9.6.3路径压缩(查找递归优化)</h4><p>上面讲的查找函数没有优化，如果查找时把当前结点路径上的所有结点的父亲都指向根结点，那之后查找就不用一直回溯了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==father(a)) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> F=findFather(father(a));</span><br><span class="line">        father(a)=F;</span><br><span class="line">        <span class="keyword">return</span> F;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-7堆"><a href="#9-7堆" class="headerlink" title="9.7堆"></a>9.7堆</h3><h4 id="9-7-1堆的定义"><a href="#9-7-1堆的定义" class="headerlink" title="9.7.1堆的定义"></a>9.7.1堆的定义</h4><p><strong>堆是一棵完全二叉树，树中每个节点都不小于或不大于其左右孩子，根据每个结点的父亲结点是大还是小分为大顶堆和小顶堆。</strong></p>
<p>所以和完全二叉树一样用数组存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;<span class="comment">//10为堆元素个数</span></span><br></pre></td></tr></table></figure>

<h4 id="9-7-2堆的基本操作"><a href="#9-7-2堆的基本操作" class="headerlink" title="9.7.2堆的基本操作"></a>9.7.2堆的基本操作</h4><ol>
<li>向下调整：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//heap数组在[low,high]范围向下调整</span></span><br><span class="line"><span class="comment">//low为需要调整的数组下标，high为最后一个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;<span class="comment">//j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;<span class="comment">//存在孩子结点</span></span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high&amp;&amp;heap[j+<span class="number">1</span>]&gt;heap[j])&#123;</span><br><span class="line">            j=j+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])&#123;<span class="comment">//孩子比父亲大就换</span></span><br><span class="line">            swap(heap[i],heap[j]);</span><br><span class="line">            i=j;<span class="comment">//保持i=欲调整结点</span></span><br><span class="line">            j=i*<span class="number">2</span>;<span class="comment">//孩子也保持</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建堆</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除堆顶元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>]=heap[n--];<span class="comment">//用最后一个元素覆盖堆顶然后向下调整</span></span><br><span class="line">    downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向上调整，low一般设为1，high是需要调整的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;<span class="comment">//和父亲比较</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])&#123;<span class="comment">//和父亲比较</span></span><br><span class="line">            swap(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++n]=x;</span><br><span class="line">    upAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-7-3堆排序"><a href="#9-7-3堆排序" class="headerlink" title="9.7.3堆排序"></a>9.7.3堆排序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        downHeap(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//原理挺长的不写了，去看书P341</span></span><br></pre></td></tr></table></figure>

<h3 id="9-8哈夫曼树"><a href="#9-8哈夫曼树" class="headerlink" title="9.8哈夫曼树"></a>9.8哈夫曼树</h3><h4 id="9-8-1哈夫曼树"><a href="#9-8-1哈夫曼树" class="headerlink" title="9.8.1哈夫曼树"></a>9.8.1哈夫曼树</h4><p>构建思想：反复选择两个最小的元素合并，直到只剩下最后一个元素</p>
<p>以合并果子为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先队列实现</span></span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt;,greater&lt;<span class="keyword">long</span>,<span class="keyword">long</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="comment">//将初始重量压入优先队列</span></span><br><span class="line">        q.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)<span class="comment">//至少得有俩才能合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        x=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        y=q.top();</span><br><span class="line">        q.pop(); </span><br><span class="line">        q.push(x+y);</span><br><span class="line">        ans+=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-8-2哈弗曼编码"><a href="#9-8-2哈弗曼编码" class="headerlink" title="9.8.2哈弗曼编码"></a>9.8.2哈弗曼编码</h4><p><strong>即令任何一个叶子结点（字符），其编码一定不会成为其他任何一个结点（字符）编码的前缀，满足这种编码方式的编码成为前缀编码</strong></p>
<p><strong>前缀编码的存在意义在于不产生混淆，使解码正常进行。</strong></p>
<p><strong>哈夫曼编码是能使给定字符串编码成01串后长度最短的前缀编码。</strong></p>
<h2 id="第十章-提高-图算法专题"><a href="#第十章-提高-图算法专题" class="headerlink" title="第十章 提高: 图算法专题."></a>第十章 提高: 图算法专题.</h2><h3 id="10-1图的定义和相关"><a href="#10-1图的定义和相关" class="headerlink" title="10.1图的定义和相关"></a>10.1图的定义和相关</h3><p>由顶点Vertex和边Edge组成</p>
<table>
<thead>
<tr>
<th>name</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>有向图</td>
<td>所有边都有单个方向</td>
</tr>
<tr>
<td>无向图</td>
<td>所有边都是双向的</td>
</tr>
<tr>
<td>顶点的度</td>
<td>和该顶点相连的边数（分为入度和出度）</td>
</tr>
<tr>
<td>权值</td>
<td>（点权和边权）代表某个属性</td>
</tr>
</tbody></table>
<h3 id="10-2图的存储"><a href="#10-2图的存储" class="headerlink" title="10.2图的存储"></a>10.2图的存储</h3><h4 id="10-2-1邻接矩阵"><a href="#10-2-1邻接矩阵" class="headerlink" title="10.2.1邻接矩阵"></a>10.2.1邻接矩阵</h4><p><strong>——————二维数组，顶点数目比较少时用这个</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//G[i][j]=1表示顶点i，j之间有边，G[i][j]=0表示顶点i，j之间无边</span></span><br></pre></td></tr></table></figure>

<h4 id="10-2-2邻接表"><a href="#10-2-2邻接表" class="headerlink" title="10.2.2邻接表"></a>10.2.2邻接表</h4><p><strong>——————链表或者vector，顶点数目比较多时用这个</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Adj[i][0]表示当前访问的顶点标号为i，int v=Adj[i][0].v(得到可以到达的顶点标号)</span></span><br><span class="line">Struct Node&#123;</span><br><span class="line"><span class="keyword">int</span> v;<span class="comment">//边编号</span></span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//边权</span></span><br><span class="line">Node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w):v(_v),w(_w)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br><span class="line">Adj[<span class="number">1</span>].push_back(Node(<span class="number">3</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h3 id="10-3图的遍历"><a href="#10-3图的遍历" class="headerlink" title="10.3图的遍历"></a>10.3图的遍历</h3><h4 id="10-3-1采用深度优先搜索-DFS-法遍历图"><a href="#10-3-1采用深度优先搜索-DFS-法遍历图" class="headerlink" title="10.3.1采用深度优先搜索(DFS)法遍历图"></a>10.3.1采用深度优先搜索(DFS)法遍历图</h4><table>
<thead>
<tr>
<th>连通分量</th>
<th>无向图：两顶点可以相互到达，就称为连通；如果图任意两个顶点都联通，就称图为连通图；否则，称非连通图中的极大连通子图为连通分量</th>
</tr>
</thead>
<tbody><tr>
<td>强连通分量</td>
<td>有向图：两顶点可以各自相互到达，就称为强连通；如果图任意两个顶点都联通，就称图为强连通图；否则，称非强连通图中的极大强连通子图为强连通分量</td>
</tr>
</tbody></table>
<ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DFS(u)&#123;<span class="comment">//访问顶点u</span></span><br><span class="line">    vis[u]=<span class="literal">true</span>;<span class="comment">//设置已被访问</span></span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==flase)&#123;</span><br><span class="line">            DFS(v);<span class="comment">//递归访问v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis(u)==flase)</span><br><span class="line">            DFS(u);<span class="comment">//访问u所在的连通块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>邻接矩阵版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span><span class="comment">//INF设为一个很大的树</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已被访问，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;<span class="comment">//对所有顶点遍历一遍</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==flase&amp;&amp;G[u][v]==<span class="number">1</span>)&#123;<span class="comment">//如果未被访问且u可以到达v</span></span><br><span class="line">            DFS(v,depth+<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span></span>&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">            DFS(u,<span class="number">1</span>)<span class="comment">//访问u所在的连通块,1表示初始为第一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>邻接表版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"></span><br><span class="line">vectos&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已被访问，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;v&lt;Adj[u].<span class="built_in">size</span>;i++)&#123;<span class="comment">//对所有顶点遍历一遍</span></span><br><span class="line">        <span class="keyword">int</span> v=Adj[u][i];<span class="comment">//u可以到达v</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]==flase)&#123;<span class="comment">//如果未被访问</span></span><br><span class="line">            DFS(v,depth+<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span></span>&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">            DFS(u,<span class="number">1</span>)<span class="comment">//访问u所在的连通块,1表示初始为第一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-3-2采用广度优先搜索-BFS-法遍历图"><a href="#10-3-2采用广度优先搜索-BFS-法遍历图" class="headerlink" title="10.3.2采用广度优先搜索(BFS) 法遍历图"></a>10.3.2采用广度优先搜索(BFS) 法遍历图</h4><ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BFS(u)&#123;<span class="comment">//访问顶点u</span></span><br><span class="line">    <span class="built_in">queue</span> q;<span class="comment">//定义队列q</span></span><br><span class="line">    inq[u]==<span class="literal">true</span>;<span class="comment">//将顶点u入队</span></span><br><span class="line">    <span class="keyword">while</span>(q非空)&#123;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">             <span class="keyword">if</span>(inq[v]==flase)&#123;<span class="comment">//如果v没有入过队，将v入队</span></span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis(u)==flase)</span><br><span class="line">            BFS(u);<span class="comment">//访问u所在的连通块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>邻接矩阵版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> inq[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已入队，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//定义队列q</span></span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(inq[v]==flase&amp;&amp;G[u][v]==<span class="number">1</span>)&#123;<span class="comment">//如果v没有入过队且v是u的临接点，将v入队</span></span><br><span class="line">                 q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;++u)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inq(u)==flase)<span class="comment">//u没入过队</span></span><br><span class="line">            BFS(u);<span class="comment">//访问u所在的连通块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>邻接表版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"></span><br><span class="line">vectos&lt;<span class="keyword">int</span>&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已被访问，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//定义队列q</span></span><br><span class="line">    q.push(u);</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[u].<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][i];</span><br><span class="line">             <span class="keyword">if</span>(inq[v]==flase)&#123;<span class="comment">//如果v没有入过队且v是u的临接点，将v入队</span></span><br><span class="line">                 q.push(v);</span><br><span class="line">                inq[v]=<span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span></span>&#123;<span class="comment">//遍历图G</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">            DFS(u)<span class="comment">//访问u所在的连通块,1表示初始为第一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要求层号就用结构体，加点代码就行</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4最短路径"><a href="#10-4最短路径" class="headerlink" title="10.4最短路径"></a>10.4最短路径</h3><h4 id="10-4-1-Dijkstra-算法"><a href="#10-4-1-Dijkstra-算法" class="headerlink" title="10.4.1 Dijkstra 算法"></a>10.4.1 Dijkstra 算法</h4><ol>
<li><p>作用:解决单源最短路径问题(边权均为非负数)</p>
</li>
<li><p>伪代码</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line">Dijkstra(G,d[],s)&#123;</span><br><span class="line">    初始化；</span><br><span class="line">    <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">        <span class="keyword">for</span>()&#123;</span><br><span class="line">            u=使d[u]最小的还未访问的顶点;</span><br><span class="line">        &#125;</span><br><span class="line">        标记u被访问;</span><br><span class="line">        <span class="keyword">for</span>(u出发可以访问的所有顶点v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问&amp;&amp;以u到达v的路径可以使d[v]更优)</span><br><span class="line">                优化d[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>邻接矩阵版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;<span class="comment">//INF为一个很大的数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已入队，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化；</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+MAXV,INF);<span class="comment">//fill给整个d数组复制，慎用memset数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点s到达自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;<span class="comment">//u使d[u]最小，MIN存最小d[u]值；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//循环n次找到未访问的顶点;</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==flase&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;<span class="comment">//u=使d[u]最小的还未访问的顶点;</span></span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不流通；</span></span><br><span class="line">        vis[u]=<span class="literal">true</span>;<span class="comment">// 标记u被访问;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==flase&amp;&amp;G[u][v]!=INF&amp;&amp;d[u]+G[u][v]&lt;d[v])</span><br><span class="line">                d[v]=d[u]+G[u][v];<span class="comment">//优化d[v];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>邻接表版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;<span class="comment">//v=目标顶点；dis=边权</span></span><br><span class="line">&#125;</span><br><span class="line">vectos&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已被访问，就是true</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化；</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+MAXV,INF);<span class="comment">//fill给整个d数组复制，慎用memset数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点s到达自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;<span class="comment">//u使d[u]最小，MIN存最小d[u]值；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//循环n次找到未访问的顶点;</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==flase&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;<span class="comment">//u=使d[u]最小的还未访问的顶点;</span></span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不流通；</span></span><br><span class="line">        vis[u]==<span class="literal">true</span>;<span class="comment">// 标记u被访问;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==flase&amp;&amp;d[u]+Adj[u][j].dis&lt;d[v])</span><br><span class="line">                d[v]=d[u]+Adj[u][j].dis;<span class="comment">//优化d[v];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>题目变化：<ol>
<li>得到全路径——&gt;设pre[MAXV]存放前驱节点，递归输出</li>
<li>第二标尺——&gt;新增点权//新增边权//求最短路径条数</li>
</ol>
</li>
</ol>
<h4 id="10-4-2-Bellman-Ford-算法和SPFA算法"><a href="#10-4-2-Bellman-Ford-算法和SPFA算法" class="headerlink" title="10.4.2 Bellman-Ford 算法和SPFA算法"></a>10.4.2 Bellman-Ford 算法和SPFA算法</h4><p><strong>——解决单源路径最短且有负边权</strong></p>
<p>还没看懂原理，之后刷到这种题就重新回P393看一遍</p>
<h4 id="10-4-3-Floyd-算法"><a href="#10-4-3-Floyd-算法" class="headerlink" title="10.4.3 Floyd 算法"></a>10.4.3 Floyd 算法</h4><p><strong>——全源最短路径,即找到任意两点之间最短的路径</strong></p>
<ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">枚举顶点k属于[<span class="number">1</span>,n]</span><br><span class="line">    以顶点k作为中介点，枚举所有顶点对i和j（i属于[<span class="number">1</span>,n],j属于[<span class="number">1</span>,n]</span><br><span class="line">       如果dis[i][k]+dis[k][j]&lt;dis[i][j]成立</span><br><span class="line">           赋值dis[i][j]=dis[i][k]+dis[k][j]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j]</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-5最小生成树"><a href="#10-5最小生成树" class="headerlink" title="10.5最小生成树"></a>10.5最小生成树</h3><h4 id="10-5-1最小生成树及其性质"><a href="#10-5-1最小生成树及其性质" class="headerlink" title="10.5.1最小生成树及其性质."></a>10.5.1最小生成树及其性质.</h4><p>最小生成树拥有无向图的所有顶点且满足整棵树的边权之和最小</p>
<p>下面两种算法都采用了贪心法，只是贪心的策略不太一样;</p>
<p><strong>稠密图（边多）用prim算法；稀疏图（边少）用krustal算法</strong></p>
<h4 id="10-5-2-prim-算法"><a href="#10-5-2-prim-算法" class="headerlink" title="10.5.2 prim 算法"></a>10.5.2 prim 算法</h4><p>——解决最小生成树问题</p>
<p>思想和Dijkstra几乎完全相同，区别仅在于d[]的含义不同//ans记录了最小生成树的总路径</p>
<ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line">Prim(G,d[])&#123;</span><br><span class="line">    初始化；</span><br><span class="line">    <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">        <span class="keyword">for</span>()&#123;</span><br><span class="line">            u=使d[u]最小的还未访问的顶点;</span><br><span class="line">        &#125;</span><br><span class="line">        标记u被访问;</span><br><span class="line">        <span class="keyword">for</span>(u出发可以访问的所有顶点v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问&amp;&amp;以u为中介点使得v与集合S的最短路径可以使d[v]更优)</span><br><span class="line">                将G[u][v]赋值给v与集合S的最短路径d[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>邻接矩阵版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;<span class="comment">//INF为一个很大的数</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> n,G[MAXV][MAXV];<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];<span class="comment">//顶点与集合的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已访问，就是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化；</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+MAXV,INF);<span class="comment">//fill给整个d数组复制，慎用memset数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点s到达集合S的距离为0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//存放最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;<span class="comment">//u使d[u]最小，MIN存最小d[u]值；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//循环n次找到未访问的顶点;</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==flase&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;<span class="comment">//u=使d[u]最小的还未访问的顶点;</span></span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不流通；</span></span><br><span class="line">        vis[u]=<span class="literal">true</span>;<span class="comment">// 标记u被访问;</span></span><br><span class="line">        ans+=d[u];<span class="comment">//将于集合S距离最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==flase&amp;&amp;G[u][v]!=INF&amp;&amp;G[u][v]&lt;d[v])</span><br><span class="line">                d[v]=G[u][v];<span class="comment">//优化d[v];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>邻接表版</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;<span class="comment">//最大顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;<span class="comment">//v=目标顶点；dis=边权</span></span><br><span class="line">&#125;</span><br><span class="line">vectos&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n<span class="comment">//n为顶点数</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//如果顶点已被访问，就是true</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">//G为图，一般设置成全局变量；数组d为源点到达各点最短路径长度；s为起点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化；</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+MAXV,INF);<span class="comment">//fill给整个d数组复制，慎用memset数组</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点s到达集合S的距离为0</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//存放最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;<span class="comment">//u使d[u]最小，MIN存最小d[u]值；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//循环n次找到未访问的顶点;</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==flase&amp;&amp;d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;<span class="comment">//u=使d[u]最小的还未访问的顶点;</span></span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//找不到小于INF的d[u],说明剩下的顶点和起点s不流通；</span></span><br><span class="line">        vis[u]=<span class="literal">true</span>;<span class="comment">// 标记u被访问;</span></span><br><span class="line">        ans+=d[u];<span class="comment">//将于集合S距离最小的边加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;v++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==flase&amp;&amp;Adj[u][j].dis&lt;d[v])</span><br><span class="line">                d[v]=Adj[u][j].dis;<span class="comment">//优化d[v];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-5-3-kruskal-算法"><a href="#10-5-3-kruskal-算法" class="headerlink" title="10.5.3 kruskal 算法"></a>10.5.3 kruskal 算法</h4><ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans，最小生成树的当前边数Num_Edge</span><br><span class="line">    将所有边按边权从大到小排序；</span><br><span class="line">        <span class="keyword">for</span>(从大到小枚举所有边)&#123;</span><br><span class="line">            <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)&#123;</span><br><span class="line">                将该测试边加入最小生成树中；</span><br><span class="line">                    ans+=测试边的边权；</span><br><span class="line">                    最小生成树的当前边数Num_Edge+<span class="number">1</span>；</span><br><span class="line">                    当Num_Edge=顶点数<span class="number">-1</span>时结束循环；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">判断两个端点是否在一个连通块中的方法是使用并查集</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;<span class="comment">//边的两个端点</span></span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//边权</span></span><br><span class="line">&#125;E[MAXE];<span class="comment">//最多MAXE条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,rdge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost&lt;b.cost;<span class="comment">//从小到大对边权排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[N];<span class="comment">//并查集数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//并查集查询函数</span></span><br><span class="line">    <span class="keyword">while</span>(x!=father(x))&#123;</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//krustal函数返回最小生成树的边权之和，参数n为顶点个数，m为图的边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">krustal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//令最小生成树的边权之和为ans，最小生成树的当前边数Num_Edge</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,Num_edg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        father[i]=i;<span class="comment">//并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(E,E+m,cmp);<span class="comment">//对边排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//枚举所有边</span></span><br><span class="line">        <span class="keyword">int</span> faU=findFather(E[i].u);</span><br><span class="line">        <span class="keyword">int</span> faV=findFather(E[i].v);</span><br><span class="line">        <span class="keyword">if</span>(faU!=faV)&#123;</span><br><span class="line">            father[faU]=faV;<span class="comment">//合并集合</span></span><br><span class="line">            ans+=E[i].cost;</span><br><span class="line">            Num_edge++;</span><br><span class="line">            <span class="keyword">if</span>(Num_edge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Num_edge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//最终也无法联通就返回-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-6拓扑排序"><a href="#10-6拓扑排序" class="headerlink" title="10.6拓扑排序"></a>10.6拓扑排序</h3><h4 id="10-6-1有向无环图DAG"><a href="#10-6-1有向无环图DAG" class="headerlink" title="10.6.1有向无环图DAG"></a>10.6.1有向无环图DAG</h4><p><strong>如果一个有向图的任意顶点都无法通过一些有向边回到自身，这个图被称为有向无环图DAG</strong></p>
<h4 id="10-6-2拓扑排序"><a href="#10-6-2拓扑排序" class="headerlink" title="10.6.2拓扑排序"></a>10.6.2拓扑排序</h4><p>拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得图G中的任意两个点u，v，如果存在边u-&gt;v,那么在序列中u一定在v的前面。这个序列就叫做拓扑序列。</p>
<ol>
<li>伪代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、定义队列q，所有入度为<span class="number">0</span>的顶点加入队列；</span><br><span class="line"><span class="number">2</span>、输出队首结点，删除所有由它出发的边，并且令对应的顶点入度减一，如果这是某个顶点入度=<span class="number">0</span>，就将此顶点加入队列；</span><br><span class="line"><span class="number">3</span>、反复<span class="number">2</span>操作，直到队列为空，此时如果入过队的结点刚好=N，则拓扑排序成功，图是DAG，否则说明存在闭环</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现代码（邻接表）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录加入拓扑排序的顶点数</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.push(i);<span class="comment">//所有入度为0的顶点加入队列；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].v;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>();<span class="comment">//清空u的所有出边（不必要可以不写）</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>ps</strong>:如果要求有多个入度为0的顶点，选择编号最小的顶点，那么把queue改成priority_queue，并保持队首元素是优先队列最小的元素即可。（遇到具体的问题再说吧）</li>
</ol>
<h3 id="10-7关键路径"><a href="#10-7关键路径" class="headerlink" title="10.7关键路径"></a>10.7关键路径</h3><h4 id="10-7-1-AOV网和AOE网"><a href="#10-7-1-AOV网和AOE网" class="headerlink" title="10.7.1 AOV网和AOE网"></a>10.7.1 AOV网和AOE网</h4><table>
<thead>
<tr>
<th>AOV网</th>
<th align="left">Acticity On Vertex——顶点表示活动，而用边集表示活动间优先关系的有向图；</th>
</tr>
</thead>
<tbody><tr>
<td>AOE网</td>
<td align="left">Activity On Edge——带圈的边集表示活动，顶点表示事件的有向图；</td>
</tr>
<tr>
<td>源点</td>
<td align="left">入度为0的点（或者创建一个新点连接所有入度为0的点）</td>
</tr>
<tr>
<td>汇点</td>
<td align="left">出度为0的点（或者创建一个新点连接所有出度为0的点）</td>
</tr>
</tbody></table>
<p><strong>AOE网的最长路径就是关键路径，关键路径上的活动称为关键活动，所需时间就是最短时间</strong></p>
<p><strong>AOV转换为AOE的方法就是拆解顶点，边视为空活动。</strong></p>
<h4 id="10-7-2最长路径"><a href="#10-7-2最长路径" class="headerlink" title="10.7.2最长路径"></a>10.7.2最长路径</h4><p>对于一个没有正环的图，求最长路径，就所有边乘以-1再用Bellman-Ford算法或者SPFA算法求最短路径再取反。</p>
<h4 id="10-7-3关键路径"><a href="#10-7-3关键路径" class="headerlink" title="10.7.3关键路径"></a>10.7.3关键路径</h4><p><strong>AOE是有向无环图，所以这里的方法实际上是求解有向无环图DAG中最长路径的方法。</strong></p>
<p>如下——活动示意图：<br>$$<br>事件V_i—————–活动a_r——————–事件V_j<br>$$<br>由于关键活动是那些不允许拖延的活动，因此这些活动的最早开始时间必须等于最迟开始时间。因此可以设置数组e和l，其中e[r]和l[r]分别表示活动a_r的最早开始时间和最迟开始时间。于是，当我们求出这两个数组之后，就可以通过判断e[r]==l[r]是否成立来确定活动r是否是关键活动。</p>
<p>那么，如何求解数组e和l？</p>
<p>我们看上面的活动示意图可以知道——</p>
<p><strong>事件最早发生时间==旧活动的最早结束时间，事件的最迟发生时间==新活动的最迟开始时间。？（事件的最迟发生时间==旧活动的最迟结束时间。）</strong>所以，可以再设置数组ve[i],vl[i]分别表示事件i的最早发生时间和最晚发生时间，然后我们就可以根据下面的公式转换得出e[r]和l[r]了。</p>
<p>ps：事件可以拖延，所以没有结束时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、事件Vi最早发生时间=新活动a_r最早开始时间</span><br><span class="line">e[r]=ve[i];</span><br><span class="line"><span class="number">2</span>、事件Vj最晚发生时间-length[r]=活动a_r最晚开始时间</span><br><span class="line">l[r]=vl[j]-length[r];</span><br><span class="line"><span class="number">3</span>、假设已知k个事件V_i1~~V_ik的最早发生时间,要求事件V_j的最早发生时间，此时由于只有所有事件都到达后，事件j才能开始，所以取最大值</span><br><span class="line">ve[j]=<span class="built_in">max</span>&#123;ve[ip]+length[rp]&#125;</span><br><span class="line"><span class="number">4</span>、假设已知k个事件V_j1~~V_jk的最晚发生时间,要求事件V_i的最晚发生时间，此时由于必须保证所有后续结点的最晚到达时间都能被满足，所以取最小值</span><br><span class="line">vl[i]=<span class="built_in">min</span>&#123;vl[jp]-length[rp]&#125;</span><br><span class="line"><span class="number">5</span>、用上面的结果计算各边的结果</span><br><span class="line">最早：e[i-&gt;j]=ve[i]</span><br><span class="line">最晚：l[i-&gt;j]=vl[j]-length[i-&gt;j]</span><br></pre></td></tr></table></figure>

<p><strong>主题代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">已知所有前驱结点的ve，求结点的ve：-------------------------------------------------------------</span><br><span class="line"><span class="keyword">int</span> n,m,inDegree[MAXV];</span><br><span class="line"><span class="comment">//拓扑序列</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;</span><br><span class="line"><span class="comment">//拓扑序列排序，顺便先求ve数组（每个事件的最早发生时间是根据前一个事件的最早发生时间+边的长度得出的。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.push(i);<span class="comment">//所有入度为0的顶点加入队列；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        topOrder.push(u);<span class="comment">//将u加入拓扑序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].v;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用ve[u]来更新u的所有后继结点v</span></span><br><span class="line">        <span class="keyword">if</span>(ve[u]+G[u][i].w&gt;ve[v])&#123;</span><br><span class="line">            ve[v]=ve[u]+G[u][i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(topOrder.<span class="built_in">size</span>()==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">已知所有后继结点的vl，求结点的vl--------------------------------------------------------------</span><br><span class="line">适用于汇点确定且唯一的情况，以n<span class="number">-1</span>为汇点为例</span><br><span class="line"><span class="comment">//关键路径，不是有向无环图返回-1，否则返回关键路径长度，顺便把vl数组的值求了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ve,<span class="number">0</span>,<span class="keyword">sizeof</span>(ve));<span class="comment">//ve数组初始化</span></span><br><span class="line">    <span class="keyword">if</span>(topologicalSort==<span class="literal">false</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不是有向无环图，退出</span></span><br><span class="line">    <span class="built_in">fill</span>(vl,vl+n,ve[n<span class="number">-1</span>]);<span class="comment">//vl数组初始化，初始值为汇点的ve值</span></span><br><span class="line">    <span class="comment">//直接使用topOrder出栈即为逆拓扑排序，求解vl数组</span></span><br><span class="line">    <span class="keyword">while</span>(!topOrder.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=topOrder.top();</span><br><span class="line">        topOrder.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].v;<span class="comment">//u的后继结点v</span></span><br><span class="line">            <span class="comment">//用u的所有后继节点v的vl值来更新vl[u]</span></span><br><span class="line">            <span class="keyword">if</span>(vl[v]-G[u][i].w&lt;vl[u])&#123;</span><br><span class="line">                vl[u]=vl[v]-G[u][i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//遍历邻接表的所有边，计算活动的最早活动开始时间e和最迟开始时间l</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=G[u][i].v,w=G[u][i].w;</span><br><span class="line">        <span class="keyword">int</span> e=ve[u],l=vl[v]-w;</span><br><span class="line">        <span class="comment">//如果e==1，说明活动u-&gt;v是关键活动</span></span><br><span class="line">        <span class="keyword">if</span>(e==l)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>,u,v);<span class="comment">//输出关键活动</span></span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ve[n<span class="number">-1</span>];<span class="comment">//返回关键路径长度</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">    ps：</span><br><span class="line">    <span class="number">1</span>、如果实现不知道汇点编号，就取ve数组的最大值，因为ve最大的肯定是最后一个</span><br><span class="line">    <span class="number">2</span>、如果想要存下关键活动并输出，就设置一个邻接表存一下就好。</span><br></pre></td></tr></table></figure>

<h2 id="第十一章-提高：动态规划专题"><a href="#第十一章-提高：动态规划专题" class="headerlink" title="第十一章 提高：动态规划专题"></a>第十一章 提高：动态规划专题</h2><h3 id="11-1动态规划的递归和递推"><a href="#11-1动态规划的递归和递推" class="headerlink" title="11.1动态规划的递归和递推"></a>11.1动态规划的递归和递推</h3><p>动态规划是一种用来解决一类最优化问题的算法思想，简单来说，就是将一个复杂的问题分解为若干个子问题，通过综合子问题的最优解来得到原问题的最优解，这个过程中动态规划会把每个子问题的最优解记录下来。</p>
<p><strong>实现方式有递归(例如斐波那契数列）和递推（树塔问题）</strong></p>
<p><strong>注意：一个问题必须拥有重叠子问题和最优子结构才能用DP</strong></p>
<ol>
<li>和分治的区别：分治没有重叠子问题</li>
<li>和贪心的区别：贪心不一定是最优解(但他们都拥有最优子结构)</li>
</ol>
<h3 id="11-2最大连续子序列和"><a href="#11-2最大连续子序列和" class="headerlink" title="11.2最大连续子序列和"></a>11.2最大连续子序列和</h3><ol>
<li><p>问题描述：给定一个数字序列A1~An，求i，j（1&lt;=i&lt;=j),使得A1+…+Aj最大，输出这个最大和</p>
</li>
<li><p>解决步骤：</p>
<pre><code>- 步骤一：令状态dp[i]表示以A[i]作为末尾的连续序列的最大和</code></pre><ul>
<li>步骤二：根据dp[i]的要求我们可以知道只有两种情况<pre><code>- 1、这个最大和序列只有一个元素就是A[i]本身
- 2、这个最大和序列有多个元素，从前面某处p开始（p&lt;i）开始
- 于是得到**状态转移方程：dp[i]=max{A[i],dp[i-1]+A[i]}**
- **边界为dp[0]=A[0]**</code></pre></li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"d%"</span>,&amp;n)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"d%"</span>,&amp;A[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    dp[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">max</span>(A[i],dp[i<span class="number">-1</span>]+A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后遍历一下dp数组得到的最大值就是最大连续不下降子序列和了。</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>状态后无效性：以及记录了的状态信息之后不会再改变。动态规划必须设计一个拥有后无效性的状态和相应的状态转移方程才能得到正确结果。</li>
</ol>
<h3 id="11-3最长不下降子序列（LIS）"><a href="#11-3最长不下降子序列（LIS）" class="headerlink" title="11.3最长不下降子序列（LIS）"></a>11.3最长不下降子序列（LIS）</h3><ol>
<li><p>问题描述：Longest Increasing Sequence，在一个数字序列A1~An，中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降（非递减）的。</p>
</li>
<li><p>解决步骤：</p>
<ul>
<li>步骤一：令状态dp[i]表示以A[i]作为末尾的最长不下降子序列的长度</li>
<li>步骤二：根据dp[i]的要求我们可以知道只有两种情况<ul>
<li>1、最长不下降子序列的长度为1，就只有A[i]</li>
<li>2、这个最大和序列有多个元素，从前面某处j开始（j&lt;i）开始,并且所有的A[j]&lt;A[i],遍历前面的dp[j]得到dp[j]+1的最大值。</li>
<li>于是得到<strong>状态转移方程：dp[i]=max{1,dp[j]+1}，(  j 属于[1,n) &amp;&amp; A[j]&lt;A[i]  )</strong></li>
<li><strong>边界为dp[i]=1</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"d%"</span>,&amp;n)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"d%"</span>,&amp;A[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;<span class="comment">//记录最大的dp[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//边界</span></span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[i]&amp;&amp;(dp[i]&lt;dp[j]+<span class="number">1</span>))</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d%"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="11-4最长公共子序列（LCS）"><a href="#11-4最长公共子序列（LCS）" class="headerlink" title="11.4最长公共子序列（LCS）"></a>11.4最长公共子序列（LCS）</h3><ol>
<li><p>问题描述：Longest Common Sequence，在两个字符串（数字）序列A1~An，中，找到最长的公共的的子序列（可以不连续）</p>
</li>
<li><p>解决步骤：</p>
<ul>
<li>步骤一：令状态dp [i] [j]表示以序列A的i号位和序列B的j号位作为末尾的最长公共子序列的长度</li>
<li>步骤二：根据dp[i] [j]的要求我们可以知道有两种情况<ul>
<li>1、A[i]==A[j]时，那么字符串A和B的最长公共子序列的长度要加1</li>
<li>2、A[i]!=A[j]，无法延长，就继承dp[i-1] [j]和dp[i] [j-1]中的较大值。</li>
<li>于是得到<strong>状态转移方程：</strong><pre><code>- dp[i] [j]=dp[i-1] [j-1]+1，A[i]==B[i]
    - dp[i] [j]=max(dp[i-1] [j]，dp[i] [j-1])，A[i]!=B[i]</code></pre></li>
<li><strong>边界为dp[i] [0]=dp[0] [j]=0</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],B[N];</span><br><span class="line"><span class="keyword">int</span> dp[N[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    gets(A+<span class="number">1</span>);<span class="comment">//从下标为1开始读入</span></span><br><span class="line">    gets(B+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenA=<span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lenB=<span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       d[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       d[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;lenB;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[i])&#123;</span><br><span class="line">                 dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d%\n"</span>,dp[lenA][lenB]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-5最长回文子串"><a href="#11-5最长回文子串" class="headerlink" title="11.5最长回文子串"></a>11.5最长回文子串</h3><ol>
<li>解决步骤： <ul>
<li>步骤一：令状态dp [i] [j]表示以序列A的i-1号位和序列B的j-1号位作为末尾的最长公共子串的长度（不是直接i、j号位的原因是字符串下标从零开始，而dp数组的下标表示的是两个字符串当前所在位所占的的实际长度），因此dp数组长度为dp[lenA+1] [lenB+1]],循环从i=1,j=1开始，因为任何一个下标=0的dp数组值显然都等于0。   </li>
<li>步骤二：于是，根据dp[i] [j]的要求我们可以知道有两种情况   <ul>
<li>1、A[i-1]==A[j-1]时，那么字符串A和B的最长公共子串的长度要加1    </li>
<li>2、A[i-1]!=A[j-1]，dp[i] [j]=0；    </li>
<li>于是得到<strong>状态转移方程：</strong>    </li>
<li>dp[i] [j]=dp[i-1] [j-1]+1，A[i]==B[i]      </li>
<li>dp[i] [j]=max(dp[i-1] [j]，dp[i] [j-1])，A[i]!=B[i]        </li>
<li><strong>边界为dp[i] [0]=dp[0] [j]=0</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">lower</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)  <span class="comment">//把所有字符变成小写</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s[i] &gt;= <span class="string">'A'</span> &amp;&amp; s[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">   s[i] = s[i] + <span class="number">32</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1;</span><br><span class="line">    <span class="built_in">string</span> str2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)&#123;</span><br><span class="line">        lower(str1);</span><br><span class="line">        lower(str2);</span><br><span class="line">        <span class="keyword">int</span> len1=str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=str2.length();</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>,<span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">max</span>&lt;dp[i][j])</span><br><span class="line">                        <span class="built_in">max</span>=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-6DAG最长路"><a href="#11-6DAG最长路" class="headerlink" title="11.6DAG最长路"></a>11.6DAG最长路</h3><h4 id="11-6-1-两个问题"><a href="#11-6-1-两个问题" class="headerlink" title="11.6.1 两个问题"></a>11.6.1 两个问题</h4><pre><code>- 一、求整个DAG中的最长路径（不固定起点和终点）
- 二、固定终点，求DAG的最长路径</code></pre><h4 id="11-6-2-第一题解决方法"><a href="#11-6-2-第一题解决方法" class="headerlink" title="11.6.2 第一题解决方法"></a>11.6.2 第一题解决方法</h4><ol>
<li><p><strong>先讨论第一个问题，给定一个DAG，怎样求解整个图里所有路径中权值之和最大的那条？</strong></p>
</li>
<li><p><strong>解决步骤：</strong></p>
</li>
</ol>
<ul>
<li>步骤一：令状态dp [i] 表示从i号顶点出发所能到达的最长路径的值，这样dp数组的最大值即为所求</li>
<li>步骤二：根据dp[i]的要求我们可以知道有两种情况，如果i号顶点可以得到多个下一个顶点j，则<ul>
<li>dp[i]=max{dp[j]+length[i-&gt;j]}</li>
<li><strong>边界为终点dp[i]=0,即没有下一个顶点</strong></li>
</ul>
</li>
</ul>
<ol start="3">
<li>代码实现(可以逆拓扑排序也可以递归，下面是递归)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> dp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">      <span class="keyword">if</span>(G[i][j]!=INF)&#123;</span><br><span class="line">          dp[i]=<span class="built_in">max</span>(dp[i],DP(j)+length[i-&gt;j]);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果想存下关键路径，开个choice数组记录每个结点的后继节点。</span></span><br></pre></td></tr></table></figure>

<h4 id="11-6-2-第二题解决方法"><a href="#11-6-2-第二题解决方法" class="headerlink" title="11.6.2 第二题解决方法"></a>11.6.2 第二题解决方法</h4><ol>
<li><strong>固定终点，求DAG的最长路径？</strong></li>
<li><strong>解决步骤</strong></li>
</ol>
<ul>
<li>步骤一：令状态dp [i] 表示从i号顶点出发到达终点T最长路径的值，这样dp数组的最大值即为所求</li>
<li>步骤二：根据dp[i]的要求我们可以知道有两种情况，如果i号顶点可以得到多个下一个顶点j，则<ul>
<li>dp[i]=max{dp[j]+length[i-&gt;j]}</li>
<li><strong>边界为终点dp[T]=0,即没有下一个顶点</strong>（在这里可能会有顶点无法到达T，所以这里的初始化dp数组需要赋一个负数-INF,此外还有设置一个vis数组记录顶点是否被计算</li>
</ul>
</li>
</ul>
<ol start="3">
<li>代码实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[i]) <span class="keyword">return</span> dp[i];</span><br><span class="line">    vis[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">      <span class="keyword">if</span>(G[i][j]!=INF)&#123;</span><br><span class="line">          dp[i]=<span class="built_in">max</span>(dp[i],DP(j)+length[i-&gt;j]);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:矩形嵌套问题就是一个比较经典的DP问题</p>
<h3 id="11-7背包问题"><a href="#11-7背包问题" class="headerlink" title="11.7背包问题"></a>11.7背包问题</h3><p><strong>是一类经典的动态规划问题———比如———01背包问题和完全背包问题</strong></p>
<h4 id="11-7-1多阶段动态规划问题"><a href="#11-7-1多阶段动态规划问题" class="headerlink" title="11.7.1多阶段动态规划问题"></a>11.7.1多阶段动态规划问题</h4><p>一个问题分为多个阶段，且每个阶段的状态只和上一个阶段的状态有关</p>
<h4 id="11-7-2-01背包问题"><a href="#11-7-2-01背包问题" class="headerlink" title="11.7.2 01背包问题"></a>11.7.2 01背包问题</h4><ol>
<li><strong>问题描述：</strong>有n件物品，每件物品重w[i],价值v[i]。现有容量为V的背包，问如何选取物品放入背包，才能使得背包内物品的总价值最大。其中每种物品都只有一件</li>
<li><strong>解决步骤</strong></li>
</ol>
<ul>
<li><p>步骤一：令状态dp[i] [v] 表示前i件物品恰好装入容量为v时所装入所有物品的价值</p>
</li>
<li><p>步骤二：根据dp[i]的要求我们可以知道</p>
<ol>
<li>不放入第i件物品，dp[i] [v]=dp[i-1] [v]</li>
<li>放入第i件物品，dp[i] [v]=dp[i-1] [v-w[i]]+c[i]</li>
</ol>
<ul>
<li>因此，状态转移方程dp[i] [v]=max{dp[i-1] [v]，dp[i-1] [v-w[i]]+c[i]}</li>
<li>边界dp[0] [v]=0(前0件物品放入任何容量为v的背包都只能获得价值0)</li>
</ul>
</li>
</ul>
<ol start="3">
<li>代码实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">        dp[i][v]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-7-3-完全背包问题"><a href="#11-7-3-完全背包问题" class="headerlink" title="11.7.3 完全背包问题"></a>11.7.3 完全背包问题</h4><ol>
<li><strong>问题描述：</strong>有n种物品，每件物品重w[i],价值v[i]。现有容量为V的背包，问如何选取物品放入背包，才能使得背包内物品的总价值最大。其中每种物品都有若干件</li>
<li><strong>解决步骤</strong></li>
</ol>
<ul>
<li><p>步骤一：令状态dp[i] [v] 表示前i件物品恰好装入容量为v时所装入所有物品的价值</p>
</li>
<li><p>步骤二：根据dp[i]的要求我们可以知道</p>
<ol>
<li>不放入第i件物品，dp[i] [v]=dp[i-1] [v]</li>
<li>放入第i件物品，dp[i] [v]=dp[i] [v-w[i]]+c[i]</li>
</ol>
<ul>
<li>因此，状态转移方程dp[i] [v]=max{dp[i] [v]，dp[i-1] [v-w[i]]+c[i]}</li>
<li>边界dp[0] [v]=0(前0件物品放入任何容量为v的背包都只能获得价值0)</li>
</ul>
</li>
<li><p><strong>区别：</strong></p>
</li>
<li><p><strong>放入i物品时转换的是 ：   dp[i] [v-w[i]]+c[i]</strong></p>
</li>
<li><p><strong>而不是之前的  ：              dp[i-1] [v-w[i]]+c[i]了</strong></p>
</li>
</ul>
<ol start="3">
<li>代码实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">        dp[i][v]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][v],dp[i][v-w[i]]+c[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-8总结"><a href="#11-8总结" class="headerlink" title="11.8总结"></a>11.8总结</h3><table>
<thead>
<tr>
<th>名称</th>
<th>dp数组含义</th>
</tr>
</thead>
<tbody><tr>
<td>1.最大连续子序列和</td>
<td>令dp[i]表示以A【i】作为结尾的连续序列的最大和</td>
</tr>
<tr>
<td>2.最长不下降子序列（LIS）</td>
<td>令dp[i] 表示以A【i】作为结尾的最长不下降子序列长度</td>
</tr>
<tr>
<td>3.最长公共子序列（LCS）</td>
<td>令dp[i] [j]表示以序列A的i号位和序列B的j号位作为末尾的最长公共子序列的长度</td>
</tr>
<tr>
<td>4.最长回文子串</td>
<td>令dp [i] [j]表示A[i]到A[j]是否是回文子串</td>
</tr>
<tr>
<td>5.数塔DP</td>
<td>令dp [i] [j]表示从i行j列数字出发的到达最底层的所有路径上所能得到的最大和</td>
</tr>
<tr>
<td>6.DAG最长路</td>
<td>令dp [i] 表示从i顶点出发能获得的最长路径长度</td>
</tr>
<tr>
<td>7.01背包</td>
<td>令dp[i] [v] 表示前i件物品恰好装入容量为v时所装入所有物品的最大价值</td>
</tr>
<tr>
<td>8.完全背包</td>
<td>令dp[i] [v] 表示前i件物品恰好装入容量为v时所装入所有物品的最大价值</td>
</tr>
</tbody></table>
<ol>
<li><strong>先看1~4（一般来说，子序列可以不连续，子串必须连续）</strong></li>
</ol>
<ul>
<li><strong>分析共同点可知，当题目和序列或者字符串（记为A）有关是，可以考虑这样设计：</strong><pre><code>- **令dp[i]表示以A【i】作为结尾（或开头）的XXX**
    - **令dp [i] [j]表示A[i]到A[j]区间的XXX**
    - **XXX根据原问题表述更改**</code></pre></li>
</ul>
<ol start="2">
<li><strong>再看5~8，状态设计包含了方向的意思</strong></li>
</ol>
<ul>
<li><strong>分析题目中的状态需要几维来表示，然后对其中每一维采取以下表述的其中一个</strong><pre><code>- **恰好为i**
- **前i**
- **每一维的含义设置完毕后，dp数组的含义就可以设置成“令dp数组表示恰好为i（或前i）...的XXX，接下来通过端点的特点去考虑状态转移方程。**</code></pre></li>
</ul>
<h2 id="第十二章-提高：字符串专题"><a href="#第十二章-提高：字符串专题" class="headerlink" title="第十二章 提高：字符串专题"></a>第十二章 提高：字符串专题</h2><h2 id="第十三章-提高：专题扩展"><a href="#第十三章-提高：专题扩展" class="headerlink" title="第十三章 提高：专题扩展"></a>第十三章 提高：专题扩展</h2>]]></content>
      <categories>
        <category>算法基础</category>
        <category>算法笔记2</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全</title>
    <url>/2020/08/26/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="信息安全与技术"><a href="#信息安全与技术" class="headerlink" title="信息安全与技术"></a>信息安全与技术</h1><p><img src="../images/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/clip_image002-1598431320149.jpg" alt="img"></p>
<h1 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.    1 引言"></a>1.    1 引言</h1><h2 id="1-1-1-1-网络安全概述"><a href="#1-1-1-1-网络安全概述" class="headerlink" title="1.1.     1.1 网络安全概述"></a>1.1.     1.1 网络安全概述</h2><h3 id="1-1-1-计算机系统安全"><a href="#1-1-1-计算机系统安全" class="headerlink" title="1.1.1.     计算机系统安全"></a>1.1.1.     计算机系统安全</h3><h4 id="保护数据安全和防范攻击的技术和工具"><a href="#保护数据安全和防范攻击的技术和工具" class="headerlink" title="保护数据安全和防范攻击的技术和工具"></a>保护数据安全和防范攻击的技术和工具</h4><h3 id="1-1-2-网络安全"><a href="#1-1-2-网络安全" class="headerlink" title="1.1.2.     网络安全"></a>1.1.2.     网络安全</h3><h4 id="数据传输过程中保护数据"><a href="#数据传输过程中保护数据" class="headerlink" title="数据传输过程中保护数据"></a>数据传输过程中保护数据</h4><h4 id="两个方面"><a href="#两个方面" class="headerlink" title="两个方面"></a>两个方面</h4><h5 id="信息载体"><a href="#信息载体" class="headerlink" title="信息载体"></a>信息载体</h5><h6 id="针对系统和网络"><a href="#针对系统和网络" class="headerlink" title="针对系统和网络"></a>针对系统和网络</h6><h5 id="信息本身"><a href="#信息本身" class="headerlink" title="信息本身"></a>信息本身</h5><h6 id="抵御对信息本身的安全威胁"><a href="#抵御对信息本身的安全威胁" class="headerlink" title="抵御对信息本身的安全威胁"></a>抵御对信息本身的安全威胁</h6><h2 id="1-2-1-2-安全概念"><a href="#1-2-1-2-安全概念" class="headerlink" title="1.2.     1.2 安全概念"></a>1.2.     1.2 安全概念</h2><h3 id="1-2-1-计算机安全"><a href="#1-2-1-计算机安全" class="headerlink" title="1.2.1.     计算机安全"></a>1.2.1.     计算机安全</h3><h4 id="目的：实现信息系统资源的机密性、完整性和可用性"><a href="#目的：实现信息系统资源的机密性、完整性和可用性" class="headerlink" title="目的：实现信息系统资源的机密性、完整性和可用性"></a>目的：实现信息系统资源的机密性、完整性和可用性</h4><h2 id="1-3-1-3-安全攻击"><a href="#1-3-1-3-安全攻击" class="headerlink" title="1.3.     1.3 安全攻击"></a>1.3.     1.3 安全攻击</h2><h3 id="1-3-1-OSI安全框架主要关注安全攻击，安全服务和安全机制"><a href="#1-3-1-OSI安全框架主要关注安全攻击，安全服务和安全机制" class="headerlink" title="1.3.1.     OSI安全框架主要关注安全攻击，安全服务和安全机制"></a>1.3.1.     OSI安全框架主要关注安全攻击，安全服务和安全机制</h3><h3 id="1-3-2-安全威胁"><a href="#1-3-2-安全威胁" class="headerlink" title="1.3.2.     安全威胁"></a>1.3.2.     安全威胁</h3><h4 id="指破坏安全的潜在可能，有意-无意"><a href="#指破坏安全的潜在可能，有意-无意" class="headerlink" title="指破坏安全的潜在可能，有意/无意"></a>指破坏安全的潜在可能，有意/无意</h4><h4 id="四要素（判断安全威胁是否存在）"><a href="#四要素（判断安全威胁是否存在）" class="headerlink" title="四要素（判断安全威胁是否存在）"></a>四要素（判断安全威胁是否存在）</h4><h5 id="攻击者"><a href="#攻击者" class="headerlink" title="攻击者"></a>攻击者</h5><h5 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h5><h5 id="实施攻击的漏洞"><a href="#实施攻击的漏洞" class="headerlink" title="实施攻击的漏洞"></a>实施攻击的漏洞</h5><h5 id="被攻击的系统资源"><a href="#被攻击的系统资源" class="headerlink" title="被攻击的系统资源"></a>被攻击的系统资源</h5><h3 id="1-3-3-安全攻击"><a href="#1-3-3-安全攻击" class="headerlink" title="1.3.3.     安全攻击"></a>1.3.3.     安全攻击</h3><h4 id="安全攻击是指任何危及信息系统安全的行为，是某个人、物或事件对网络资源的机密性、完整性、可用性和非否认性等所造成的危害。"><a href="#安全攻击是指任何危及信息系统安全的行为，是某个人、物或事件对网络资源的机密性、完整性、可用性和非否认性等所造成的危害。" class="headerlink" title="安全攻击是指任何危及信息系统安全的行为，是某个人、物或事件对网络资源的机密性、完整性、可用性和非否认性等所造成的危害。"></a>安全攻击是指任何危及信息系统安全的行为，是某个人、物或事件对网络资源的机密性、完整性、可用性和非否认性等所造成的危害。</h4><h4 id="RFC规范分类"><a href="#RFC规范分类" class="headerlink" title="RFC规范分类"></a>RFC规范分类</h4><h5 id="被动攻击"><a href="#被动攻击" class="headerlink" title="被动攻击"></a>被动攻击</h5><h6 id="不改变数据，只读取"><a href="#不改变数据，只读取" class="headerlink" title="不改变数据，只读取"></a>不改变数据，只读取</h6><h6 id="对信息机密性的攻击"><a href="#对信息机密性的攻击" class="headerlink" title="对信息机密性的攻击"></a>对信息机密性的攻击</h6><h6 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h6><p>析出消息内容</p>
<p>截获数据并对数据进行分析获得信息</p>
<p>对应安全机制：数据加密</p>
<p>通信量分析</p>
<p>通过观察消息模式，推测通信双方的身份位置，猜测正在发生的通信的性质</p>
<p>对应安全机制：流量填充</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>难以检测</p>
<p>可以预防</p>
<h5 id="主动攻击"><a href="#主动攻击" class="headerlink" title="主动攻击"></a>主动攻击</h5><h6 id="修改数据甚至控制信号，或者有意伪造数据，因而比被动攻击更具危害性"><a href="#修改数据甚至控制信号，或者有意伪造数据，因而比被动攻击更具危害性" class="headerlink" title="修改数据甚至控制信号，或者有意伪造数据，因而比被动攻击更具危害性"></a>修改数据甚至控制信号，或者有意伪造数据，因而比被动攻击更具危害性</h6><h6 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h6><p>篡改</p>
<p>篡改攻击</p>
<p>对信息完整性的攻击。</p>
<p>是指修改内容、延迟传输或改变顺序等，以获得非授权的效果。</p>
<p>消息重放</p>
<p>也是一种篡改攻击，是对消息发送时间的篡改。</p>
<p>消息重放是将获得的消息再次发送以产生非授权的效果。</p>
<p>伪装</p>
<p>对信息真实性的攻击。</p>
<p>伪装是一个实体假装成另一个实体以获得非授权的效果</p>
<p>拒绝服务攻击</p>
<p>对信息可用性的攻击。</p>
<p>目的是中断或干扰通信设施或服务的正常使用和管理</p>
<h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><p>难以预防</p>
<p>易于检测</p>
<h6 id="对付方法：检测攻击，并从破坏中恢复"><a href="#对付方法：检测攻击，并从破坏中恢复" class="headerlink" title="对付方法：检测攻击，并从破坏中恢复"></a>对付方法：检测攻击，并从破坏中恢复</h6><h2 id="1-4-1-4-安全服务"><a href="#1-4-1-4-安全服务" class="headerlink" title="1.4.     1.4 安全服务"></a>1.4.     1.4 安全服务</h2><h3 id="1-4-1-从·网络安全系统提供的用于保护网络安全的服务，通过安全机制实现安全策略"><a href="#1-4-1-从·网络安全系统提供的用于保护网络安全的服务，通过安全机制实现安全策略" class="headerlink" title="1.4.1.     从·网络安全系统提供的用于保护网络安全的服务，通过安全机制实现安全策略"></a>1.4.1.     从·网络安全系统提供的用于保护网络安全的服务，通过安全机制实现安全策略</h3><h3 id="1-4-2-包括"><a href="#1-4-2-包括" class="headerlink" title="1.4.2.     包括"></a>1.4.2.     包括</h3><h4 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h4><h5 id="用于保护系统免受被动攻击，系统为防止数据被非法访问或截获而泄露所提供的保护"><a href="#用于保护系统免受被动攻击，系统为防止数据被非法访问或截获而泄露所提供的保护" class="headerlink" title="用于保护系统免受被动攻击，系统为防止数据被非法访问或截获而泄露所提供的保护"></a>用于保护系统免受被动攻击，系统为防止数据被非法访问或截获而泄露所提供的保护</h5><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><h6 id="数据机密性"><a href="#数据机密性" class="headerlink" title="数据机密性"></a>数据机密性</h6><h6 id="通信量机密性"><a href="#通信量机密性" class="headerlink" title="通信量机密性"></a>通信量机密性</h6><h5 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h5><h6 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h6><h6 id="流量填充"><a href="#流量填充" class="headerlink" title="流量填充"></a>流量填充</h6><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><h5 id="用于保护消息免受篡改，确保消息未被插入，修改，重排序，重放"><a href="#用于保护消息免受篡改，确保消息未被插入，修改，重排序，重放" class="headerlink" title="用于保护消息免受篡改，确保消息未被插入，修改，重排序，重放"></a>用于保护消息免受篡改，确保消息未被插入，修改，重排序，重放</h5><h5 id="安全机制-1"><a href="#安全机制-1" class="headerlink" title="安全机制"></a>安全机制</h5><h6 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h6><h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><h6 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h6><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><h5 id="信息真实性，一方确认另一方身份"><a href="#信息真实性，一方确认另一方身份" class="headerlink" title="信息真实性，一方确认另一方身份"></a>信息真实性，一方确认另一方身份</h5><h5 id="安全机制-2"><a href="#安全机制-2" class="headerlink" title="安全机制"></a>安全机制</h5><h6 id="加密-2"><a href="#加密-2" class="headerlink" title="加密"></a>加密</h6><h6 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h6><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="限制和控制通信链路对主机和系统资源进行访问的能力，前提是身份认证或鉴别"><a href="#限制和控制通信链路对主机和系统资源进行访问的能力，前提是身份认证或鉴别" class="headerlink" title="限制和控制通信链路对主机和系统资源进行访问的能力，前提是身份认证或鉴别"></a>限制和控制通信链路对主机和系统资源进行访问的能力，前提是身份认证或鉴别</h5><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><h6 id="自主访问控制策略"><a href="#自主访问控制策略" class="headerlink" title="自主访问控制策略"></a>自主访问控制策略</h6><p>为特定用户提供访问资源的权限</p>
<p>又称基于身份的策略</p>
<p>是指对某个客体具有控制权的主体可以将对该客体的一种或多种访问权限自主地授予其他主体，并在随后地任何时候将这些权限回收</p>
<h6 id="强制访问控制策略"><a href="#强制访问控制策略" class="headerlink" title="强制访问控制策略"></a>强制访问控制策略</h6><p>基于一组能自动实施的规则</p>
<p>又称基于规则的策略</p>
<p>根据主题被信任程度和客体所包含消息的机密性或敏感程度来决定主体对客体的访问权，往往通过安全标记来实现</p>
<p>典型策略</p>
<p>多级策略</p>
<p>访问控制规则</p>
<p>只读访问规则</p>
<p>又称简单安全条件-不向上读</p>
<p>只写访问规则</p>
<p>又称*-特性-不向下写</p>
<h4 id="非否认性"><a href="#非否认性" class="headerlink" title="非否认性"></a>非否认性</h4><h5 id="防止发送方或接收方抵赖所传输的消息"><a href="#防止发送方或接收方抵赖所传输的消息" class="headerlink" title="防止发送方或接收方抵赖所传输的消息"></a>防止发送方或接收方抵赖所传输的消息</h5><h5 id="安全机制-3"><a href="#安全机制-3" class="headerlink" title="安全机制"></a>安全机制</h5><h6 id="数字签名-2"><a href="#数字签名-2" class="headerlink" title="数字签名"></a>数字签名</h6><h6 id="共同信赖的第三方仲裁"><a href="#共同信赖的第三方仲裁" class="headerlink" title="共同信赖的第三方仲裁"></a>共同信赖的第三方仲裁</h6><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><h5 id="根据系统的性能说明，能够按照被授权实体的要求访问或使用系统资源"><a href="#根据系统的性能说明，能够按照被授权实体的要求访问或使用系统资源" class="headerlink" title="根据系统的性能说明，能够按照被授权实体的要求访问或使用系统资源"></a>根据系统的性能说明，能够按照被授权实体的要求访问或使用系统资源</h5><h5 id="依赖于访问控制和其他安全服务"><a href="#依赖于访问控制和其他安全服务" class="headerlink" title="依赖于访问控制和其他安全服务"></a>依赖于访问控制和其他安全服务</h5><h2 id="1-5-1-5-安全评价准则"><a href="#1-5-1-5-安全评价准则" class="headerlink" title="1.5.     1.5 安全评价准则"></a>1.5.     1.5 安全评价准则</h2><h3 id="1-5-1-美国可信计算机系统安全评价准则TCSEC"><a href="#1-5-1-美国可信计算机系统安全评价准则TCSEC" class="headerlink" title="1.5.1.     美国可信计算机系统安全评价准则TCSEC"></a>1.5.1.     美国可信计算机系统安全评价准则TCSEC</h3><h3 id="1-5-2-分类"><a href="#1-5-2-分类" class="headerlink" title="1.5.2.     分类"></a>1.5.2.     分类</h3><h4 id="分为四大类：D、B、C、A"><a href="#分为四大类：D、B、C、A" class="headerlink" title="分为四大类：D、B、C、A"></a>分为四大类：D、B、C、A</h4><h4 id="从低到高：D-C1-C2-B1-B2-B3-A七个级别"><a href="#从低到高：D-C1-C2-B1-B2-B3-A七个级别" class="headerlink" title="从低到高：D-C1-C2-B1-B2-B3-A七个级别"></a>从低到高：D-C1-C2-B1-B2-B3-A七个级别</h4><h4 id="D类"><a href="#D类" class="headerlink" title="D类"></a>D类</h4><h5 id="经过评价但不能达到任何更高级别要求的系统"><a href="#经过评价但不能达到任何更高级别要求的系统" class="headerlink" title="经过评价但不能达到任何更高级别要求的系统"></a>经过评价但不能达到任何更高级别要求的系统</h5><h4 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h4><h5 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h5><h6 id="自主安全保护"><a href="#自主安全保护" class="headerlink" title="自主安全保护"></a>自主安全保护</h6><h5 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h5><h6 id="受控安全保护"><a href="#受控安全保护" class="headerlink" title="受控安全保护"></a>受控安全保护</h6><h4 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h4><h5 id="B1"><a href="#B1" class="headerlink" title="B1"></a>B1</h5><h6 id="标记安全保护"><a href="#标记安全保护" class="headerlink" title="标记安全保护"></a>标记安全保护</h6><h5 id="B2"><a href="#B2" class="headerlink" title="B2"></a>B2</h5><h6 id="结构化保护"><a href="#结构化保护" class="headerlink" title="结构化保护"></a>结构化保护</h6><h5 id="B3"><a href="#B3" class="headerlink" title="B3"></a>B3</h5><h6 id="安全域"><a href="#安全域" class="headerlink" title="安全域"></a>安全域</h6><h4 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h4><h5 id="经过验证的保护"><a href="#经过验证的保护" class="headerlink" title="经过验证的保护"></a>经过验证的保护</h5><h3 id="1-5-3-可信计算基TCB：系统安全相关的保护"><a href="#1-5-3-可信计算基TCB：系统安全相关的保护" class="headerlink" title="1.5.3.     可信计算基TCB：系统安全相关的保护"></a>1.5.3.     可信计算基TCB：系统安全相关的保护</h3><h2 id="1-6-1-6-网络安全模型"><a href="#1-6-1-6-网络安全模型" class="headerlink" title="1.6.     1.6 网络安全模型"></a>1.6.     1.6 网络安全模型</h2><h3 id="1-6-1-加密安全模型"><a href="#1-6-1-加密安全模型" class="headerlink" title="1.6.1.     加密安全模型"></a>1.6.1.     加密安全模型</h3><h4 id="用户消息通过网络传输，需要安全系统对传输的消息进行保护，这一类安全模型叫做加密安全模型"><a href="#用户消息通过网络传输，需要安全系统对传输的消息进行保护，这一类安全模型叫做加密安全模型" class="headerlink" title="用户消息通过网络传输，需要安全系统对传输的消息进行保护，这一类安全模型叫做加密安全模型"></a>用户消息通过网络传输，需要安全系统对传输的消息进行保护，这一类安全模型叫做加密安全模型</h4><h4 id="涉及"><a href="#涉及" class="headerlink" title="涉及"></a>涉及</h4><h5 id="参与者-信息通道-安全机制"><a href="#参与者-信息通道-安全机制" class="headerlink" title="参与者+信息通道+安全机制"></a>参与者+信息通道+安全机制</h5><h5 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h5><h6 id="发送方-接收方-可信的第三方-攻击者"><a href="#发送方-接收方-可信的第三方-攻击者" class="headerlink" title="发送方+接收方+可信的第三方+攻击者"></a>发送方+接收方+可信的第三方+攻击者</h6><h4 id="安全机制-4"><a href="#安全机制-4" class="headerlink" title="安全机制"></a>安全机制</h4><h5 id="安全变换"><a href="#安全变换" class="headerlink" title="安全变换"></a>安全变换</h5><h6 id="加密变换"><a href="#加密变换" class="headerlink" title="加密变换"></a>加密变换</h6><h6 id="流量填充-1"><a href="#流量填充-1" class="headerlink" title="流量填充"></a>流量填充</h6><h6 id="数字签名-3"><a href="#数字签名-3" class="headerlink" title="数字签名"></a>数字签名</h6><h6 id="报文鉴别-1"><a href="#报文鉴别-1" class="headerlink" title="报文鉴别"></a>报文鉴别</h6><h6 id="与其相关的是安全变换算法-算法参数：秘密信息"><a href="#与其相关的是安全变换算法-算法参数：秘密信息" class="headerlink" title="与其相关的是安全变换算法+算法参数：秘密信息"></a>与其相关的是安全变换算法+算法参数：秘密信息</h6><h5 id="秘密信息"><a href="#秘密信息" class="headerlink" title="秘密信息"></a>秘密信息</h5><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><h5 id="设计安全变换算法"><a href="#设计安全变换算法" class="headerlink" title="设计安全变换算法"></a>设计安全变换算法</h5><h5 id="生成秘密信息"><a href="#生成秘密信息" class="headerlink" title="生成秘密信息"></a>生成秘密信息</h5><h5 id="设计秘密信息发布和共享的方法，可以由可信的第三方发布，亦可以由通信双方任何一方发布"><a href="#设计秘密信息发布和共享的方法，可以由可信的第三方发布，亦可以由通信双方任何一方发布" class="headerlink" title="设计秘密信息发布和共享的方法，可以由可信的第三方发布，亦可以由通信双方任何一方发布"></a>设计秘密信息发布和共享的方法，可以由可信的第三方发布，亦可以由通信双方任何一方发布</h5><h5 id="设计保证通信安全的协议"><a href="#设计保证通信安全的协议" class="headerlink" title="设计保证通信安全的协议"></a>设计保证通信安全的协议</h5><h3 id="1-6-2-访问安全模型"><a href="#1-6-2-访问安全模型" class="headerlink" title="1.6.2.     访问安全模型"></a>1.6.2.     访问安全模型</h3><h4 id="攻击者有可能试图通过网络对系统资源进行非法访问，此时需要对资源系统提供安全保护"><a href="#攻击者有可能试图通过网络对系统资源进行非法访问，此时需要对资源系统提供安全保护" class="headerlink" title="攻击者有可能试图通过网络对系统资源进行非法访问，此时需要对资源系统提供安全保护"></a>攻击者有可能试图通过网络对系统资源进行非法访问，此时需要对资源系统提供安全保护</h4><h4 id="涉及-1"><a href="#涉及-1" class="headerlink" title="涉及"></a>涉及</h4><h5 id="攻击者-访问信道-安全机制-资源系统"><a href="#攻击者-访问信道-安全机制-资源系统" class="headerlink" title="攻击者+访问信道+安全机制+资源系统"></a>攻击者+访问信道+安全机制+资源系统</h5><h5 id="攻击者-1"><a href="#攻击者-1" class="headerlink" title="攻击者"></a>攻击者</h5><h6 id="人或软件"><a href="#人或软件" class="headerlink" title="人或软件"></a>人或软件</h6><h5 id="资源系统"><a href="#资源系统" class="headerlink" title="资源系统"></a>资源系统</h5><h6 id="计算-数据-软件资源"><a href="#计算-数据-软件资源" class="headerlink" title="计算/数据/软件资源"></a>计算/数据/软件资源</h6><h4 id="两道安全防线"><a href="#两道安全防线" class="headerlink" title="两道安全防线"></a>两道安全防线</h4><h5 id="外部安全防线"><a href="#外部安全防线" class="headerlink" title="外部安全防线"></a>外部安全防线</h5><h6 id="隔离或过滤作用"><a href="#隔离或过滤作用" class="headerlink" title="隔离或过滤作用"></a>隔离或过滤作用</h6><h6 id="身份鉴别-防火墙"><a href="#身份鉴别-防火墙" class="headerlink" title="身份鉴别+防火墙"></a>身份鉴别+防火墙</h6><h5 id="系统内部安全防线"><a href="#系统内部安全防线" class="headerlink" title="系统内部安全防线"></a>系统内部安全防线</h5><h1 id="2-2-密码学基本原理"><a href="#2-2-密码学基本原理" class="headerlink" title="2.    2 密码学基本原理"></a>2.    2 密码学基本原理</h1><h2 id="2-1-2-1-密码学基本概念"><a href="#2-1-2-1-密码学基本概念" class="headerlink" title="2.1.     2.1 密码学基本概念"></a>2.1.     2.1 密码学基本概念</h2><h3 id="2-1-1-密码学"><a href="#2-1-1-密码学" class="headerlink" title="2.1.1.     密码学"></a>2.1.1.     密码学</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><h5 id="研究数据保密，秘密变换信息防止被第三方窃取"><a href="#研究数据保密，秘密变换信息防止被第三方窃取" class="headerlink" title="研究数据保密，秘密变换信息防止被第三方窃取"></a>研究数据保密，秘密变换信息防止被第三方窃取</h5><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><h5 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h5><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><h5 id="密码编码技术"><a href="#密码编码技术" class="headerlink" title="密码编码技术"></a>密码编码技术</h5><h6 id="找到高安全性的有效密码算法和协议，以满足对消息进行安全保护的要求"><a href="#找到高安全性的有效密码算法和协议，以满足对消息进行安全保护的要求" class="headerlink" title="找到高安全性的有效密码算法和协议，以满足对消息进行安全保护的要求"></a>找到高安全性的有效密码算法和协议，以满足对消息进行安全保护的要求</h6><h6 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h6><p>保护明文、密钥，防止攻击者非法窃取</p>
<h5 id="密码分析技术"><a href="#密码分析技术" class="headerlink" title="密码分析技术"></a>密码分析技术</h5><h6 id="试图破解或伪造认证信息，试图窃取机密信息或进行诈骗活动的目的"><a href="#试图破解或伪造认证信息，试图窃取机密信息或进行诈骗活动的目的" class="headerlink" title="试图破解或伪造认证信息，试图窃取机密信息或进行诈骗活动的目的"></a>试图破解或伪造认证信息，试图窃取机密信息或进行诈骗活动的目的</h6><h6 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h6><p>密钥未知的情况下试图恢复明文或者密钥</p>
<h3 id="2-1-2-密码系统"><a href="#2-1-2-密码系统" class="headerlink" title="2.1.2.     密码系统"></a>2.1.2.     密码系统</h3><h4 id="明文P"><a href="#明文P" class="headerlink" title="明文P"></a>明文P</h4><h5 id="加密变换前的原信息"><a href="#加密变换前的原信息" class="headerlink" title="加密变换前的原信息"></a>加密变换前的原信息</h5><h4 id="密文C"><a href="#密文C" class="headerlink" title="密文C"></a>密文C</h4><h5 id="加密变换后的信息"><a href="#加密变换后的信息" class="headerlink" title="加密变换后的信息"></a>加密变换后的信息</h5><h4 id="加密算法E"><a href="#加密算法E" class="headerlink" title="加密算法E"></a>加密算法E</h4><h5 id="加密变换使用的算法（稳定且公开）"><a href="#加密变换使用的算法（稳定且公开）" class="headerlink" title="加密变换使用的算法（稳定且公开）"></a>加密变换使用的算法（稳定且公开）</h5><h4 id="解密算法D"><a href="#解密算法D" class="headerlink" title="解密算法D"></a>解密算法D</h4><h5 id="解密变换使用的算法（E的逆过程）"><a href="#解密变换使用的算法（E的逆过程）" class="headerlink" title="解密变换使用的算法（E的逆过程）"></a>解密变换使用的算法（E的逆过程）</h5><h4 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h4><h5 id="加-解密过程中引入的一个相同或者两个不同但相关的参数"><a href="#加-解密过程中引入的一个相同或者两个不同但相关的参数" class="headerlink" title="加/解密过程中引入的一个相同或者两个不同但相关的参数"></a>加/解密过程中引入的一个相同或者两个不同但相关的参数</h5><h4 id="由于加密算法通常公开，使用被加密信息的安全性通常取决于密钥的安全性"><a href="#由于加密算法通常公开，使用被加密信息的安全性通常取决于密钥的安全性" class="headerlink" title="由于加密算法通常公开，使用被加密信息的安全性通常取决于密钥的安全性"></a>由于加密算法通常公开，使用被加密信息的安全性通常取决于密钥的安全性</h4><h2 id="2-2-2-2-密码体制"><a href="#2-2-2-2-密码体制" class="headerlink" title="2.2.     2.2 密码体制"></a>2.2.     2.2 密码体制</h2><h3 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1.     概念"></a>2.2.1.     概念</h3><h4 id="加-解密过程中采用方法的种类"><a href="#加-解密过程中采用方法的种类" class="headerlink" title="加/解密过程中采用方法的种类"></a>加/解密过程中采用方法的种类</h4><h3 id="2-2-2-分类方法"><a href="#2-2-2-分类方法" class="headerlink" title="2.2.2.     分类方法"></a>2.2.2.     分类方法</h3><h4 id="加解密密钥是否相同"><a href="#加解密密钥是否相同" class="headerlink" title="加解密密钥是否相同"></a>加解密密钥是否相同</h4><h5 id="对称密码体制"><a href="#对称密码体制" class="headerlink" title="对称密码体制"></a>对称密码体制</h5><h6 id="加解密钥相同，密钥必须保密"><a href="#加解密钥相同，密钥必须保密" class="headerlink" title="加解密钥相同，密钥必须保密"></a>加解密钥相同，密钥必须保密</h6><h6 id="又称：常规-单-秘密密钥密码体制"><a href="#又称：常规-单-秘密密钥密码体制" class="headerlink" title="又称：常规/单/秘密密钥密码体制"></a>又称：常规/单/秘密密钥密码体制</h6><h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><p>加密效率较高</p>
<p>保密强度较高</p>
<p>难以满足开放式系统的要求</p>
<h5 id="非对称密码体制"><a href="#非对称密码体制" class="headerlink" title="非对称密码体制"></a>非对称密码体制</h5><h6 id="公钥对外开放，私钥保密，公钥不可推出私钥"><a href="#公钥对外开放，私钥保密，公钥不可推出私钥" class="headerlink" title="公钥对外开放，私钥保密，公钥不可推出私钥"></a>公钥对外开放，私钥保密，公钥不可推出私钥</h6><h6 id="又称：双-公开密钥密码体制"><a href="#又称：双-公开密钥密码体制" class="headerlink" title="又称：双/公开密钥密码体制"></a>又称：双/公开密钥密码体制</h6><h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h6><p>密钥分配方便，能够用于鉴别和数字签名</p>
<p>较好的满足开放式系统的要求</p>
<p>算法复杂度高，开销大，不适合大量数据加密处理</p>
<h4 id="密文是否与明文段位置有关"><a href="#密文是否与明文段位置有关" class="headerlink" title="密文是否与明文段位置有关"></a>密文是否与明文段位置有关</h4><h5 id="分组密码体制"><a href="#分组密码体制" class="headerlink" title="分组密码体制"></a>分组密码体制</h5><h6 id="密文仅与加密算法和密钥有关，与明文段位置无关"><a href="#密文仅与加密算法和密钥有关，与明文段位置无关" class="headerlink" title="密文仅与加密算法和密钥有关，与明文段位置无关"></a>密文仅与加密算法和密钥有关，与明文段位置无关</h6><h6 id="对固定长度的明文分组加密，生成相同固定长度的密文分组"><a href="#对固定长度的明文分组加密，生成相同固定长度的密文分组" class="headerlink" title="对固定长度的明文分组加密，生成相同固定长度的密文分组"></a>对固定长度的明文分组加密，生成相同固定长度的密文分组</h6><h5 id="序列密码体制"><a href="#序列密码体制" class="headerlink" title="序列密码体制"></a>序列密码体制</h5><h6 id="密文不仅与加密算法和密钥有关，还与明文段所在位置有关"><a href="#密文不仅与加密算法和密钥有关，还与明文段所在位置有关" class="headerlink" title="密文不仅与加密算法和密钥有关，还与明文段所在位置有关"></a>密文不仅与加密算法和密钥有关，还与明文段所在位置有关</h6><h6 id="每次对较小的明文单元处理，通常以比特（或字节）为加密单元，将明文流和密钥流结合形成密文流"><a href="#每次对较小的明文单元处理，通常以比特（或字节）为加密单元，将明文流和密钥流结合形成密文流" class="headerlink" title="每次对较小的明文单元处理，通常以比特（或字节）为加密单元，将明文流和密钥流结合形成密文流"></a>每次对较小的明文单元处理，通常以比特（或字节）为加密单元，将明文流和密钥流结合形成密文流</h6><h6 id="密文流"><a href="#密文流" class="headerlink" title="密文流"></a>密文流</h6><p>与明文流等长的伪随机序列（密钥流也是）</p>
<h6 id="类似于一次一密体制"><a href="#类似于一次一密体制" class="headerlink" title="类似于一次一密体制"></a>类似于一次一密体制</h6><h4 id="加密变换是否可逆"><a href="#加密变换是否可逆" class="headerlink" title="加密变换是否可逆"></a>加密变换是否可逆</h4><h5 id="单向密码体制"><a href="#单向密码体制" class="headerlink" title="单向密码体制"></a>单向密码体制</h5><h5 id="双向密码体制"><a href="#双向密码体制" class="headerlink" title="双向密码体制"></a>双向密码体制</h5><h4 id="是否引入客观随机因素"><a href="#是否引入客观随机因素" class="headerlink" title="是否引入客观随机因素"></a>是否引入客观随机因素</h4><h5 id="确定型密码体制"><a href="#确定型密码体制" class="headerlink" title="确定型密码体制"></a>确定型密码体制</h5><h5 id="概率密码体制"><a href="#概率密码体制" class="headerlink" title="概率密码体制"></a>概率密码体制</h5><h2 id="2-3-2-3-密码分析"><a href="#2-3-2-3-密码分析" class="headerlink" title="2.3.     2.3 密码分析"></a>2.3.     2.3 密码分析</h2><h3 id="2-3-1-攻击目标"><a href="#2-3-1-攻击目标" class="headerlink" title="2.3.1.     攻击目标"></a>2.3.1.     攻击目标</h3><h4 id="恢复密钥而不仅仅是单个明文"><a href="#恢复密钥而不仅仅是单个明文" class="headerlink" title="恢复密钥而不仅仅是单个明文"></a>恢复密钥而不仅仅是单个明文</h4><h3 id="2-3-2-攻击策略"><a href="#2-3-2-攻击策略" class="headerlink" title="2.3.2.     攻击策略"></a>2.3.2.     攻击策略</h3><h4 id="取决于攻击者掌握的信息和加密方案的性质"><a href="#取决于攻击者掌握的信息和加密方案的性质" class="headerlink" title="取决于攻击者掌握的信息和加密方案的性质"></a>取决于攻击者掌握的信息和加密方案的性质</h4><h3 id="2-3-3-获得信息类型"><a href="#2-3-3-获得信息类型" class="headerlink" title="2.3.3.     获得信息类型"></a>2.3.3.     获得信息类型</h3><h4 id="1、加密算法"><a href="#1、加密算法" class="headerlink" title="1、加密算法"></a>1、加密算法</h4><h4 id="2、密文"><a href="#2、密文" class="headerlink" title="2、密文"></a>2、密文</h4><h4 id="3、一个或多个明文、密文对"><a href="#3、一个或多个明文、密文对" class="headerlink" title="3、一个或多个明文、密文对"></a>3、一个或多个明文、密文对</h4><h4 id="4、攻击者所选择的明文，以及该明文所对应的密文"><a href="#4、攻击者所选择的明文，以及该明文所对应的密文" class="headerlink" title="4、攻击者所选择的明文，以及该明文所对应的密文"></a>4、攻击者所选择的明文，以及该明文所对应的密文</h4><h4 id="4、攻击者所选择的密文，以及该密文所对应的明文"><a href="#4、攻击者所选择的密文，以及该密文所对应的明文" class="headerlink" title="4、攻击者所选择的密文，以及该密文所对应的明文"></a>4、攻击者所选择的密文，以及该密文所对应的明文</h4><h3 id="2-3-4-攻击类型"><a href="#2-3-4-攻击类型" class="headerlink" title="2.3.4.     攻击类型"></a>2.3.4.     攻击类型</h3><h4 id="唯密文攻击"><a href="#唯密文攻击" class="headerlink" title="唯密文攻击"></a>唯密文攻击</h4><h5 id="1-2"><a href="#1-2" class="headerlink" title="1+2"></a>1+2</h5><h5 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h5><h6 id="穷举攻击"><a href="#穷举攻击" class="headerlink" title="穷举攻击"></a>穷举攻击</h6><h4 id="已知明文攻击"><a href="#已知明文攻击" class="headerlink" title="已知明文攻击"></a>已知明文攻击</h4><h5 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1+2+3"></a>1+2+3</h5><h4 id="选择明文攻击"><a href="#选择明文攻击" class="headerlink" title="选择明文攻击"></a>选择明文攻击</h4><h5 id="1-2-4"><a href="#1-2-4" class="headerlink" title="1+2+4"></a>1+2+4</h5><h5 id="差分密码分析"><a href="#差分密码分析" class="headerlink" title="差分密码分析"></a>差分密码分析</h5><h4 id="选择密文攻击"><a href="#选择密文攻击" class="headerlink" title="选择密文攻击"></a>选择密文攻击</h4><h5 id="1-2-5"><a href="#1-2-5" class="headerlink" title="1+2+5"></a>1+2+5</h5><h4 id="选择文本攻击"><a href="#选择文本攻击" class="headerlink" title="选择文本攻击"></a>选择文本攻击</h4><h5 id="1-2-4-5"><a href="#1-2-4-5" class="headerlink" title="1+2+4+5"></a>1+2+4+5</h5><h4 id="一般地，加密算法要能够抵挡已知明文攻击"><a href="#一般地，加密算法要能够抵挡已知明文攻击" class="headerlink" title="一般地，加密算法要能够抵挡已知明文攻击"></a>一般地，加密算法要能够抵挡已知明文攻击</h4><h3 id="2-3-5-与加密算法强度相关概念"><a href="#2-3-5-与加密算法强度相关概念" class="headerlink" title="2.3.5.     与加密算法强度相关概念"></a>2.3.5.     与加密算法强度相关概念</h3><h4 id="无条件安全"><a href="#无条件安全" class="headerlink" title="无条件安全"></a>无条件安全</h4><h5 id="除一次一密方案外不存在无条件安全地加密方案"><a href="#除一次一密方案外不存在无条件安全地加密方案" class="headerlink" title="除一次一密方案外不存在无条件安全地加密方案"></a>除一次一密方案外不存在无条件安全地加密方案</h5><h4 id="计算上安全"><a href="#计算上安全" class="headerlink" title="计算上安全"></a>计算上安全</h4><h5 id="满足两个准则之一"><a href="#满足两个准则之一" class="headerlink" title="满足两个准则之一"></a>满足两个准则之一</h5><h5 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h5><h6 id="破译该密码的成本超过被加密信息价值"><a href="#破译该密码的成本超过被加密信息价值" class="headerlink" title="破译该密码的成本超过被加密信息价值"></a>破译该密码的成本超过被加密信息价值</h6><h6 id="破译该密码的时间超过被加密信息生命周期"><a href="#破译该密码的时间超过被加密信息生命周期" class="headerlink" title="破译该密码的时间超过被加密信息生命周期"></a>破译该密码的时间超过被加密信息生命周期</h6><h3 id="2-3-6-穷举攻击"><a href="#2-3-6-穷举攻击" class="headerlink" title="2.3.6.     穷举攻击"></a>2.3.6.     穷举攻击</h3><h4 id="除密码分析的另一种攻击"><a href="#除密码分析的另一种攻击" class="headerlink" title="除密码分析的另一种攻击"></a>除密码分析的另一种攻击</h4><h4 id="一般必须尝试所有密钥的1-2才可能成功"><a href="#一般必须尝试所有密钥的1-2才可能成功" class="headerlink" title="一般必须尝试所有密钥的1/2才可能成功"></a>一般必须尝试所有密钥的1/2才可能成功</h4><h1 id="3-3-古典密码"><a href="#3-3-古典密码" class="headerlink" title="3.    3 古典密码"></a>3.    3 古典密码</h1><h2 id="3-1-3-1替代技术"><a href="#3-1-3-1替代技术" class="headerlink" title="3.1.     3.1替代技术"></a>3.1.     3.1替代技术</h2><h3 id="3-1-1-概念：将明文中每个元素（比特、字母、比特组合或字母组合）映射为另一个元素的技术"><a href="#3-1-1-概念：将明文中每个元素（比特、字母、比特组合或字母组合）映射为另一个元素的技术" class="headerlink" title="3.1.1.     概念：将明文中每个元素（比特、字母、比特组合或字母组合）映射为另一个元素的技术"></a>3.1.1.     概念：将明文中每个元素（比特、字母、比特组合或字母组合）映射为另一个元素的技术</h3><h3 id="3-1-2-分类"><a href="#3-1-2-分类" class="headerlink" title="3.1.2.     分类"></a>3.1.2.     分类</h3><h4 id="单字母替代密码"><a href="#单字母替代密码" class="headerlink" title="单字母替代密码"></a>单字母替代密码</h4><h5 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h5><h6 id="明文每个字母用其后第三个字母代替"><a href="#明文每个字母用其后第三个字母代替" class="headerlink" title="明文每个字母用其后第三个字母代替"></a>明文每个字母用其后第三个字母代替</h6><h6 id="c-（m-3）mod-26"><a href="#c-（m-3）mod-26" class="headerlink" title="c=（m+3）mod 26"></a>c=（m+3）mod 26</h6><h6 id="密钥空间-3"><a href="#密钥空间-3" class="headerlink" title="密钥空间 3"></a>密钥空间 3</h6><h5 id="移位密码"><a href="#移位密码" class="headerlink" title="移位密码"></a>移位密码</h5><h6 id="明文每个字母用其后第k个字母代替（偏移值可更改）"><a href="#明文每个字母用其后第k个字母代替（偏移值可更改）" class="headerlink" title="明文每个字母用其后第k个字母代替（偏移值可更改）"></a>明文每个字母用其后第k个字母代替（偏移值可更改）</h6><h6 id="c-（m-k）mod-26"><a href="#c-（m-k）mod-26" class="headerlink" title="c=（m+k）mod 26"></a>c=（m+k）mod 26</h6><h6 id="密钥空间-k"><a href="#密钥空间-k" class="headerlink" title="密钥空间 k"></a>密钥空间 k</h6><h5 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h5><h6 id="c-（am-b）mod-26"><a href="#c-（am-b）mod-26" class="headerlink" title="c=（am+b）mod 26"></a>c=（am+b）mod 26</h6><h6 id="m-a-1-c-b-mod-26"><a href="#m-a-1-c-b-mod-26" class="headerlink" title="m=a^-1(c-b)mod 26"></a>m=a^-1(c-b)mod 26</h6><h4 id="多字母替代密码"><a href="#多字母替代密码" class="headerlink" title="多字母替代密码"></a>多字母替代密码</h4><h5 id="Vigenere密码"><a href="#Vigenere密码" class="headerlink" title="Vigenere密码"></a>Vigenere密码</h5><h6 id="Ci-（Mi-K-i-mod-r）mod-26"><a href="#Ci-（Mi-K-i-mod-r）mod-26" class="headerlink" title="Ci=（Mi+K(i mod r）mod 26"></a>Ci=（Mi+K(i mod r）mod 26</h6><h6 id="Mi-（Ci-K-i-mod-r）mod-26"><a href="#Mi-（Ci-K-i-mod-r）mod-26" class="headerlink" title="Mi=（Ci-K(i mod r）mod 26"></a>Mi=（Ci-K(i mod r）mod 26</h6><h6 id="使用不同密钥对应不同的单字母替代"><a href="#使用不同密钥对应不同的单字母替代" class="headerlink" title="使用不同密钥对应不同的单字母替代"></a>使用不同密钥对应不同的单字母替代</h6><h6 id="密钥空间-26-r"><a href="#密钥空间-26-r" class="headerlink" title="密钥空间 26^r"></a>密钥空间 26^r</h6><h5 id="Hill密码"><a href="#Hill密码" class="headerlink" title="Hill密码"></a>Hill密码</h5><h6 id="密钥K为n-n的矩阵"><a href="#密钥K为n-n的矩阵" class="headerlink" title="密钥K为n*n的矩阵"></a>密钥K为n*n的矩阵</h6><h2 id="3-2-3-2置换技术"><a href="#3-2-3-2置换技术" class="headerlink" title="3.2.     3.2置换技术"></a>3.2.     3.2置换技术</h2><h3 id="3-2-1-概念：在不丢失信息的其前提下对明文中的元素进行重新排序，以打乱明文字母的位置和顺序-y-f（x）"><a href="#3-2-1-概念：在不丢失信息的其前提下对明文中的元素进行重新排序，以打乱明文字母的位置和顺序-y-f（x）" class="headerlink" title="3.2.1.     概念：在不丢失信息的其前提下对明文中的元素进行重新排序，以打乱明文字母的位置和顺序 y= f（x）"></a>3.2.1.     概念：在不丢失信息的其前提下对明文中的元素进行重新排序，以打乱明文字母的位置和顺序 y= f（x）</h3><h1 id="4-4-对称密码"><a href="#4-4-对称密码" class="headerlink" title="4.    4 对称密码"></a>4.    4 对称密码</h1><h2 id="4-1-4-1概述"><a href="#4-1-4-1概述" class="headerlink" title="4.1.     4.1概述"></a>4.1.     4.1概述</h2><h3 id="4-1-1-对称密码模型"><a href="#4-1-1-对称密码模型" class="headerlink" title="4.1.1.     对称密码模型"></a>4.1.1.     对称密码模型</h3><h4 id="CS-（P，C，E，D，K）"><a href="#CS-（P，C，E，D，K）" class="headerlink" title="CS=（P，C，E，D，K）"></a>CS=（P，C，E，D，K）</h4><h3 id="4-1-2-分类"><a href="#4-1-2-分类" class="headerlink" title="4.1.2.     分类"></a>4.1.2.     分类</h3><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><h4 id="序列密码（流密码）"><a href="#序列密码（流密码）" class="headerlink" title="序列密码（流密码）"></a>序列密码（流密码）</h4><h2 id="4-2-4-2分组密码原理与操作模式"><a href="#4-2-4-2分组密码原理与操作模式" class="headerlink" title="4.2.     4.2分组密码原理与操作模式"></a>4.2.     4.2分组密码原理与操作模式</h2><h3 id="4-2-1-分组密码原理"><a href="#4-2-1-分组密码原理" class="headerlink" title="4.2.1.     分组密码原理"></a>4.2.1.     分组密码原理</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><h5 id="加密算法公开，常规加密算法的安全性取决于密钥的安全性（密钥对安全的影响主要包括两个方面）"><a href="#加密算法公开，常规加密算法的安全性取决于密钥的安全性（密钥对安全的影响主要包括两个方面）" class="headerlink" title="加密算法公开，常规加密算法的安全性取决于密钥的安全性（密钥对安全的影响主要包括两个方面）"></a>加密算法公开，常规加密算法的安全性取决于密钥的安全性（密钥对安全的影响主要包括两个方面）</h5><h5 id="密钥安全"><a href="#密钥安全" class="headerlink" title="密钥安全"></a>密钥安全</h5><h6 id="密钥长度"><a href="#密钥长度" class="headerlink" title="密钥长度"></a>密钥长度</h6><h6 id="密钥更新频率"><a href="#密钥更新频率" class="headerlink" title="密钥更新频率"></a>密钥更新频率</h6><h4 id="扩散与扰乱"><a href="#扩散与扰乱" class="headerlink" title="扩散与扰乱"></a>扩散与扰乱</h4><h5 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h5><h6 id="让明文和密钥的每个字母影响尽可能多的密文字母的取值，从而使得明文和密钥的统计特征被扩散"><a href="#让明文和密钥的每个字母影响尽可能多的密文字母的取值，从而使得明文和密钥的统计特征被扩散" class="headerlink" title="让明文和密钥的每个字母影响尽可能多的密文字母的取值，从而使得明文和密钥的统计特征被扩散"></a>让明文和密钥的每个字母影响尽可能多的密文字母的取值，从而使得明文和密钥的统计特征被扩散</h6><h6 id="密文中多字母组合的出现频率比在明文和密钥中出现的频率均匀，明文和密钥中原有的统计特征不再反映在密文中"><a href="#密文中多字母组合的出现频率比在明文和密钥中出现的频率均匀，明文和密钥中原有的统计特征不再反映在密文中" class="headerlink" title="密文中多字母组合的出现频率比在明文和密钥中出现的频率均匀，明文和密钥中原有的统计特征不再反映在密文中"></a>密文中多字母组合的出现频率比在明文和密钥中出现的频率均匀，明文和密钥中原有的统计特征不再反映在密文中</h6><h5 id="扰乱"><a href="#扰乱" class="headerlink" title="扰乱"></a>扰乱</h5><h6 id="使明文与密钥与密文的统计特征的关系尽可能复杂化"><a href="#使明文与密钥与密文的统计特征的关系尽可能复杂化" class="headerlink" title="使明文与密钥与密文的统计特征的关系尽可能复杂化"></a>使明文与密钥与密文的统计特征的关系尽可能复杂化</h6><h6 id="使得攻击者即使掌握了密文的某些统计特征，也很难从中推测出密钥和明文。"><a href="#使得攻击者即使掌握了密文的某些统计特征，也很难从中推测出密钥和明文。" class="headerlink" title="使得攻击者即使掌握了密文的某些统计特征，也很难从中推测出密钥和明文。"></a>使得攻击者即使掌握了密文的某些统计特征，也很难从中推测出密钥和明文。</h6><h4 id="Feistel分组密码"><a href="#Feistel分组密码" class="headerlink" title="Feistel分组密码"></a>Feistel分组密码</h4><h5 id="PPT-11图（会考）"><a href="#PPT-11图（会考）" class="headerlink" title="PPT-11图（会考）"></a>PPT-11图（会考）</h5><h5 id="安全性相关参数"><a href="#安全性相关参数" class="headerlink" title="安全性相关参数"></a>安全性相关参数</h5><h6 id="分组长度"><a href="#分组长度" class="headerlink" title="分组长度"></a>分组长度</h6><p>分组越长安全性越高，加解密速度越慢，通常64</p>
<h6 id="密钥长度-1"><a href="#密钥长度-1" class="headerlink" title="密钥长度"></a>密钥长度</h6><p>密钥越长安全性越高，加解密速度越慢，通常128或更长</p>
<h6 id="循环次数"><a href="#循环次数" class="headerlink" title="循环次数"></a>循环次数</h6><p>循环次数越多安全性越高，加解密速度越慢，通常16次</p>
<h6 id="子密钥生成算法"><a href="#子密钥生成算法" class="headerlink" title="子密钥生成算法"></a>子密钥生成算法</h6><p>子密钥生成算法越复杂，安全性越高</p>
<h6 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h6><p>轮函数越复杂，扩散与扰乱功能越强，安全性越高</p>
<h3 id="4-2-2-分组密码模式"><a href="#4-2-2-分组密码模式" class="headerlink" title="4.2.2.     分组密码模式"></a>4.2.2.     分组密码模式</h3><h4 id="电子密码本ECB"><a href="#电子密码本ECB" class="headerlink" title="电子密码本ECB"></a>电子密码本ECB</h4><h5 id="Ci-Ek-Pi"><a href="#Ci-Ek-Pi" class="headerlink" title="Ci=Ek[Pi]"></a>Ci=Ek[Pi]</h5><h5 id="明文划分为w比特的明文分组，最后一个分组视情况填充，每个分组相同密钥加密"><a href="#明文划分为w比特的明文分组，最后一个分组视情况填充，每个分组相同密钥加密" class="headerlink" title="明文划分为w比特的明文分组，最后一个分组视情况填充，每个分组相同密钥加密"></a>明文划分为w比特的明文分组，最后一个分组视情况填充，每个分组相同密钥加密</h5><h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><h6 id="相同的明文分组产生相同的密文分组"><a href="#相同的明文分组产生相同的密文分组" class="headerlink" title="相同的明文分组产生相同的密文分组"></a>相同的明文分组产生相同的密文分组</h6><h6 id="由于明文加密过程和密文无关，因此可以并行加密处理，获得很高的加密速度"><a href="#由于明文加密过程和密文无关，因此可以并行加密处理，获得很高的加密速度" class="headerlink" title="由于明文加密过程和密文无关，因此可以并行加密处理，获得很高的加密速度"></a>由于明文加密过程和密文无关，因此可以并行加密处理，获得很高的加密速度</h6><h4 id="密文分组链接CBC"><a href="#密文分组链接CBC" class="headerlink" title="密文分组链接CBC"></a>密文分组链接CBC</h4><h5 id="Ci-Ek-Ci-1-异或-Pi"><a href="#Ci-Ek-Ci-1-异或-Pi" class="headerlink" title="Ci=Ek[Ci-1 异或 Pi]"></a>Ci=Ek[Ci-1 异或 Pi]</h5><h5 id="当前明文和上一次输出的密文分组异或，然后加密算法处理"><a href="#当前明文和上一次输出的密文分组异或，然后加密算法处理" class="headerlink" title="当前明文和上一次输出的密文分组异或，然后加密算法处理"></a>当前明文和上一次输出的密文分组异或，然后加密算法处理</h5><h5 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h5><h6 id="相同的明文分组产生不同的密文分组"><a href="#相同的明文分组产生不同的密文分组" class="headerlink" title="相同的明文分组产生不同的密文分组"></a>相同的明文分组产生不同的密文分组</h6><h6 id="适用于大量信息和高结构化信息的加密传输"><a href="#适用于大量信息和高结构化信息的加密传输" class="headerlink" title="适用于大量信息和高结构化信息的加密传输"></a>适用于大量信息和高结构化信息的加密传输</h6><h4 id="密文反馈模式CFB"><a href="#密文反馈模式CFB" class="headerlink" title="密文反馈模式CFB"></a>密文反馈模式CFB</h4><h5 id="能将任意分组密码转换为流密码，本质是利用分组加密模块产生密钥流（注意——解密时使用的也是加密函数）"><a href="#能将任意分组密码转换为流密码，本质是利用分组加密模块产生密钥流（注意——解密时使用的也是加密函数）" class="headerlink" title="能将任意分组密码转换为流密码，本质是利用分组加密模块产生密钥流（注意——解密时使用的也是加密函数）"></a>能将任意分组密码转换为流密码，本质是利用分组加密模块产生密钥流（注意——解密时使用的也是加密函数）</h5><h5 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h5><h6 id="CFB中与明文异或的密钥流和密文相关"><a href="#CFB中与明文异或的密钥流和密文相关" class="headerlink" title="CFB中与明文异或的密钥流和密文相关"></a>CFB中与明文异或的密钥流和密文相关</h6><h6 id="若传输中密文出错，会造成解密错误"><a href="#若传输中密文出错，会造成解密错误" class="headerlink" title="若传输中密文出错，会造成解密错误"></a>若传输中密文出错，会造成解密错误</h6><h6 id="由于错误码在被移出移位寄存器之前被多次使用，所以一个密文单元出错，会造成连续w-h个解密明文的错误"><a href="#由于错误码在被移出移位寄存器之前被多次使用，所以一个密文单元出错，会造成连续w-h个解密明文的错误" class="headerlink" title="由于错误码在被移出移位寄存器之前被多次使用，所以一个密文单元出错，会造成连续w/h个解密明文的错误"></a>由于错误码在被移出移位寄存器之前被多次使用，所以一个密文单元出错，会造成连续w/h个解密明文的错误</h6><h4 id="输出反馈模式OFB"><a href="#输出反馈模式OFB" class="headerlink" title="输出反馈模式OFB"></a>输出反馈模式OFB</h4><h5 id="能将分组密码转换为流密码，和CFB相似，但CFB是反馈密文单元，OFB是反馈加密函数的输出反馈（注意——解密时使用的也是加密函数）"><a href="#能将分组密码转换为流密码，和CFB相似，但CFB是反馈密文单元，OFB是反馈加密函数的输出反馈（注意——解密时使用的也是加密函数）" class="headerlink" title="能将分组密码转换为流密码，和CFB相似，但CFB是反馈密文单元，OFB是反馈加密函数的输出反馈（注意——解密时使用的也是加密函数）"></a>能将分组密码转换为流密码，和CFB相似，但CFB是反馈密文单元，OFB是反馈加密函数的输出反馈（注意——解密时使用的也是加密函数）</h5><h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>传输中的比特差错不会传播</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>比CFB更容易受到报文流篡改攻击</p>
<h6 id="具有典型的流密码结构"><a href="#具有典型的流密码结构" class="headerlink" title="具有典型的流密码结构"></a>具有典型的流密码结构</h6><h4 id="计数器模式CTR"><a href="#计数器模式CTR" class="headerlink" title="计数器模式CTR"></a>计数器模式CTR</h4><h5 id="使用和明文分组等长的计数器，在加密不同的明文分组时该计数器的值不同"><a href="#使用和明文分组等长的计数器，在加密不同的明文分组时该计数器的值不同" class="headerlink" title="使用和明文分组等长的计数器，在加密不同的明文分组时该计数器的值不同"></a>使用和明文分组等长的计数器，在加密不同的明文分组时该计数器的值不同</h5><h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><h6 id="对报文分组时无需对明文进行填充"><a href="#对报文分组时无需对明文进行填充" class="headerlink" title="对报文分组时无需对明文进行填充"></a>对报文分组时无需对明文进行填充</h6><h6 id="初始计数器必须是时变的，即所有使用相同密钥加密的所有报文必须使用不同的初始计数器值，且Ti值也必须唯一"><a href="#初始计数器必须是时变的，即所有使用相同密钥加密的所有报文必须使用不同的初始计数器值，且Ti值也必须唯一" class="headerlink" title="初始计数器必须是时变的，即所有使用相同密钥加密的所有报文必须使用不同的初始计数器值，且Ti值也必须唯一"></a>初始计数器必须是时变的，即所有使用相同密钥加密的所有报文必须使用不同的初始计数器值，且Ti值也必须唯一</h6><h2 id="4-3-4-3-数据加密标准DES"><a href="#4-3-4-3-数据加密标准DES" class="headerlink" title="4.3.     4.3 数据加密标准DES"></a>4.3.     4.3 数据加密标准DES</h2><h3 id="4-3-1-使用最广泛的常规加密体制"><a href="#4-3-1-使用最广泛的常规加密体制" class="headerlink" title="4.3.1.     使用最广泛的常规加密体制"></a>4.3.1.     使用最广泛的常规加密体制</h3><h3 id="4-3-2-DES加密与解密"><a href="#4-3-2-DES加密与解密" class="headerlink" title="4.3.2.     DES加密与解密"></a>4.3.2.     DES加密与解密</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="严格的Feistel结构，以明文分组和密钥作为输入"><a href="#严格的Feistel结构，以明文分组和密钥作为输入" class="headerlink" title="严格的Feistel结构，以明文分组和密钥作为输入"></a>严格的Feistel结构，以明文分组和密钥作为输入</h5><h5 id="明文长度——64bit"><a href="#明文长度——64bit" class="headerlink" title="明文长度——64bit"></a>明文长度——64bit</h5><h5 id="密钥长度——56bit"><a href="#密钥长度——56bit" class="headerlink" title="密钥长度——56bit"></a>密钥长度——56bit</h5><h5 id="16轮循环"><a href="#16轮循环" class="headerlink" title="16轮循环"></a>16轮循环</h5><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1、初始置换"><a href="#1、初始置换" class="headerlink" title="1、初始置换"></a>1、初始置换</h5><h5 id="2、16轮置换加迭代"><a href="#2、16轮置换加迭代" class="headerlink" title="2、16轮置换加迭代"></a>2、16轮置换加迭代</h5><h5 id="3、初始置换的逆置换"><a href="#3、初始置换的逆置换" class="headerlink" title="3、初始置换的逆置换"></a>3、初始置换的逆置换</h5><h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><h5 id="具有很强的雪崩效应"><a href="#具有很强的雪崩效应" class="headerlink" title="具有很强的雪崩效应"></a>具有很强的雪崩效应</h5><h5 id="雪崩效应：明文或密钥及其微小的变化都会引起密文发生大的改变"><a href="#雪崩效应：明文或密钥及其微小的变化都会引起密文发生大的改变" class="headerlink" title="雪崩效应：明文或密钥及其微小的变化都会引起密文发生大的改变"></a>雪崩效应：明文或密钥及其微小的变化都会引起密文发生大的改变</h5><h3 id="4-3-3-简化DES"><a href="#4-3-3-简化DES" class="headerlink" title="4.3.3.     简化DES"></a>4.3.3.     简化DES</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><h5 id="明文长度——8bit"><a href="#明文长度——8bit" class="headerlink" title="明文长度——8bit"></a>明文长度——8bit</h5><h5 id="密钥长度——10bit"><a href="#密钥长度——10bit" class="headerlink" title="密钥长度——10bit"></a>密钥长度——10bit</h5><h4 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h4><h3 id="4-3-4-替代方式"><a href="#4-3-4-替代方式" class="headerlink" title="4.3.4.     替代方式"></a>4.3.4.     替代方式</h3><h4 id="由于——DES算法的密钥长度只有56bits，比较脆弱需要替代算法"><a href="#由于——DES算法的密钥长度只有56bits，比较脆弱需要替代算法" class="headerlink" title="由于——DES算法的密钥长度只有56bits，比较脆弱需要替代算法"></a>由于——DES算法的密钥长度只有56bits，比较脆弱需要替代算法</h4><h4 id="DES算法多次加密"><a href="#DES算法多次加密" class="headerlink" title="DES算法多次加密"></a>DES算法多次加密</h4><h5 id="双重DES算法"><a href="#双重DES算法" class="headerlink" title="双重DES算法"></a>双重DES算法</h5><h6 id="概念：利用两个不同密钥对明文进行两次连续加密处理"><a href="#概念：利用两个不同密钥对明文进行两次连续加密处理" class="headerlink" title="概念：利用两个不同密钥对明文进行两次连续加密处理"></a>概念：利用两个不同密钥对明文进行两次连续加密处理</h6><h6 id="致命缺陷"><a href="#致命缺陷" class="headerlink" title="致命缺陷"></a>致命缺陷</h6><p>易受中途攻击</p>
<h5 id="三重DES算法"><a href="#三重DES算法" class="headerlink" title="三重DES算法"></a>三重DES算法</h5><h6 id="对付中途攻击的最好办法：使用三个密钥进行加密"><a href="#对付中途攻击的最好办法：使用三个密钥进行加密" class="headerlink" title="对付中途攻击的最好办法：使用三个密钥进行加密"></a>对付中途攻击的最好办法：使用三个密钥进行加密</h6><h6 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h6><p>双密钥三重DES</p>
<p>概念：利用两个不同密钥对明文进行三次连续加密处理，第一次和第三次加密密钥相同</p>
<p>方案</p>
<p>DES-EEE2</p>
<p>加加加密——解解解密</p>
<p>DES-EDE2</p>
<p>加解加密——解加解密</p>
<p>DES-EDE2优点在于可以解密原来单次DES所加密的数据，K1=K2时</p>
<p>密钥长度112</p>
<p>三密钥三重算法</p>
<p>概念：利用三个不同密钥对明文进行三次连续加密处理</p>
<p>方案</p>
<p>DES-EEE3</p>
<p>加加加密——解解解密</p>
<p>DES-EDE3</p>
<p>加解加密——解加解密</p>
<p>DES-EDE3优点在于可以解密原来单次DES所加密的数据，K1=K2=K3时</p>
<p>密钥长度168</p>
<h4 id="设计新的算法"><a href="#设计新的算法" class="headerlink" title="设计新的算法"></a>设计新的算法</h4><h5 id="高级加密标准AES"><a href="#高级加密标准AES" class="headerlink" title="高级加密标准AES"></a>高级加密标准AES</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>特点</p>
<p>分组长度128</p>
<p>密钥长度可变—128/192/256</p>
<p>根据密钥长度不同，AES分别被称为AES-128，AES-192，AES-256</p>
<p>状态：</p>
<p>AES算法明文分组需要多次变化，操作的中间结果叫做状态</p>
<p>4*4的字节方阵</p>
<p>密钥</p>
<p>4*Nk的字节方阵</p>
<p>Nk=密钥长度/32</p>
<p>循环轮数Nr</p>
<p>Nr和Nk的关系，Nr=Nk+6</p>
<p>轮函数：由4个不同的可逆均匀变换组成，在每轮替换和移位时并行处理整个数据分组</p>
<h6 id="轮循环"><a href="#轮循环" class="headerlink" title="轮循环"></a>轮循环</h6><p>字节替代</p>
<p>逆字节替代</p>
<p>移行</p>
<p>逆移行</p>
<p>混列</p>
<p>逆混列</p>
<p>加轮密钥</p>
<p>加轮密钥（逆变换即其本身）</p>
<h6 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h6><p>w[i]的值依赖于w[i-1] 和w[i-4]</p>
<h5 id="RC5算法"><a href="#RC5算法" class="headerlink" title="RC5算法"></a>RC5算法</h5><h6 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h6><p>一种快速的参数化分组密码算法</p>
<h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>参数</p>
<p>字长w</p>
<p>取值：16、32、64</p>
<p>单位:bit</p>
<p>分组2w：32、64、128</p>
<p>循环轮数r</p>
<p>取值：[0~255]</p>
<p>密钥长度b</p>
<p>取值：[0~255]</p>
<p>单位：字节B</p>
<p>RC5-32/16/16建议RC5-w/r/b</p>
<p>强度</p>
<p>分组长度越长</p>
<p>循环轮数越多</p>
<p>密钥长度越长</p>
<p>但选择合适的循环轮数和密钥长度需要在安全性和计算速度之间进行均衡考量</p>
<h6 id="运算步骤及相关"><a href="#运算步骤及相关" class="headerlink" title="运算步骤及相关"></a>运算步骤及相关</h6><p>运算</p>
<p>按位异或</p>
<p>加法/减法</p>
<p>模2w加法用于加密，记为+；</p>
<p>模2w减法用于解密，记为-</p>
<p>循环移位</p>
<p>左移加密</p>
<p>右移解密</p>
<p>RC5算法包括加密、解密、密钥扩展三个部分</p>
<p>子密钥个数</p>
<p>和循环轮数r相关</p>
<p>令2w表示分组长度，则RC5算法需要2r+2个子密钥，表示为数组S[2r+2],每个子密钥的长度为比特</p>
<h6 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h6><p>简单、加密速度快，便于软件和硬件实现，可变的参数使得RC5安全性较高</p>
<h5 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h5><h6 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h6><p>一种分组加密算法</p>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>分组128bit</p>
<p>密钥128bit</p>
<p>循环32轮，以32位字单位进行加密运算</p>
<h6 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h6><p>32bit异或</p>
<p>32bit循环左移</p>
<h1 id="5-5-非对称密码"><a href="#5-5-非对称密码" class="headerlink" title="5.    5 非对称密码"></a>5.    5 非对称密码</h1><h2 id="5-1-5-1-概述"><a href="#5-1-5-1-概述" class="headerlink" title="5.1.     5.1 概述"></a>5.1.     5.1 概述</h2><h3 id="5-1-1-又称"><a href="#5-1-1-又称" class="headerlink" title="5.1.1.     又称"></a>5.1.1.     又称</h3><h4 id="公钥密码或双密钥密码"><a href="#公钥密码或双密钥密码" class="headerlink" title="公钥密码或双密钥密码"></a>公钥密码或双密钥密码</h4><h3 id="5-1-2-与对称密码的比较"><a href="#5-1-2-与对称密码的比较" class="headerlink" title="5.1.2.     与对称密码的比较"></a>5.1.2.     与对称密码的比较</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h5 id="常规加密"><a href="#常规加密" class="headerlink" title="常规加密"></a>常规加密</h5><h6 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h6><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><h5 id="同一密钥"><a href="#同一密钥" class="headerlink" title="同一密钥"></a>同一密钥</h5><h6 id="不同但相关密钥"><a href="#不同但相关密钥" class="headerlink" title="不同但相关密钥"></a>不同但相关密钥</h6><h4 id="安全条件"><a href="#安全条件" class="headerlink" title="安全条件"></a>安全条件</h4><h5 id="密钥必须保密"><a href="#密钥必须保密" class="headerlink" title="密钥必须保密"></a>密钥必须保密</h5><h6 id="私钥保密"><a href="#私钥保密" class="headerlink" title="私钥保密"></a>私钥保密</h6><h4 id="加密速度"><a href="#加密速度" class="headerlink" title="加密速度"></a>加密速度</h4><h5 id="快"><a href="#快" class="headerlink" title="快"></a>快</h5><h6 id="慢"><a href="#慢" class="headerlink" title="慢"></a>慢</h6><h4 id="方便性"><a href="#方便性" class="headerlink" title="方便性"></a>方便性</h4><h5 id="密钥分配不便"><a href="#密钥分配不便" class="headerlink" title="密钥分配不便"></a>密钥分配不便</h5><h6 id="密钥公开方便"><a href="#密钥公开方便" class="headerlink" title="密钥公开方便"></a>密钥公开方便</h6><h4 id="密钥数量"><a href="#密钥数量" class="headerlink" title="密钥数量"></a>密钥数量</h4><h5 id="N（N-1）-2"><a href="#N（N-1）-2" class="headerlink" title="N（N-1）/2"></a>N（N-1）/2</h5><h6 id="2N"><a href="#2N" class="headerlink" title="2N"></a>2N</h6><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="加密-3"><a href="#加密-3" class="headerlink" title="加密"></a>加密</h5><h6 id="加密、数字签名、密钥分配"><a href="#加密、数字签名、密钥分配" class="headerlink" title="加密、数字签名、密钥分配"></a>加密、数字签名、密钥分配</h6><h3 id="5-1-3-特点"><a href="#5-1-3-特点" class="headerlink" title="5.1.3.     特点"></a>5.1.3.     特点</h3><h4 id="非对称密码是基于数学函数而不是替代和置换的。"><a href="#非对称密码是基于数学函数而不是替代和置换的。" class="headerlink" title="非对称密码是基于数学函数而不是替代和置换的。"></a>非对称密码是基于数学函数而不是替代和置换的。</h4><h4 id="非对称密码体制中的密钥是非对称的，它使用两个不同的密钥，这影响保密通信、密钥分配和鉴别"><a href="#非对称密码体制中的密钥是非对称的，它使用两个不同的密钥，这影响保密通信、密钥分配和鉴别" class="headerlink" title="非对称密码体制中的密钥是非对称的，它使用两个不同的密钥，这影响保密通信、密钥分配和鉴别"></a>非对称密码体制中的密钥是非对称的，它使用两个不同的密钥，这影响保密通信、密钥分配和鉴别</h4><h4 id="非对称密码成功地解决了计算机网络安全中的身份鉴别、数字签名等问题"><a href="#非对称密码成功地解决了计算机网络安全中的身份鉴别、数字签名等问题" class="headerlink" title="非对称密码成功地解决了计算机网络安全中的身份鉴别、数字签名等问题"></a>非对称密码成功地解决了计算机网络安全中的身份鉴别、数字签名等问题</h4><h4 id="使密钥管理变得容易。"><a href="#使密钥管理变得容易。" class="headerlink" title="使密钥管理变得容易。"></a>使密钥管理变得容易。</h4><h4 id="非对称密码的加密和解密较对称密码体制慢。"><a href="#非对称密码的加密和解密较对称密码体制慢。" class="headerlink" title="非对称密码的加密和解密较对称密码体制慢。"></a>非对称密码的加密和解密较对称密码体制慢。</h4><h2 id="5-2-5-2-基本原理"><a href="#5-2-5-2-基本原理" class="headerlink" title="5.2.     5.2 基本原理"></a>5.2.     5.2 基本原理</h2><h3 id="5-2-1-特点"><a href="#5-2-1-特点" class="headerlink" title="5.2.1.     特点"></a>5.2.1.     特点</h3><h4 id="使用了两个不同但相关的密钥分别用于实现互逆运算，即加密和解密，其中一个密钥公开，叫做公钥"><a href="#使用了两个不同但相关的密钥分别用于实现互逆运算，即加密和解密，其中一个密钥公开，叫做公钥" class="headerlink" title="使用了两个不同但相关的密钥分别用于实现互逆运算，即加密和解密，其中一个密钥公开，叫做公钥"></a>使用了两个不同但相关的密钥分别用于实现互逆运算，即加密和解密，其中一个密钥公开，叫做公钥</h4><h3 id="5-2-2-应用"><a href="#5-2-2-应用" class="headerlink" title="5.2.2.     应用"></a>5.2.2.     应用</h3><h4 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><h6 id="PPT22左"><a href="#PPT22左" class="headerlink" title="PPT22左"></a>PPT22左</h6><h5 id="在用于加密-解密时，发送方使用接收方公钥加密消息，接收方使用私钥解密消息；"><a href="#在用于加密-解密时，发送方使用接收方公钥加密消息，接收方使用私钥解密消息；" class="headerlink" title="在用于加密/解密时，发送方使用接收方公钥加密消息，接收方使用私钥解密消息；"></a>在用于加密/解密时，发送方使用接收方公钥加密消息，接收方使用私钥解密消息；</h5><h4 id="数字签名-4"><a href="#数字签名-4" class="headerlink" title="数字签名"></a>数字签名</h4><h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><h6 id="PPT22左-1"><a href="#PPT22左-1" class="headerlink" title="PPT22左"></a>PPT22左</h6><h5 id="在用于数字签名时，发送方使用私钥加密消息，而接收方使用发送方的公钥来解密消息，验证签名。"><a href="#在用于数字签名时，发送方使用私钥加密消息，而接收方使用发送方的公钥来解密消息，验证签名。" class="headerlink" title="在用于数字签名时，发送方使用私钥加密消息，而接收方使用发送方的公钥来解密消息，验证签名。"></a>在用于数字签名时，发送方使用私钥加密消息，而接收方使用发送方的公钥来解密消息，验证签名。</h5><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><h3 id="5-2-3-系统构成"><a href="#5-2-3-系统构成" class="headerlink" title="5.2.3.     系统构成"></a>5.2.3.     系统构成</h3><h4 id="明文M密文C、公钥KU、私钥KR、加解密算法E-D"><a href="#明文M密文C、公钥KU、私钥KR、加解密算法E-D" class="headerlink" title="明文M密文C、公钥KU、私钥KR、加解密算法E/D"></a>明文M密文C、公钥KU、私钥KR、加解密算法E/D</h4><h3 id="5-2-4-双重加密"><a href="#5-2-4-双重加密" class="headerlink" title="5.2.4.     双重加密"></a>5.2.4.     双重加密</h3><h4 id="同时提供机密性和认证功能"><a href="#同时提供机密性和认证功能" class="headerlink" title="同时提供机密性和认证功能"></a>同时提供机密性和认证功能</h4><h3 id="5-2-5-公钥密码算法需满足的要求"><a href="#5-2-5-公钥密码算法需满足的要求" class="headerlink" title="5.2.5.     公钥密码算法需满足的要求"></a>5.2.5.     公钥密码算法需满足的要求</h3><h4 id="PPT22"><a href="#PPT22" class="headerlink" title="PPT22"></a>PPT22</h4><h5 id="通信双方生成密钥对容易"><a href="#通信双方生成密钥对容易" class="headerlink" title="通信双方生成密钥对容易"></a>通信双方生成密钥对容易</h5><h5 id="已知接收方B的公钥KUB和待加密的消息M，发送方A生成相应的密文C在计算上是容易的："><a href="#已知接收方B的公钥KUB和待加密的消息M，发送方A生成相应的密文C在计算上是容易的：" class="headerlink" title="已知接收方B的公钥KUB和待加密的消息M，发送方A生成相应的密文C在计算上是容易的："></a>已知接收方B的公钥KUB和待加密的消息M，发送方A生成相应的密文C在计算上是容易的：</h5><h5 id="接收方B使用其私钥KRB解密密文C以恢复明文M时，在计算上是容易的："><a href="#接收方B使用其私钥KRB解密密文C以恢复明文M时，在计算上是容易的：" class="headerlink" title="接收方B使用其私钥KRB解密密文C以恢复明文M时，在计算上是容易的："></a>接收方B使用其私钥KRB解密密文C以恢复明文M时，在计算上是容易的：</h5><h5 id="攻击者已知公钥KUB，试图推导出私钥KRB，在计算上是不可行的。"><a href="#攻击者已知公钥KUB，试图推导出私钥KRB，在计算上是不可行的。" class="headerlink" title="攻击者已知公钥KUB，试图推导出私钥KRB，在计算上是不可行的。"></a>攻击者已知公钥KUB，试图推导出私钥KRB，在计算上是不可行的。</h5><h5 id="攻击者已知公钥KUB和密文C，试图推导出明文M，在计算上是不可行的。"><a href="#攻击者已知公钥KUB和密文C，试图推导出明文M，在计算上是不可行的。" class="headerlink" title="攻击者已知公钥KUB和密文C，试图推导出明文M，在计算上是不可行的。"></a>攻击者已知公钥KUB和密文C，试图推导出明文M，在计算上是不可行的。</h5><h5 id="加密变换和解密变换是互逆的，且可以以任意顺序使用："><a href="#加密变换和解密变换是互逆的，且可以以任意顺序使用：" class="headerlink" title="加密变换和解密变换是互逆的，且可以以任意顺序使用："></a>加密变换和解密变换是互逆的，且可以以任意顺序使用：</h5><h4 id="陷门单向函数"><a href="#陷门单向函数" class="headerlink" title="陷门单向函数"></a>陷门单向函数</h4><h5 id="陷门就是私钥"><a href="#陷门就是私钥" class="headerlink" title="陷门就是私钥"></a>陷门就是私钥</h5><h5 id="称一个函数是陷门单向函数，是指该函数是易于计算的，但求它的逆是不可行的，除非知道某些附加信息（陷门）。当附加信息给定后，求逆可以在多项式时间完成。"><a href="#称一个函数是陷门单向函数，是指该函数是易于计算的，但求它的逆是不可行的，除非知道某些附加信息（陷门）。当附加信息给定后，求逆可以在多项式时间完成。" class="headerlink" title="称一个函数是陷门单向函数，是指该函数是易于计算的，但求它的逆是不可行的，除非知道某些附加信息（陷门）。当附加信息给定后，求逆可以在多项式时间完成。"></a>称一个函数是陷门单向函数，是指该函数是易于计算的，但求它的逆是不可行的，除非知道某些附加信息（陷门）。当附加信息给定后，求逆可以在多项式时间完成。</h5><h3 id="5-2-6-非对称密码体制的应用"><a href="#5-2-6-非对称密码体制的应用" class="headerlink" title="5.2.6.     非对称密码体制的应用"></a>5.2.6.     非对称密码体制的应用</h3><h4 id="1、加密-解密：发送方使用接收方的公钥对消息进行加密，接收方使用自己的私钥对消息进行解密。"><a href="#1、加密-解密：发送方使用接收方的公钥对消息进行加密，接收方使用自己的私钥对消息进行解密。" class="headerlink" title="1、加密/解密：发送方使用接收方的公钥对消息进行加密，接收方使用自己的私钥对消息进行解密。"></a>1、加密/解密：发送方使用接收方的公钥对消息进行加密，接收方使用自己的私钥对消息进行解密。</h4><h4 id="2、数字签名：发送方使用自己的私钥对消息或鉴别符进行签名。其中，签名是通过对整个消息或对整个消息进行计算形成的鉴别符进行加密产生的。"><a href="#2、数字签名：发送方使用自己的私钥对消息或鉴别符进行签名。其中，签名是通过对整个消息或对整个消息进行计算形成的鉴别符进行加密产生的。" class="headerlink" title="2、数字签名：发送方使用自己的私钥对消息或鉴别符进行签名。其中，签名是通过对整个消息或对整个消息进行计算形成的鉴别符进行加密产生的。"></a>2、数字签名：发送方使用自己的私钥对消息或鉴别符进行签名。其中，签名是通过对整个消息或对整个消息进行计算形成的鉴别符进行加密产生的。</h4><h4 id="3、密钥交换：通信双方合作以交换会话密钥。有多种方法可以用于交换密钥，且在密钥交换过程中使用了非对称密码体制。"><a href="#3、密钥交换：通信双方合作以交换会话密钥。有多种方法可以用于交换密钥，且在密钥交换过程中使用了非对称密码体制。" class="headerlink" title="3、密钥交换：通信双方合作以交换会话密钥。有多种方法可以用于交换密钥，且在密钥交换过程中使用了非对称密码体制。"></a>3、密钥交换：通信双方合作以交换会话密钥。有多种方法可以用于交换密钥，且在密钥交换过程中使用了非对称密码体制。</h4><h3 id="5-2-7-各种l流行的公钥算法支持的应用范围"><a href="#5-2-7-各种l流行的公钥算法支持的应用范围" class="headerlink" title="5.2.7.     各种l流行的公钥算法支持的应用范围"></a>5.2.7.     各种l流行的公钥算法支持的应用范围</h3><h4 id="PPT22-右下表格"><a href="#PPT22-右下表格" class="headerlink" title="PPT22 右下表格"></a>PPT22 右下表格</h4><h2 id="5-3-5-3-RSA密码体制"><a href="#5-3-5-3-RSA密码体制" class="headerlink" title="5.3.     5.3 RSA密码体制"></a>5.3.     5.3 RSA密码体制</h2><h3 id="5-3-1-分成三个部分"><a href="#5-3-1-分成三个部分" class="headerlink" title="5.3.1.     分成三个部分"></a>5.3.1.     分成三个部分</h3><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><h4 id="加密-4"><a href="#加密-4" class="headerlink" title="加密"></a>加密</h4><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><h4 id="看ppt-23"><a href="#看ppt-23" class="headerlink" title="看ppt-23"></a>看ppt-23</h4><h3 id="5-3-2-安全性基于大整数分子分解的困难性"><a href="#5-3-2-安全性基于大整数分子分解的困难性" class="headerlink" title="5.3.2.     安全性基于大整数分子分解的困难性"></a>5.3.2.     安全性基于大整数分子分解的困难性</h3><h2 id="5-4-5-4-Diffie-Hellman密钥交换"><a href="#5-4-5-4-Diffie-Hellman密钥交换" class="headerlink" title="5.4.     5.4 Diffie-Hellman密钥交换"></a>5.4.     5.4 Diffie-Hellman密钥交换</h2><h3 id="5-4-1-算法"><a href="#5-4-1-算法" class="headerlink" title="5.4.1.     算法"></a>5.4.1.     算法</h3><h4 id="安全性源于在有限域上计算离散对数的困难性"><a href="#安全性源于在有限域上计算离散对数的困难性" class="headerlink" title="安全性源于在有限域上计算离散对数的困难性"></a>安全性源于在有限域上计算离散对数的困难性</h4><h4 id="算法本身仅限于密钥交换，不用于加密-解密和数字签名"><a href="#算法本身仅限于密钥交换，不用于加密-解密和数字签名" class="headerlink" title="算法本身仅限于密钥交换，不用于加密/解密和数字签名"></a>算法本身仅限于密钥交换，不用于加密/解密和数字签名</h4><h3 id="5-4-2-计算过程"><a href="#5-4-2-计算过程" class="headerlink" title="5.4.2.     计算过程"></a>5.4.2.     计算过程</h3><h4 id="PPT-25"><a href="#PPT-25" class="headerlink" title="PPT-25"></a>PPT-25</h4><h3 id="5-4-3-攻击过程"><a href="#5-4-3-攻击过程" class="headerlink" title="5.4.3.     攻击过程"></a>5.4.3.     攻击过程</h3><h4 id="PPT-25-1"><a href="#PPT-25-1" class="headerlink" title="PPT-25"></a>PPT-25</h4><h4 id="是由于未对通信双方的身份进行身份鉴别"><a href="#是由于未对通信双方的身份进行身份鉴别" class="headerlink" title="是由于未对通信双方的身份进行身份鉴别"></a>是由于未对通信双方的身份进行身份鉴别</h4><h4 id="解决方法：数字签名或者公钥证书"><a href="#解决方法：数字签名或者公钥证书" class="headerlink" title="解决方法：数字签名或者公钥证书"></a>解决方法：数字签名或者公钥证书</h4><h2 id="5-5-5-5-ElGamal密钥体制"><a href="#5-5-5-5-ElGamal密钥体制" class="headerlink" title="5.5.     5.5 ElGamal密钥体制"></a>5.5.     5.5 ElGamal密钥体制</h2><h3 id="5-5-1-安全性依赖于计算有限域上离散对数的难度（和5-4-Diffie-Hellman密钥交换相同）"><a href="#5-5-1-安全性依赖于计算有限域上离散对数的难度（和5-4-Diffie-Hellman密钥交换相同）" class="headerlink" title="5.5.1.     安全性依赖于计算有限域上离散对数的难度（和5.4 Diffie-Hellman密钥交换相同）"></a>5.5.1.     安全性依赖于计算有限域上离散对数的难度（和5.4 Diffie-Hellman密钥交换相同）</h3><h3 id="5-5-2-不用于密钥交换，只用于加密和数字签名"><a href="#5-5-2-不用于密钥交换，只用于加密和数字签名" class="headerlink" title="5.5.2.     不用于密钥交换，只用于加密和数字签名"></a>5.5.2.     不用于密钥交换，只用于加密和数字签名</h3><h2 id="5-6-5-3-椭圆曲线体制ECC优点"><a href="#5-6-5-3-椭圆曲线体制ECC优点" class="headerlink" title="5.6.     5.3 椭圆曲线体制ECC优点"></a>5.6.     5.3 椭圆曲线体制ECC优点</h2><h3 id="5-6-1-ECC使用的密钥长度要比RSA的密钥长度短得多"><a href="#5-6-1-ECC使用的密钥长度要比RSA的密钥长度短得多" class="headerlink" title="5.6.1.     ECC使用的密钥长度要比RSA的密钥长度短得多"></a>5.6.1.     ECC使用的密钥长度要比RSA的密钥长度短得多</h3><h3 id="5-6-2-在密钥长度相同时，RSA与ECC所指向的计算量差不多"><a href="#5-6-2-在密钥长度相同时，RSA与ECC所指向的计算量差不多" class="headerlink" title="5.6.2.     在密钥长度相同时，RSA与ECC所指向的计算量差不多"></a>5.6.2.     在密钥长度相同时，RSA与ECC所指向的计算量差不多</h3><h3 id="5-6-3-因此，同等安全性条件下，ECC密钥更短，因此所需要的计算量也比RSA少"><a href="#5-6-3-因此，同等安全性条件下，ECC密钥更短，因此所需要的计算量也比RSA少" class="headerlink" title="5.6.3.     因此，同等安全性条件下，ECC密钥更短，因此所需要的计算量也比RSA少"></a>5.6.3.     因此，同等安全性条件下，ECC密钥更短，因此所需要的计算量也比RSA少</h3><h1 id="6-6-数据完整性算法"><a href="#6-6-数据完整性算法" class="headerlink" title="6.    6 数据完整性算法"></a>6.    6 数据完整性算法</h1><h2 id="6-1-数据完整性可以确保收到的数据确实是授权实体发送的数据，并保护数据免受非法篡改。"><a href="#6-1-数据完整性可以确保收到的数据确实是授权实体发送的数据，并保护数据免受非法篡改。" class="headerlink" title="6.1.     数据完整性可以确保收到的数据确实是授权实体发送的数据，并保护数据免受非法篡改。"></a>6.1.     数据完整性可以确保收到的数据确实是授权实体发送的数据，并保护数据免受非法篡改。</h2><h2 id="6-2-6-1-散列函数"><a href="#6-2-6-1-散列函数" class="headerlink" title="6.2.     6.1 散列函数"></a>6.2.     6.1 散列函数</h2><h3 id="6-2-1-概念"><a href="#6-2-1-概念" class="headerlink" title="6.2.1.     概念"></a>6.2.1.     概念</h3><h4 id="散列函数对报文的所有比特进行计算产生散列值，因而具有差错检测能力。"><a href="#散列函数对报文的所有比特进行计算产生散列值，因而具有差错检测能力。" class="headerlink" title="散列函数对报文的所有比特进行计算产生散列值，因而具有差错检测能力。"></a>散列函数对报文的所有比特进行计算产生散列值，因而具有差错检测能力。</h4><h4 id="即，报文中任意一比特或若干比特发生变化都将导致散列值发生变化。"><a href="#即，报文中任意一比特或若干比特发生变化都将导致散列值发生变化。" class="headerlink" title="即，报文中任意一比特或若干比特发生变化都将导致散列值发生变化。"></a>即，报文中任意一比特或若干比特发生变化都将导致散列值发生变化。</h4><h3 id="6-2-2-用于"><a href="#6-2-2-用于" class="headerlink" title="6.2.2.     用于"></a>6.2.2.     用于</h3><h4 id="报文认证"><a href="#报文认证" class="headerlink" title="报文认证"></a>报文认证</h4><h4 id="数字签名-5"><a href="#数字签名-5" class="headerlink" title="数字签名"></a>数字签名</h4><h3 id="6-2-3-一般结构"><a href="#6-2-3-一般结构" class="headerlink" title="6.2.3.     一般结构"></a>6.2.3.     一般结构</h3><h4 id="迭代型"><a href="#迭代型" class="headerlink" title="迭代型"></a>迭代型</h4><h4 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h4><h5 id="散列算法的核心是设计无碰撞的压缩函数f，攻击重点是f的内部结构，分析的过程需要找出f的碰撞。"><a href="#散列算法的核心是设计无碰撞的压缩函数f，攻击重点是f的内部结构，分析的过程需要找出f的碰撞。" class="headerlink" title="散列算法的核心是设计无碰撞的压缩函数f，攻击重点是f的内部结构，分析的过程需要找出f的碰撞。"></a>散列算法的核心是设计无碰撞的压缩函数f，攻击重点是f的内部结构，分析的过程需要找出f的碰撞。</h5><h3 id="6-2-4-不同方式提供报文认证"><a href="#6-2-4-不同方式提供报文认证" class="headerlink" title="6.2.4.     不同方式提供报文认证"></a>6.2.4.     不同方式提供报文认证</h3><h4 id="使用对称加密方法对附加散列值的报文进行加密"><a href="#使用对称加密方法对附加散列值的报文进行加密" class="headerlink" title="使用对称加密方法对附加散列值的报文进行加密"></a>使用对称加密方法对附加散列值的报文进行加密</h4><h5 id="机密性-1"><a href="#机密性-1" class="headerlink" title="机密性"></a>机密性</h5><h5 id="认证-1"><a href="#认证-1" class="headerlink" title="认证"></a>认证</h5><h4 id="使用对称加密方法仅对散列值进行加密"><a href="#使用对称加密方法仅对散列值进行加密" class="headerlink" title="使用对称加密方法仅对散列值进行加密"></a>使用对称加密方法仅对散列值进行加密</h4><h5 id="认证-2"><a href="#认证-2" class="headerlink" title="认证"></a>认证</h5><h4 id="使用散列值、公共秘密值的明文方案"><a href="#使用散列值、公共秘密值的明文方案" class="headerlink" title="使用散列值、公共秘密值的明文方案"></a>使用散列值、公共秘密值的明文方案</h4><h5 id="认证-3"><a href="#认证-3" class="headerlink" title="认证"></a>认证</h5><h4 id="使用散列值、公共秘密值的密文方案"><a href="#使用散列值、公共秘密值的密文方案" class="headerlink" title="使用散列值、公共秘密值的密文方案"></a>使用散列值、公共秘密值的密文方案</h4><h5 id="机密性-2"><a href="#机密性-2" class="headerlink" title="机密性"></a>机密性</h5><h5 id="认证-4"><a href="#认证-4" class="headerlink" title="认证"></a>认证</h5><h3 id="6-2-5-不同方式提供数字签名"><a href="#6-2-5-不同方式提供数字签名" class="headerlink" title="6.2.5.     不同方式提供数字签名"></a>6.2.5.     不同方式提供数字签名</h3><h4 id="使用公钥加密体制及源端私钥仅对散列值进行加密"><a href="#使用公钥加密体制及源端私钥仅对散列值进行加密" class="headerlink" title="使用公钥加密体制及源端私钥仅对散列值进行加密"></a>使用公钥加密体制及源端私钥仅对散列值进行加密</h4><h5 id="认证-5"><a href="#认证-5" class="headerlink" title="认证"></a>认证</h5><h4 id="使用对称加密体制对报文和已使用公钥加密的散列值进行加密（1的基础上再对称加密）"><a href="#使用对称加密体制对报文和已使用公钥加密的散列值进行加密（1的基础上再对称加密）" class="headerlink" title="使用对称加密体制对报文和已使用公钥加密的散列值进行加密（1的基础上再对称加密）"></a>使用对称加密体制对报文和已使用公钥加密的散列值进行加密（1的基础上再对称加密）</h4><h5 id="机密性-3"><a href="#机密性-3" class="headerlink" title="机密性"></a>机密性</h5><h5 id="认证-6"><a href="#认证-6" class="headerlink" title="认证"></a>认证</h5><h3 id="6-2-6-散列函数H性质"><a href="#6-2-6-散列函数H性质" class="headerlink" title="6.2.6.     散列函数H性质"></a>6.2.6.     散列函数H性质</h3><h4 id="1、H能用于任意大小的数据分组；"><a href="#1、H能用于任意大小的数据分组；" class="headerlink" title="1、H能用于任意大小的数据分组；"></a>1、H能用于任意大小的数据分组；</h4><h4 id="2、H产生定长的输出；"><a href="#2、H产生定长的输出；" class="headerlink" title="2、H产生定长的输出；"></a>2、H产生定长的输出；</h4><h4 id="3、对任意给定的x，H-x-要相对易于计算，使得硬件和软件实现成为可能；"><a href="#3、对任意给定的x，H-x-要相对易于计算，使得硬件和软件实现成为可能；" class="headerlink" title="3、对任意给定的x，H(x)要相对易于计算，使得硬件和软件实现成为可能；"></a>3、对任意给定的x，H(x)要相对易于计算，使得硬件和软件实现成为可能；</h4><h4 id="4、H应具有单向性，即对任意给定的散列值h，寻找x使得H-x-h在计算上是不可行的；"><a href="#4、H应具有单向性，即对任意给定的散列值h，寻找x使得H-x-h在计算上是不可行的；" class="headerlink" title="4、H应具有单向性，即对任意给定的散列值h，寻找x使得H(x) = h在计算上是不可行的；"></a>4、H应具有单向性，即对任意给定的散列值h，寻找x使得H(x) = h在计算上是不可行的；</h4><h4 id="5、H应具有抗弱碰撞性，即对任意给定的分组x，寻找y≠x，使得H-y-H-x-在计算上是不可行的；"><a href="#5、H应具有抗弱碰撞性，即对任意给定的分组x，寻找y≠x，使得H-y-H-x-在计算上是不可行的；" class="headerlink" title="5、H应具有抗弱碰撞性，即对任意给定的分组x，寻找y≠x，使得H(y)=H(x)在计算上是不可行的；"></a>5、H应具有抗弱碰撞性，即对任意给定的分组x，寻找y≠x，使得H(y)=H(x)在计算上是不可行的；</h4><h4 id="6、H应具有抗强碰撞性，即寻找任意的-x-y-对，使得H-x-H-y-在计算上是不可行的。"><a href="#6、H应具有抗强碰撞性，即寻找任意的-x-y-对，使得H-x-H-y-在计算上是不可行的。" class="headerlink" title="6、H应具有抗强碰撞性，即寻找任意的(x, y)对，使得H(x)=H(y)在计算上是不可行的。"></a>6、H应具有抗强碰撞性，即寻找任意的(x, y)对，使得H(x)=H(y)在计算上是不可行的。</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="满足性质（1）至性质（5）的散列函数也称为单向散列函数或弱单向散列函数。"><a href="#满足性质（1）至性质（5）的散列函数也称为单向散列函数或弱单向散列函数。" class="headerlink" title="满足性质（1）至性质（5）的散列函数也称为单向散列函数或弱单向散列函数。"></a>满足性质（1）至性质（5）的散列函数也称为单向散列函数或弱单向散列函数。</h5><h5 id="若散列函数也满足性质（6），则称该散列函数为强单向散列函数。"><a href="#若散列函数也满足性质（6），则称该散列函数为强单向散列函数。" class="headerlink" title="若散列函数也满足性质（6），则称该散列函数为强单向散列函数。"></a>若散列函数也满足性质（6），则称该散列函数为强单向散列函数。</h5><h3 id="6-2-7-结论"><a href="#6-2-7-结论" class="headerlink" title="6.2.7.     结论"></a>6.2.7.     结论</h3><h4 id="特别地，如果散列函数H生成的散列值长度为m比特，可能存在2-m个散列值，则k个值H-y1-H-y2-…-H-yk-中至少有一个等于H-x-的概率为1-2的k值为2-m-1。"><a href="#特别地，如果散列函数H生成的散列值长度为m比特，可能存在2-m个散列值，则k个值H-y1-H-y2-…-H-yk-中至少有一个等于H-x-的概率为1-2的k值为2-m-1。" class="headerlink" title="特别地，如果散列函数H生成的散列值长度为m比特，可能存在2^m个散列值，则k个值H(y1), H(y2),…, H(yk)中至少有一个等于H(x)的概率为1/2的k值为2^m-1。"></a>特别地，如果散列函数H生成的散列值长度为m比特，可能存在2^m个散列值，则k个值H(y1), H(y2),…, H(yk)中至少有一个等于H(x)的概率为1/2的k值为2^m-1。</h4><h4 id="特别地，如果散列函数H生成的散列值长度为m比特，可能存在2-m个散列值，则k个值H-y1-H-y2-…-H-yk-中至少有两个相同的概率为1-2的k值为2-m-2。"><a href="#特别地，如果散列函数H生成的散列值长度为m比特，可能存在2-m个散列值，则k个值H-y1-H-y2-…-H-yk-中至少有两个相同的概率为1-2的k值为2-m-2。" class="headerlink" title="特别地，如果散列函数H生成的散列值长度为m比特，可能存在2^m个散列值，则k个值H(y1), H(y2),…, H(yk)中至少有两个相同的概率为1/2的k值为2^m/2。"></a>特别地，如果散列函数H生成的散列值长度为m比特，可能存在2^m个散列值，则k个值H(y1), H(y2),…, H(yk)中至少有两个相同的概率为1/2的k值为2^m/2。</h4><h3 id="6-2-8-算法"><a href="#6-2-8-算法" class="headerlink" title="6.2.8.     算法"></a>6.2.8.     算法</h3><h4 id="MD5报文摘要算法"><a href="#MD5报文摘要算法" class="headerlink" title="MD5报文摘要算法"></a>MD5报文摘要算法</h4><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><h6 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h6><p>任意长度</p>
<h6 id="报文摘要"><a href="#报文摘要" class="headerlink" title="报文摘要"></a>报文摘要</h6><p>128bit</p>
<h6 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h6><p>512bit</p>
<h5 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h5><h6 id="对报文进行填充"><a href="#对报文进行填充" class="headerlink" title="对报文进行填充"></a>对报文进行填充</h6><h6 id="附加报文的长度"><a href="#附加报文的长度" class="headerlink" title="附加报文的长度"></a>附加报文的长度</h6><p>小端对齐</p>
<h6 id="初始化MD缓存"><a href="#初始化MD缓存" class="headerlink" title="初始化MD缓存"></a>初始化MD缓存</h6><h6 id="处理512比特报文分组序列"><a href="#处理512比特报文分组序列" class="headerlink" title="处理512比特报文分组序列"></a>处理512比特报文分组序列</h6><h6 id="输出报文摘要"><a href="#输出报文摘要" class="headerlink" title="输出报文摘要"></a>输出报文摘要</h6><h5 id="每轮计算"><a href="#每轮计算" class="headerlink" title="每轮计算"></a>每轮计算</h5><h6 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h6><p>a ← b + CLSs(a + g(b, c, d) + X[k] + T[i])</p>
<h6 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h6><p>a,b,c,d为缓存的4个32比特字，运算完成后向右循环一个字，即得到该步迭代的输出；</p>
<p>g是基本逻辑函数F、G、H、I之一；</p>
<p>CLSs表示循环左移s位，s的取值参见循环移位表；</p>
<p>X[k]=M[q×16+k]，即报文第q个分组中的第k个32比特字，k=1, 2, …, 16；</p>
<p>T[i]为常量表T中的第i个字；</p>
<p>+为对应32比特字的模2^32加法</p>
<h5 id="4轮16步"><a href="#4轮16步" class="headerlink" title="4轮16步"></a>4轮16步</h5><h4 id="SHA安全散列算法"><a href="#SHA安全散列算法" class="headerlink" title="SHA安全散列算法"></a>SHA安全散列算法</h4><h5 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h5><h6 id="对报文进行填充-1"><a href="#对报文进行填充-1" class="headerlink" title="对报文进行填充"></a>对报文进行填充</h6><h6 id="附加报文的长度-1"><a href="#附加报文的长度-1" class="headerlink" title="附加报文的长度"></a>附加报文的长度</h6><p>大端对齐</p>
<h6 id="初始化缓存"><a href="#初始化缓存" class="headerlink" title="初始化缓存"></a>初始化缓存</h6><h6 id="处理1024比特报文分组序列"><a href="#处理1024比特报文分组序列" class="headerlink" title="处理1024比特报文分组序列"></a>处理1024比特报文分组序列</h6><h6 id="输出报文摘要-1"><a href="#输出报文摘要-1" class="headerlink" title="输出报文摘要"></a>输出报文摘要</h6><h5 id="80步"><a href="#80步" class="headerlink" title="80步"></a>80步</h5><h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><h6 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h6><p>&lt;=2^128</p>
<h6 id="报文摘要-1"><a href="#报文摘要-1" class="headerlink" title="报文摘要"></a>报文摘要</h6><p>512bit</p>
<h6 id="分组-1"><a href="#分组-1" class="headerlink" title="分组"></a>分组</h6><p>1024bit</p>
<h2 id="6-3-6-2-报文认证码MAC"><a href="#6-3-6-2-报文认证码MAC" class="headerlink" title="6.3.     6.2 报文认证码MAC"></a>6.3.     6.2 报文认证码MAC</h2><h3 id="6-3-1-报文认证"><a href="#6-3-1-报文认证" class="headerlink" title="6.3.1.     报文认证"></a>6.3.1.     报文认证</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><h5 id="报文认证是用于验证报文完整性的一种安全机制或服务。"><a href="#报文认证是用于验证报文完整性的一种安全机制或服务。" class="headerlink" title="报文认证是用于验证报文完整性的一种安全机制或服务。"></a>报文认证是用于验证报文完整性的一种安全机制或服务。</h5><h5 id="报文认证确保收到的信息在传输过程中未被篡改，且发送端声称的身份是真实有效的。"><a href="#报文认证确保收到的信息在传输过程中未被篡改，且发送端声称的身份是真实有效的。" class="headerlink" title="报文认证确保收到的信息在传输过程中未被篡改，且发送端声称的身份是真实有效的。"></a>报文认证确保收到的信息在传输过程中未被篡改，且发送端声称的身份是真实有效的。</h5><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><h5 id="报文认证与报文认证码"><a href="#报文认证与报文认证码" class="headerlink" title="报文认证与报文认证码"></a>报文认证与报文认证码</h5><h5 id="报文认证函数"><a href="#报文认证函数" class="headerlink" title="报文认证函数"></a>报文认证函数</h5><h5 id="基于散列函数的报文认证码HMAC"><a href="#基于散列函数的报文认证码HMAC" class="headerlink" title="基于散列函数的报文认证码HMAC"></a>基于散列函数的报文认证码HMAC</h5><h5 id="基于分组密码的报文认证码CMAC"><a href="#基于分组密码的报文认证码CMAC" class="headerlink" title="基于分组密码的报文认证码CMAC"></a>基于分组密码的报文认证码CMAC</h5><h3 id="6-3-2-报文认证与报文认证码"><a href="#6-3-2-报文认证与报文认证码" class="headerlink" title="6.3.2.     报文认证与报文认证码"></a>6.3.2.     报文认证与报文认证码</h3><h4 id="网络攻击形式"><a href="#网络攻击形式" class="headerlink" title="网络攻击形式"></a>网络攻击形式</h4><h5 id="被动攻击-1"><a href="#被动攻击-1" class="headerlink" title="被动攻击"></a>被动攻击</h5><h6 id="1、消息析取"><a href="#1、消息析取" class="headerlink" title="1、消息析取"></a>1、消息析取</h6><h6 id="2、通信量分析"><a href="#2、通信量分析" class="headerlink" title="2、通信量分析"></a>2、通信量分析</h6><h5 id="主动攻击-1"><a href="#主动攻击-1" class="headerlink" title="主动攻击"></a>主动攻击</h5><h6 id="3、伪装"><a href="#3、伪装" class="headerlink" title="3、伪装"></a>3、伪装</h6><h6 id="篡改"><a href="#篡改" class="headerlink" title="篡改"></a>篡改</h6><p>4、内容篡改</p>
<p>5、序号篡改</p>
<p>6、计时篡改</p>
<h6 id="7、抵赖"><a href="#7、抵赖" class="headerlink" title="7、抵赖"></a>7、抵赖</h6><h4 id="对付方法"><a href="#对付方法" class="headerlink" title="对付方法"></a>对付方法</h4><h5 id="对付第（1）（2）类攻击的措施是加强报文的保密性，即加密与流量填充。"><a href="#对付第（1）（2）类攻击的措施是加强报文的保密性，即加密与流量填充。" class="headerlink" title="对付第（1）（2）类攻击的措施是加强报文的保密性，即加密与流量填充。"></a>对付第（1）（2）类攻击的措施是加强报文的保密性，即加密与流量填充。</h5><h5 id="对付第（3）（4）（5）（6）类攻击的措施是报文认证。"><a href="#对付第（3）（4）（5）（6）类攻击的措施是报文认证。" class="headerlink" title="对付第（3）（4）（5）（6）类攻击的措施是报文认证。"></a>对付第（3）（4）（5）（6）类攻击的措施是报文认证。</h5><h5 id="对付第（7）类攻击的措施是数字签名，一般地，数字签名也能够对付第（3）～（6）类攻击。"><a href="#对付第（7）类攻击的措施是数字签名，一般地，数字签名也能够对付第（3）～（6）类攻击。" class="headerlink" title="对付第（7）类攻击的措施是数字签名，一般地，数字签名也能够对付第（3）～（6）类攻击。"></a>对付第（7）类攻击的措施是数字签名，一般地，数字签名也能够对付第（3）～（6）类攻击。</h5><h4 id="报文认证码和散列函数的区别："><a href="#报文认证码和散列函数的区别：" class="headerlink" title="报文认证码和散列函数的区别："></a>报文认证码和散列函数的区别：</h4><h5 id="散列函数不使用密钥"><a href="#散列函数不使用密钥" class="headerlink" title="散列函数不使用密钥"></a>散列函数不使用密钥</h5><h5 id="报文认证码使用密钥"><a href="#报文认证码使用密钥" class="headerlink" title="报文认证码使用密钥"></a>报文认证码使用密钥</h5><h3 id="6-3-3-报文认证函数"><a href="#6-3-3-报文认证函数" class="headerlink" title="6.3.3.     报文认证函数"></a>6.3.3.     报文认证函数</h3><h4 id="产生认证码的函数分为"><a href="#产生认证码的函数分为" class="headerlink" title="产生认证码的函数分为"></a>产生认证码的函数分为</h4><h5 id="报文加密"><a href="#报文加密" class="headerlink" title="报文加密"></a>报文加密</h5><h5 id="报文认证码MAC"><a href="#报文认证码MAC" class="headerlink" title="报文认证码MAC"></a>报文认证码MAC</h5><h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><h4 id="报文加密-1"><a href="#报文加密-1" class="headerlink" title="报文加密"></a>报文加密</h4><h5 id="以整个报文的密文作为认证符；"><a href="#以整个报文的密文作为认证符；" class="headerlink" title="以整个报文的密文作为认证符；"></a>以整个报文的密文作为认证符；</h5><h5 id="实现认证的方式"><a href="#实现认证的方式" class="headerlink" title="实现认证的方式"></a>实现认证的方式</h5><h6 id="对称加密：提供机密性与认证"><a href="#对称加密：提供机密性与认证" class="headerlink" title="对称加密：提供机密性与认证"></a>对称加密：提供机密性与认证</h6><h6 id="非对称加密：提供机密性"><a href="#非对称加密：提供机密性" class="headerlink" title="非对称加密：提供机密性"></a>非对称加密：提供机密性</h6><h6 id="非对称加密：提供认证与数字签名"><a href="#非对称加密：提供认证与数字签名" class="headerlink" title="非对称加密：提供认证与数字签名"></a>非对称加密：提供认证与数字签名</h6><h6 id="非对称加密：提供机密性、认证与数字签名"><a href="#非对称加密：提供机密性、认证与数字签名" class="headerlink" title="非对称加密：提供机密性、认证与数字签名"></a>非对称加密：提供机密性、认证与数字签名</h6><h4 id="报文认证码MAC-1"><a href="#报文认证码MAC-1" class="headerlink" title="报文认证码MAC"></a>报文认证码MAC</h4><h5 id="以一个公共函数和密钥产生一个定长值作为认证符；"><a href="#以一个公共函数和密钥产生一个定长值作为认证符；" class="headerlink" title="以一个公共函数和密钥产生一个定长值作为认证符；"></a>以一个公共函数和密钥产生一个定长值作为认证符；</h5><h5 id="实现认证的方式-1"><a href="#实现认证的方式-1" class="headerlink" title="实现认证的方式"></a>实现认证的方式</h5><h6 id="报文认证，不提供机密性"><a href="#报文认证，不提供机密性" class="headerlink" title="报文认证，不提供机密性"></a>报文认证，不提供机密性</h6><h6 id="报文认证与机密性，报文认证码与明文连接"><a href="#报文认证与机密性，报文认证码与明文连接" class="headerlink" title="报文认证与机密性，报文认证码与明文连接"></a>报文认证与机密性，报文认证码与明文连接</h6><h6 id="报文认证与机密性，报文认证码与密文连接"><a href="#报文认证与机密性，报文认证码与密文连接" class="headerlink" title="报文认证与机密性，报文认证码与密文连接"></a>报文认证与机密性，报文认证码与密文连接</h6><h4 id="散列函数-1"><a href="#散列函数-1" class="headerlink" title="散列函数"></a>散列函数</h4><h5 id="一个将任意长度的报文映射为定长的散列值的公共函数，以散列值作为认证符。"><a href="#一个将任意长度的报文映射为定长的散列值的公共函数，以散列值作为认证符。" class="headerlink" title="一个将任意长度的报文映射为定长的散列值的公共函数，以散列值作为认证符。"></a>一个将任意长度的报文映射为定长的散列值的公共函数，以散列值作为认证符。</h5><h3 id="6-3-4-基于散列函数的报文认证码HMAC"><a href="#6-3-4-基于散列函数的报文认证码HMAC" class="headerlink" title="6.3.4.     基于散列函数的报文认证码HMAC"></a>6.3.4.     基于散列函数的报文认证码HMAC</h3><h4 id="HMAC算法的输出"><a href="#HMAC算法的输出" class="headerlink" title="HMAC算法的输出:"></a>HMAC算法的输出:</h4><h5 id="HMACK-M-H-K-⊕opad-H-K-⊕ipad-M"><a href="#HMACK-M-H-K-⊕opad-H-K-⊕ipad-M" class="headerlink" title="HMACK(M)=H[(K+⊕opad)||H[(K+⊕ipad)||M]]"></a>HMACK(M)=H[(K+⊕opad)||H[(K+⊕ipad)||M]]</h5><h4 id="HMAC算法可以描述如下："><a href="#HMAC算法可以描述如下：" class="headerlink" title="HMAC算法可以描述如下："></a>HMAC算法可以描述如下：</h4><h5 id="（1）对密钥K的左端填充0以生成一个b比特的串K-；"><a href="#（1）对密钥K的左端填充0以生成一个b比特的串K-；" class="headerlink" title="（1）对密钥K的左端填充0以生成一个b比特的串K+；"></a>（1）对密钥K的左端填充0以生成一个b比特的串K+；</h5><h5 id="（2）将K-与ipad按比特异或产生一个b比特的分组Si；"><a href="#（2）将K-与ipad按比特异或产生一个b比特的分组Si；" class="headerlink" title="（2）将K+与ipad按比特异或产生一个b比特的分组Si；"></a>（2）将K+与ipad按比特异或产生一个b比特的分组Si；</h5><h5 id="（3）将报文M附加到Si后；"><a href="#（3）将报文M附加到Si后；" class="headerlink" title="（3）将报文M附加到Si后；"></a>（3）将报文M附加到Si后；</h5><h5 id="（4）使用散列函数H计算步骤（3）所产生数据流的散列值；"><a href="#（4）使用散列函数H计算步骤（3）所产生数据流的散列值；" class="headerlink" title="（4）使用散列函数H计算步骤（3）所产生数据流的散列值；"></a>（4）使用散列函数H计算步骤（3）所产生数据流的散列值；</h5><h5 id="（5）将K-与opad按比特异或产生一个b比特的分组So；"><a href="#（5）将K-与opad按比特异或产生一个b比特的分组So；" class="headerlink" title="（5）将K+与opad按比特异或产生一个b比特的分组So；"></a>（5）将K+与opad按比特异或产生一个b比特的分组So；</h5><h5 id="（6）将步骤（4）产生的散列值附加到So后；"><a href="#（6）将步骤（4）产生的散列值附加到So后；" class="headerlink" title="（6）将步骤（4）产生的散列值附加到So后；"></a>（6）将步骤（4）产生的散列值附加到So后；</h5><h5 id="（7）使用散列函数H计算步骤（6）所产生数据流的散列值，并输出最终结果"><a href="#（7）使用散列函数H计算步骤（6）所产生数据流的散列值，并输出最终结果" class="headerlink" title="（7）使用散列函数H计算步骤（6）所产生数据流的散列值，并输出最终结果"></a>（7）使用散列函数H计算步骤（6）所产生数据流的散列值，并输出最终结果</h5><h3 id="6-3-5-基于分组密码的报文认证码CMAC"><a href="#6-3-5-基于分组密码的报文认证码CMAC" class="headerlink" title="6.3.5.     基于分组密码的报文认证码CMAC"></a>6.3.5.     基于分组密码的报文认证码CMAC</h3><h2 id="6-4-6-3-数字签名"><a href="#6-4-6-3-数字签名" class="headerlink" title="6.4.     6.3 数字签名"></a>6.4.     6.3 数字签名</h2><h3 id="6-4-1-概念"><a href="#6-4-1-概念" class="headerlink" title="6.4.1.     概念"></a>6.4.1.     概念</h3><h4 id="不仅可以保证信息的完整性和信息源的可靠性，而且可以防止通信双方的欺骗和抵赖行为。"><a href="#不仅可以保证信息的完整性和信息源的可靠性，而且可以防止通信双方的欺骗和抵赖行为。" class="headerlink" title="不仅可以保证信息的完整性和信息源的可靠性，而且可以防止通信双方的欺骗和抵赖行为。"></a>不仅可以保证信息的完整性和信息源的可靠性，而且可以防止通信双方的欺骗和抵赖行为。</h4><h3 id="6-4-2-性质"><a href="#6-4-2-性质" class="headerlink" title="6.4.2.     性质"></a>6.4.2.     性质</h3><h4 id="必须能够验证签名生成者的身份，以及生成签名的时间；"><a href="#必须能够验证签名生成者的身份，以及生成签名的时间；" class="headerlink" title="必须能够验证签名生成者的身份，以及生成签名的时间；"></a>必须能够验证签名生成者的身份，以及生成签名的时间；</h4><h4 id="能够用于证实被签名消息的内容；"><a href="#能够用于证实被签名消息的内容；" class="headerlink" title="能够用于证实被签名消息的内容；"></a>能够用于证实被签名消息的内容；</h4><h4 id="数字签名必须能被第三方验证，从而解决通信双方的争议。"><a href="#数字签名必须能被第三方验证，从而解决通信双方的争议。" class="headerlink" title="数字签名必须能被第三方验证，从而解决通信双方的争议。"></a>数字签名必须能被第三方验证，从而解决通信双方的争议。</h4><h3 id="6-4-3-使用方式"><a href="#6-4-3-使用方式" class="headerlink" title="6.4.3.     使用方式"></a>6.4.3.     使用方式</h3><h4 id="直接数字签名"><a href="#直接数字签名" class="headerlink" title="直接数字签名"></a>直接数字签名</h4><h4 id="需仲裁的数字签名"><a href="#需仲裁的数字签名" class="headerlink" title="需仲裁的数字签名"></a>需仲裁的数字签名</h4><h3 id="6-4-4-ElGamal数字签名算法"><a href="#6-4-4-ElGamal数字签名算法" class="headerlink" title="6.4.4.     ElGamal数字签名算法"></a>6.4.4.     ElGamal数字签名算法</h3><h4 id="使用私钥进行加密，使用公钥进行解密。"><a href="#使用私钥进行加密，使用公钥进行解密。" class="headerlink" title="使用私钥进行加密，使用公钥进行解密。"></a>使用私钥进行加密，使用公钥进行解密。</h4><h4 id="安全性同样依赖于计算有限域上离散对数的难度。"><a href="#安全性同样依赖于计算有限域上离散对数的难度。" class="headerlink" title="安全性同样依赖于计算有限域上离散对数的难度。"></a>安全性同样依赖于计算有限域上离散对数的难度。</h4><h3 id="6-4-5-数字签名标准DSS"><a href="#6-4-5-数字签名标准DSS" class="headerlink" title="6.4.5.     数字签名标准DSS"></a>6.4.5.     数字签名标准DSS</h3><h3 id="6-4-6-数字签名算法DSA"><a href="#6-4-6-数字签名算法DSA" class="headerlink" title="6.4.6.     数字签名算法DSA"></a>6.4.6.     数字签名算法DSA</h3><h1 id="7-7-密钥分配与用户认证"><a href="#7-7-密钥分配与用户认证" class="headerlink" title="7.    7 密钥分配与用户认证"></a>7.    7 密钥分配与用户认证</h1><h2 id="7-1-7-1-密钥分配"><a href="#7-1-7-1-密钥分配" class="headerlink" title="7.1.     7.1 密钥分配"></a>7.1.     7.1 密钥分配</h2><h3 id="7-1-1-概念"><a href="#7-1-1-概念" class="headerlink" title="7.1.1.     概念"></a>7.1.1.     概念</h3><h4 id="密钥分配是为需要交换安全加密数据的双方分发密钥，并提供密钥安全分发所需要的方法或协议。"><a href="#密钥分配是为需要交换安全加密数据的双方分发密钥，并提供密钥安全分发所需要的方法或协议。" class="headerlink" title="密钥分配是为需要交换安全加密数据的双方分发密钥，并提供密钥安全分发所需要的方法或协议。"></a>密钥分配是为需要交换安全加密数据的双方分发密钥，并提供密钥安全分发所需要的方法或协议。</h4><h3 id="7-1-2-主要内容"><a href="#7-1-2-主要内容" class="headerlink" title="7.1.2.     主要内容"></a>7.1.2.     主要内容</h3><h4 id="基于对称加密的秘密密钥分配"><a href="#基于对称加密的秘密密钥分配" class="headerlink" title="基于对称加密的秘密密钥分配"></a>基于对称加密的秘密密钥分配</h4><h4 id="基于非对称加密的秘密密钥分配"><a href="#基于非对称加密的秘密密钥分配" class="headerlink" title="基于非对称加密的秘密密钥分配"></a>基于非对称加密的秘密密钥分配</h4><h5 id="公钥加密的效率较低，不太适合用于保密通信，但将其用于分配对称加密的秘密密钥却是非常合适的。"><a href="#公钥加密的效率较低，不太适合用于保密通信，但将其用于分配对称加密的秘密密钥却是非常合适的。" class="headerlink" title="公钥加密的效率较低，不太适合用于保密通信，但将其用于分配对称加密的秘密密钥却是非常合适的。"></a>公钥加密的效率较低，不太适合用于保密通信，但将其用于分配对称加密的秘密密钥却是非常合适的。</h5><h5 id="秘密密钥分配方式"><a href="#秘密密钥分配方式" class="headerlink" title="秘密密钥分配方式"></a>秘密密钥分配方式</h5><h6 id="简单的秘密密钥分配"><a href="#简单的秘密密钥分配" class="headerlink" title="简单的秘密密钥分配"></a>简单的秘密密钥分配</h6><p>问题</p>
<p>易受主动攻击</p>
<h6 id="具有机密性和认证功能的秘密密钥分配"><a href="#具有机密性和认证功能的秘密密钥分配" class="headerlink" title="具有机密性和认证功能的秘密密钥分配"></a>具有机密性和认证功能的秘密密钥分配</h6><h4 id="公钥分发"><a href="#公钥分发" class="headerlink" title="公钥分发"></a>公钥分发</h4><h5 id="公钥分配方法"><a href="#公钥分配方法" class="headerlink" title="公钥分配方法"></a>公钥分配方法</h5><h6 id="公开宣布"><a href="#公开宣布" class="headerlink" title="公开宣布"></a>公开宣布</h6><h6 id="公开可以得到的目录"><a href="#公开可以得到的目录" class="headerlink" title="公开可以得到的目录"></a>公开可以得到的目录</h6><h6 id="公开密钥管理机构"><a href="#公开密钥管理机构" class="headerlink" title="公开密钥管理机构"></a>公开密钥管理机构</h6><p>公钥管理机构</p>
<p>维护一个所有参与者的公钥动态目录</p>
<h6 id="公开密钥证书"><a href="#公开密钥证书" class="headerlink" title="公开密钥证书"></a>公开密钥证书</h6><p>时间戳验证证书的时效性</p>
<h2 id="7-2-7-2-用户认证原理"><a href="#7-2-7-2-用户认证原理" class="headerlink" title="7.2.     7.2 用户认证原理"></a>7.2.     7.2 用户认证原理</h2><h3 id="7-2-1-概念"><a href="#7-2-1-概念" class="headerlink" title="7.2.1.     概念"></a>7.2.1.     概念</h3><h4 id="用户认证是证实被认证对象是否属实和是否有效的一个过程。"><a href="#用户认证是证实被认证对象是否属实和是否有效的一个过程。" class="headerlink" title="用户认证是证实被认证对象是否属实和是否有效的一个过程。"></a>用户认证是证实被认证对象是否属实和是否有效的一个过程。</h4><h3 id="7-2-2-分类"><a href="#7-2-2-分类" class="headerlink" title="7.2.2.     分类"></a>7.2.2.     分类</h3><h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><h5 id="双向认证协议能够使通信双方互相认证彼此的身份，并交换会话密钥。"><a href="#双向认证协议能够使通信双方互相认证彼此的身份，并交换会话密钥。" class="headerlink" title="双向认证协议能够使通信双方互相认证彼此的身份，并交换会话密钥。"></a>双向认证协议能够使通信双方互相认证彼此的身份，并交换会话密钥。</h5><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4><h5 id="在有些情况下无需相互认证对方的身份，而仅对通信一方的身份进行认证，即单向认证。"><a href="#在有些情况下无需相互认证对方的身份，而仅对通信一方的身份进行认证，即单向认证。" class="headerlink" title="在有些情况下无需相互认证对方的身份，而仅对通信一方的身份进行认证，即单向认证。"></a>在有些情况下无需相互认证对方的身份，而仅对通信一方的身份进行认证，即单向认证。</h5><h2 id="7-3-7-3-Kerberos"><a href="#7-3-7-3-Kerberos" class="headerlink" title="7.3.     7.3 Kerberos"></a>7.3.     7.3 Kerberos</h2><h3 id="7-3-1-概念"><a href="#7-3-1-概念" class="headerlink" title="7.3.1.     概念"></a>7.3.1.     概念</h3><h4 id="基于可信第三方的认证系统。"><a href="#基于可信第三方的认证系统。" class="headerlink" title="基于可信第三方的认证系统。"></a>基于可信第三方的认证系统。</h4><h4 id="提供一个集中的认证服务器，其功能是实现服务器与用户之间的双向认证。"><a href="#提供一个集中的认证服务器，其功能是实现服务器与用户之间的双向认证。" class="headerlink" title="提供一个集中的认证服务器，其功能是实现服务器与用户之间的双向认证。"></a>提供一个集中的认证服务器，其功能是实现服务器与用户之间的双向认证。</h4><h3 id="7-3-2-问题"><a href="#7-3-2-问题" class="headerlink" title="7.3.2.     问题"></a>7.3.2.     问题</h3><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><h5 id="任何客户都可向服务器申请服务，为防止用户对服务器未授权访问，服务器必须能够认证请求服务的用户的身份"><a href="#任何客户都可向服务器申请服务，为防止用户对服务器未授权访问，服务器必须能够认证请求服务的用户的身份" class="headerlink" title="任何客户都可向服务器申请服务，为防止用户对服务器未授权访问，服务器必须能够认证请求服务的用户的身份"></a>任何客户都可向服务器申请服务，为防止用户对服务器未授权访问，服务器必须能够认证请求服务的用户的身份</h5><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使用一个认证服务器AS"><a href="#使用一个认证服务器AS" class="headerlink" title="使用一个认证服务器AS"></a>使用一个认证服务器AS</h6><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><h5 id="希望使用户访问同一种服务时必须输入口令的次数最少"><a href="#希望使用户访问同一种服务时必须输入口令的次数最少" class="headerlink" title="希望使用户访问同一种服务时必须输入口令的次数最少"></a>希望使用户访问同一种服务时必须输入口令的次数最少</h5><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使用服务许可票据"><a href="#使用服务许可票据" class="headerlink" title="使用服务许可票据"></a>使用服务许可票据</h6><h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><h5 id="对不同的服务用户需要新的票据的问题"><a href="#对不同的服务用户需要新的票据的问题" class="headerlink" title="对不同的服务用户需要新的票据的问题"></a>对不同的服务用户需要新的票据的问题</h5><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使用票据许可票据"><a href="#使用票据许可票据" class="headerlink" title="使用票据许可票据"></a>使用票据许可票据</h6><p>利用票据许可票据可以获得服务许可票据。</p>
<h4 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h4><h5 id="票据的生存期问题"><a href="#票据的生存期问题" class="headerlink" title="票据的生存期问题"></a>票据的生存期问题</h5><h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使得网络服务必须能证明使用票据的人即是申请票据的人"><a href="#使得网络服务必须能证明使用票据的人即是申请票据的人" class="headerlink" title="使得网络服务必须能证明使用票据的人即是申请票据的人"></a>使得网络服务必须能证明使用票据的人即是申请票据的人</h6><h4 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h4><h5 id="服务器向用户认证自己"><a href="#服务器向用户认证自己" class="headerlink" title="服务器向用户认证自己"></a>服务器向用户认证自己</h5><h5 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="使用双向认证。"><a href="#使用双向认证。" class="headerlink" title="使用双向认证。"></a>使用双向认证。</h6><h2 id="7-4-7-4-X-509证书与公钥基础设施"><a href="#7-4-7-4-X-509证书与公钥基础设施" class="headerlink" title="7.4.     7.4 X.509证书与公钥基础设施"></a>7.4.     7.4 X.509证书与公钥基础设施</h2><h3 id="7-4-1-概念"><a href="#7-4-1-概念" class="headerlink" title="7.4.1.     概念"></a>7.4.1.     概念</h3><h4 id="定义了一种提供认证服务的框架。"><a href="#定义了一种提供认证服务的框架。" class="headerlink" title="定义了一种提供认证服务的框架。"></a>定义了一种提供认证服务的框架。</h4><h3 id="7-4-2-主要内容"><a href="#7-4-2-主要内容" class="headerlink" title="7.4.2.     主要内容"></a>7.4.2.     主要内容</h3><h4 id="X-509证书"><a href="#X-509证书" class="headerlink" title="X.509证书"></a>X.509证书</h4><h5 id="本质上，X-509证书是由可信的第三方——证书权威机构（CA）签发的一个关于实体及其公钥关联的数字声明，该证书具有权威性。"><a href="#本质上，X-509证书是由可信的第三方——证书权威机构（CA）签发的一个关于实体及其公钥关联的数字声明，该证书具有权威性。" class="headerlink" title="本质上，X.509证书是由可信的第三方——证书权威机构（CA）签发的一个关于实体及其公钥关联的数字声明，该证书具有权威性。"></a>本质上，X.509证书是由可信的第三方——证书权威机构（CA）签发的一个关于实体及其公钥关联的数字声明，该证书具有权威性。</h5><h5 id="可信的第三方"><a href="#可信的第三方" class="headerlink" title="可信的第三方"></a>可信的第三方</h5><h6 id="是称为CA的证书权威机构，该机构负责认证用户的身份并向用户签发数字证书。"><a href="#是称为CA的证书权威机构，该机构负责认证用户的身份并向用户签发数字证书。" class="headerlink" title="是称为CA的证书权威机构，该机构负责认证用户的身份并向用户签发数字证书。"></a>是称为CA的证书权威机构，该机构负责认证用户的身份并向用户签发数字证书。</h6><h5 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h5><h6 id="是公钥、公钥持有者（主体）和CA的签名，证书完成了公钥与公钥持有者的权威性绑定。"><a href="#是公钥、公钥持有者（主体）和CA的签名，证书完成了公钥与公钥持有者的权威性绑定。" class="headerlink" title="是公钥、公钥持有者（主体）和CA的签名，证书完成了公钥与公钥持有者的权威性绑定。"></a>是公钥、公钥持有者（主体）和CA的签名，证书完成了公钥与公钥持有者的权威性绑定。</h6><h5 id="由于证书是不可伪造的，因此将其放入目录后无需对目录施加特别的保护措施。"><a href="#由于证书是不可伪造的，因此将其放入目录后无需对目录施加特别的保护措施。" class="headerlink" title="由于证书是不可伪造的，因此将其放入目录后无需对目录施加特别的保护措施。"></a>由于证书是不可伪造的，因此将其放入目录后无需对目录施加特别的保护措施。</h5><h5 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h5><h6 id="任何拥有CA公钥的用户都可以对该CA签发的证书进行验证，从而获得一个可信的用户公钥。"><a href="#任何拥有CA公钥的用户都可以对该CA签发的证书进行验证，从而获得一个可信的用户公钥。" class="headerlink" title="任何拥有CA公钥的用户都可以对该CA签发的证书进行验证，从而获得一个可信的用户公钥。"></a>任何拥有CA公钥的用户都可以对该CA签发的证书进行验证，从而获得一个可信的用户公钥。</h6><h6 id="除证书权威机构CA外任何一方都不可能不被察觉地修改证书。"><a href="#除证书权威机构CA外任何一方都不可能不被察觉地修改证书。" class="headerlink" title="除证书权威机构CA外任何一方都不可能不被察觉地修改证书。"></a>除证书权威机构CA外任何一方都不可能不被察觉地修改证书。</h6><h5 id="基于"><a href="#基于" class="headerlink" title="基于"></a>基于</h5><h6 id="公开密钥加密-数字签名"><a href="#公开密钥加密-数字签名" class="headerlink" title="公开密钥加密+数字签名"></a>公开密钥加密+数字签名</h6><p>加密算法推荐使用RSA</p>
<p>数字签名要求使用散列函数。</p>
<h5 id="两部分构成"><a href="#两部分构成" class="headerlink" title="两部分构成"></a>两部分构成</h5><h6 id="信息部分-I"><a href="#信息部分-I" class="headerlink" title="信息部分(I)"></a>信息部分(I)</h6><h6 id="数字签名部分-S"><a href="#数字签名部分-S" class="headerlink" title="数字签名部分(S)"></a>数字签名部分(S)</h6><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><h6 id="看PPT"><a href="#看PPT" class="headerlink" title="看PPT"></a>看PPT</h6><h6 id="和第二版区别"><a href="#和第二版区别" class="headerlink" title="和第二版区别"></a>和第二版区别</h6><p>颁发者唯一标识符</p>
<p>主体唯一标识符</p>
<h6 id="和第三版区别"><a href="#和第三版区别" class="headerlink" title="和第三版区别"></a>和第三版区别</h6><p>证书扩展</p>
<h5 id="证书的格式、证书的获取、证书链、证书的撤销、证书的验证、证书的撤销列表"><a href="#证书的格式、证书的获取、证书链、证书的撤销、证书的验证、证书的撤销列表" class="headerlink" title="证书的格式、证书的获取、证书链、证书的撤销、证书的验证、证书的撤销列表"></a>证书的格式、证书的获取、证书链、证书的撤销、证书的验证、证书的撤销列表</h5><h4 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h4><h5 id="PKIX"><a href="#PKIX" class="headerlink" title="PKIX"></a>PKIX</h5>]]></content>
      <categories>
        <category>考试</category>
        <category>信息安全与技术</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-一、操作系统引论"><a href="#1-一、操作系统引论" class="headerlink" title="1.    一、操作系统引论"></a>1.    一、操作系统引论</h1><h2 id="1-1-计算机层次结构"><a href="#1-1-计算机层次结构" class="headerlink" title="1.1.     计算机层次结构"></a>1.1.     计算机层次结构</h2><h3 id="1-1-1-软件"><a href="#1-1-1-软件" class="headerlink" title="1.1.1.     软件"></a>1.1.1.     软件</h3><h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><h5 id="数据库系统、汇编器、编译软件"><a href="#数据库系统、汇编器、编译软件" class="headerlink" title="数据库系统、汇编器、编译软件"></a>数据库系统、汇编器、编译软件</h5><h5 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h5><h3 id="1-1-2-硬件"><a href="#1-1-2-硬件" class="headerlink" title="1.1.2.     硬件"></a>1.1.2.     硬件</h3><h4 id="裸机"><a href="#裸机" class="headerlink" title="裸机"></a>裸机</h4><h2 id="1-2-操作系统定义"><a href="#1-2-操作系统定义" class="headerlink" title="1.2.     操作系统定义"></a>1.2.     操作系统定义</h2><h3 id="1-2-1-1、配置在计算机硬件上的第一层软件，是对硬件系统的补充"><a href="#1-2-1-1、配置在计算机硬件上的第一层软件，是对硬件系统的补充" class="headerlink" title="1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充"></a>1.2.1.     1、配置在计算机硬件上的第一层软件，是对硬件系统的补充</h3><h3 id="1-2-2-2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合"><a href="#1-2-2-2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合" class="headerlink" title="1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合"></a>1.2.2.     2、是一组能有效地控制和管理计算机软硬件资源，合理对各类作业进行调度，方便用户使用的程序的集合</h3><h2 id="1-3-操作系统目标"><a href="#1-3-操作系统目标" class="headerlink" title="1.3.     操作系统目标"></a>1.3.     操作系统目标</h2><h3 id="1-3-1-1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别"><a href="#1-3-1-1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别" class="headerlink" title="1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别"></a>1.3.1.     1、方便性：（用户的观点）——提供良好的、一致的用户接口，弥补硬件系统数量和类型的差别</h3><h3 id="1-3-2-2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程"><a href="#1-3-2-2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程" class="headerlink" title="1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程"></a>1.3.2.     2、有效性：（管理人员的观点）——管理和分配计算机软硬件资源，合理组织计算机工作流程</h3><h3 id="1-3-3-3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作"><a href="#1-3-3-3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作" class="headerlink" title="1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作"></a>1.3.3.     3、可扩充性：（开放的观点）——多个OS之间的资源共享和互操作</h3><h2 id="1-4-操作系统作用"><a href="#1-4-操作系统作用" class="headerlink" title="1.4.     操作系统作用"></a>1.4.     操作系统作用</h2><h3 id="1-4-1-1、用户与计算机硬件系统之间的接口"><a href="#1-4-1-1、用户与计算机硬件系统之间的接口" class="headerlink" title="1.4.1.     1、用户与计算机硬件系统之间的接口"></a>1.4.1.     1、用户与计算机硬件系统之间的接口</h3><h3 id="1-4-2-2、计算机资源的管理者"><a href="#1-4-2-2、计算机资源的管理者" class="headerlink" title="1.4.2.     2、计算机资源的管理者"></a>1.4.2.     2、计算机资源的管理者</h3><h3 id="1-4-3-3、实现对计算机资源的抽象（扩展机-虚拟机）"><a href="#1-4-3-3、实现对计算机资源的抽象（扩展机-虚拟机）" class="headerlink" title="1.4.3.     3、实现对计算机资源的抽象（扩展机/虚拟机）"></a>1.4.3.     3、实现对计算机资源的抽象（扩展机/虚拟机）</h3><h2 id="1-5-操作系统分类"><a href="#1-5-操作系统分类" class="headerlink" title="1.5.     操作系统分类"></a>1.5.     操作系统分类</h2><h3 id="1-5-1-人工操作"><a href="#1-5-1-人工操作" class="headerlink" title="1.5.1.     人工操作"></a>1.5.1.     人工操作</h3><h4 id="利用率-执行时间-（执行时间-读卡时间）"><a href="#利用率-执行时间-（执行时间-读卡时间）" class="headerlink" title="利用率=执行时间/（执行时间+读卡时间）"></a>利用率=执行时间/（执行时间+读卡时间）</h4><h3 id="1-5-2-批处理系统"><a href="#1-5-2-批处理系统" class="headerlink" title="1.5.2.     批处理系统"></a>1.5.2.     批处理系统</h3><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><h6 id="若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。"><a href="#若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。" class="headerlink" title="若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。"></a>若干个作业编成作业执行序列，每个批作业由一个专门的监督程序（monitor）自动依次处理。</h6><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="1、优点：改善了CPU和I-O设备的使用效率；提高了系统吞吐量"><a href="#1、优点：改善了CPU和I-O设备的使用效率；提高了系统吞吐量" class="headerlink" title="1、优点：改善了CPU和I/O设备的使用效率；提高了系统吞吐量"></a>1、优点：改善了CPU和I/O设备的使用效率；提高了系统吞吐量</h6><h6 id="2、缺点：系统资源得不到充分利用；CPU和I-O外设忙闲不均"><a href="#2、缺点：系统资源得不到充分利用；CPU和I-O外设忙闲不均" class="headerlink" title="2、缺点：系统资源得不到充分利用；CPU和I/O外设忙闲不均"></a>2、缺点：系统资源得不到充分利用；CPU和I/O外设忙闲不均</h6><h5 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h5><h6 id="1、自动性"><a href="#1、自动性" class="headerlink" title="1、自动性"></a>1、自动性</h6><h6 id="2、顺序性"><a href="#2、顺序性" class="headerlink" title="2、顺序性"></a>2、顺序性</h6><h6 id="3、单道性"><a href="#3、单道性" class="headerlink" title="3、单道性"></a>3、单道性</h6><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><h6 id="作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。"><a href="#作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。" class="headerlink" title="作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。"></a>作业在外存排成后备队列，然后作业调度程序按某算法在其中选择若干个作业调入内存，使它们共享CPU和系统的各种资源。</h6><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）"><a href="#1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）" class="headerlink" title="1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）"></a>1、优点：CPU和内存利用率高；作业吞吐量大（单位时间完成的工作总量大）</h6><h6 id="2、缺点："><a href="#2、缺点：" class="headerlink" title="2、缺点："></a>2、缺点：</h6><p>用户交互性差：整个作业完成后或中间出错时，才与用户交互</p>
<p>作业平均周转时间长：短作业周转时间显著增长</p>
<h5 id="主要特征-1"><a href="#主要特征-1" class="headerlink" title="主要特征"></a>主要特征</h5><h6 id="1、多道：内存中同时存放多个作业"><a href="#1、多道：内存中同时存放多个作业" class="headerlink" title="1、多道：内存中同时存放多个作业"></a>1、多道：内存中同时存放多个作业</h6><h6 id="2、宏观：并行运行，都处于运行状态"><a href="#2、宏观：并行运行，都处于运行状态" class="headerlink" title="2、宏观：并行运行，都处于运行状态"></a>2、宏观：并行运行，都处于运行状态</h6><h6 id="3、微观：串行运行，各作业交替使用CPU"><a href="#3、微观：串行运行，各作业交替使用CPU" class="headerlink" title="3、微观：串行运行，各作业交替使用CPU"></a>3、微观：串行运行，各作业交替使用CPU</h6><h5 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h5><h3 id="1-5-3-分时系统"><a href="#1-5-3-分时系统" class="headerlink" title="1.5.3.     分时系统"></a>1.5.3.     分时系统</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><h5 id="是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。"><a href="#是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。" class="headerlink" title="是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。"></a>是一种联机的多用户交互式的操作系统，采用时间片轮转的方式使一台计算机为多个终端服务。对每个用户保证及时响应并提供交互会话能力。</h5><h4 id="主要特征-2"><a href="#主要特征-2" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、交互性：用户与系统可以进行广泛的人机对话"><a href="#1、交互性：用户与系统可以进行广泛的人机对话" class="headerlink" title="1、交互性：用户与系统可以进行广泛的人机对话"></a>1、交互性：用户与系统可以进行广泛的人机对话</h5><h5 id="2、多路性：多用户在各自终端上使用同一CPU"><a href="#2、多路性：多用户在各自终端上使用同一CPU" class="headerlink" title="2、多路性：多用户在各自终端上使用同一CPU"></a>2、多路性：多用户在各自终端上使用同一CPU</h5><h5 id="3、独立性：用户独立操作，互不干扰"><a href="#3、独立性：用户独立操作，互不干扰" class="headerlink" title="3、独立性：用户独立操作，互不干扰"></a>3、独立性：用户独立操作，互不干扰</h5><h5 id="4、及时性-用户短时间内得到系统地及时回答"><a href="#4、及时性-用户短时间内得到系统地及时回答" class="headerlink" title="4、及时性:用户短时间内得到系统地及时回答"></a>4、及时性:用户短时间内得到系统地及时回答</h5><h5 id="ps：可靠性：较低"><a href="#ps：可靠性：较低" class="headerlink" title="ps：可靠性：较低"></a>ps：可靠性：较低</h5><h4 id="影响响应时间的因素"><a href="#影响响应时间的因素" class="headerlink" title="影响响应时间的因素"></a>影响响应时间的因素</h4><h5 id="终端数目；时间片大小；信息交换量；信息交换速度"><a href="#终端数目；时间片大小；信息交换量；信息交换速度" class="headerlink" title="终端数目；时间片大小；信息交换量；信息交换速度"></a>终端数目；时间片大小；信息交换量；信息交换速度</h5><h3 id="1-5-4-实时系统"><a href="#1-5-4-实时系统" class="headerlink" title="1.5.4.     实时系统"></a>1.5.4.     实时系统</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><h5 id="能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位"><a href="#能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位" class="headerlink" title="能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位"></a>能及时相应外部事件请求，在规定时间内完成对该事件的处理，使所有实时任务协调一致地运行；保证实时性和高可靠行，系统效率放在第二位</h5><h4 id="主要特征-3"><a href="#主要特征-3" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序"><a href="#1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序" class="headerlink" title="1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序"></a>1、交互性：用户与系统的交互仅限于访问某个特定的专用服务程序</h5><h5 id="2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构"><a href="#2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构" class="headerlink" title="2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构"></a>2、多路性：实时信息处理系统和分时系统系统；实时控制系统表现为对多路现场信息的采集，以及控制多个对象和执行机构</h5><h5 id="3、独立性：独立操作互不干扰"><a href="#3、独立性：独立操作互不干扰" class="headerlink" title="3、独立性：独立操作互不干扰"></a>3、独立性：独立操作互不干扰</h5><h5 id="4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级"><a href="#4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级" class="headerlink" title="4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级"></a>4、及时性：以控制对象要求的截止时间来确定，一般精确到秒级</h5><h5 id="ps-可靠性：高度可靠"><a href="#ps-可靠性：高度可靠" class="headerlink" title="ps:可靠性：高度可靠"></a>ps:可靠性：高度可靠</h5><h4 id="实时系统分类"><a href="#实时系统分类" class="headerlink" title="实时系统分类"></a>实时系统分类</h4><h5 id="实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统"><a href="#实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统" class="headerlink" title="实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统"></a>实时控制系统：通常值以计算机为中心的生产过程控制系统，又称计算机控制系统</h5><h5 id="实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答"><a href="#实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答" class="headerlink" title="实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答"></a>实时信息处理系统：及时接收远程终端请求，根据请求进行信息的检索和处理，很短时间内对用户做出正确的回答</h5><h4 id="任务类型分类"><a href="#任务类型分类" class="headerlink" title="任务类型分类"></a>任务类型分类</h4><h5 id="任务执行是否周期性"><a href="#任务执行是否周期性" class="headerlink" title="任务执行是否周期性"></a>任务执行是否周期性</h5><h6 id="周期性实时任务：设备周期性发送信号"><a href="#周期性实时任务：设备周期性发送信号" class="headerlink" title="周期性实时任务：设备周期性发送信号"></a>周期性实时任务：设备周期性发送信号</h6><h6 id="非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）"><a href="#非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）" class="headerlink" title="非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）"></a>非周期性实时任务：联系一个截止时间（开始截止时间或者完成截止时间）</h6><h5 id="截止时间的要求"><a href="#截止时间的要求" class="headerlink" title="截止时间的要求"></a>截止时间的要求</h5><h6 id="硬实时任务：必须满足截止时间"><a href="#硬实时任务：必须满足截止时间" class="headerlink" title="硬实时任务：必须满足截止时间"></a>硬实时任务：必须满足截止时间</h6><h6 id="软实时任务：允许偶尔不满足截止时间"><a href="#软实时任务：允许偶尔不满足截止时间" class="headerlink" title="软实时任务：允许偶尔不满足截止时间"></a>软实时任务：允许偶尔不满足截止时间</h6><h3 id="1-5-5-多处理机操作系统"><a href="#1-5-5-多处理机操作系统" class="headerlink" title="1.5.5.     多处理机操作系统"></a>1.5.5.     多处理机操作系统</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><h5 id="增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）"><a href="#增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）" class="headerlink" title="增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）"></a>增加系统吞吐量。但N个处理器加速比达不到N倍（额外调度开销，算法并行化）</h5><h5 id="提高系统可靠性：故障时系统降级运行"><a href="#提高系统可靠性：故障时系统降级运行" class="headerlink" title="提高系统可靠性：故障时系统降级运行"></a>提高系统可靠性：故障时系统降级运行</h5><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连"><a href="#并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连" class="headerlink" title="并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连"></a>并行系统（紧密耦合）：统一OS管理，共享内存，各处理机由开关阵列或快速总线相连</h5><h6 id="对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式"><a href="#对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式" class="headerlink" title="对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式"></a>对称式多重处理：OS交替运行在不同的处理机上，任务负载较均衡，性能调节容易——傻瓜式</h6><h6 id="非对称式多重处理（主从模式-主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I-O处理。负载不匀，可靠性较低（通常要求硬件也非对称）"><a href="#非对称式多重处理（主从模式-主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I-O处理。负载不匀，可靠性较低（通常要求硬件也非对称）" class="headerlink" title="非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I/O处理。负载不匀，可靠性较低（通常要求硬件也非对称）"></a>非对称式多重处理（主从模式):主处理机运行OS，负责分配任务，调度资源；从处理机执行应用程序或I/O处理。负载不匀，可靠性较低（通常要求硬件也非对称）</h6><h5 id="分布式系统（松散耦合）：各处理机有各自的存储器，OS和I-O设备，由通道或通信线路相连"><a href="#分布式系统（松散耦合）：各处理机有各自的存储器，OS和I-O设备，由通道或通信线路相连" class="headerlink" title="分布式系统（松散耦合）：各处理机有各自的存储器，OS和I/O设备，由通道或通信线路相连"></a>分布式系统（松散耦合）：各处理机有各自的存储器，OS和I/O设备，由通道或通信线路相连</h5><h3 id="1-5-6-网络操作系统"><a href="#1-5-6-网络操作系统" class="headerlink" title="1.5.6.     网络操作系统"></a>1.5.6.     网络操作系统</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><h5 id="提供网络通信和网络服务功能的操作系统"><a href="#提供网络通信和网络服务功能的操作系统" class="headerlink" title="提供网络通信和网络服务功能的操作系统"></a>提供网络通信和网络服务功能的操作系统</h5><h4 id="主要特征-4"><a href="#主要特征-4" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、耦合程度"><a href="#1、耦合程度" class="headerlink" title="1、耦合程度"></a>1、耦合程度</h5><h6 id="松散耦合，允许异种OS互联，遵循“协议同质”"><a href="#松散耦合，允许异种OS互联，遵循“协议同质”" class="headerlink" title="松散耦合，允许异种OS互联，遵循“协议同质”"></a>松散耦合，允许异种OS互联，遵循“协议同质”</h6><h5 id="2、并行性"><a href="#2、并行性" class="headerlink" title="2、并行性"></a>2、并行性</h5><h6 id="各机进程独立"><a href="#各机进程独立" class="headerlink" title="各机进程独立"></a>各机进程独立</h6><h5 id="3、透明性（用户是否知道或指定资源在哪个机器上）"><a href="#3、透明性（用户是否知道或指定资源在哪个机器上）" class="headerlink" title="3、透明性（用户是否知道或指定资源在哪个机器上）"></a>3、透明性（用户是否知道或指定资源在哪个机器上）</h5><h6 id="用户明确指定要使用的网络资源"><a href="#用户明确指定要使用的网络资源" class="headerlink" title="用户明确指定要使用的网络资源"></a>用户明确指定要使用的网络资源</h6><h5 id="4、健壮性"><a href="#4、健壮性" class="headerlink" title="4、健壮性"></a>4、健壮性</h5><h6 id="要求不高"><a href="#要求不高" class="headerlink" title="要求不高"></a>要求不高</h6><h3 id="1-5-7-分布式操作系统"><a href="#1-5-7-分布式操作系统" class="headerlink" title="1.5.7.     分布式操作系统"></a>1.5.7.     分布式操作系统</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><h5 id="以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配"><a href="#以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配" class="headerlink" title="以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配"></a>以计算机网络为基础，所有系统任务可以在任何处理机上运行，自动实现任务调度和资源分配</h5><h4 id="主要特征-5"><a href="#主要特征-5" class="headerlink" title="主要特征"></a>主要特征</h4><h5 id="1、耦合程度-1"><a href="#1、耦合程度-1" class="headerlink" title="1、耦合程度"></a>1、耦合程度</h5><h6 id="紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。"><a href="#紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。" class="headerlink" title="紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。"></a>紧密耦合，各级统一建立“OS同质”，直接管理CPU，存储器和外设，统一全系统管理。</h6><h5 id="2、并行性-1"><a href="#2、并行性-1" class="headerlink" title="2、并行性"></a>2、并行性</h5><h6 id="一个进程可以分散在各机上并行执行，“进程迁移”"><a href="#一个进程可以分散在各机上并行执行，“进程迁移”" class="headerlink" title="一个进程可以分散在各机上并行执行，“进程迁移”"></a>一个进程可以分散在各机上并行执行，“进程迁移”</h6><h5 id="3、透明性"><a href="#3、透明性" class="headerlink" title="3、透明性"></a>3、透明性</h5><h6 id="网络资源调度对用户透明，用户不了解所占有资源所在位置"><a href="#网络资源调度对用户透明，用户不了解所占有资源所在位置" class="headerlink" title="网络资源调度对用户透明，用户不了解所占有资源所在位置"></a>网络资源调度对用户透明，用户不了解所占有资源所在位置</h6><h5 id="4、健壮性-1"><a href="#4、健壮性-1" class="headerlink" title="4、健壮性"></a>4、健壮性</h5><h6 id="要求比网络OS更强的容错能力（工作时系统重构）"><a href="#要求比网络OS更强的容错能力（工作时系统重构）" class="headerlink" title="要求比网络OS更强的容错能力（工作时系统重构）"></a>要求比网络OS更强的容错能力（工作时系统重构）</h6><h3 id="1-5-8-个人计算机操作系统"><a href="#1-5-8-个人计算机操作系统" class="headerlink" title="1.5.8.     个人计算机操作系统"></a>1.5.8.     个人计算机操作系统</h3><h4 id="单用户单任务"><a href="#单用户单任务" class="headerlink" title="单用户单任务"></a>单用户单任务</h4><h5 id="只允许一个用户上机，只允许用户程序作为一个任务运行"><a href="#只允许一个用户上机，只允许用户程序作为一个任务运行" class="headerlink" title="只允许一个用户上机，只允许用户程序作为一个任务运行"></a>只允许一个用户上机，只允许用户程序作为一个任务运行</h5><h4 id="单用户多任务"><a href="#单用户多任务" class="headerlink" title="单用户多任务"></a>单用户多任务</h4><h5 id="只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能"><a href="#只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能" class="headerlink" title="只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能"></a>只允许一个用户上机，但允许用户程序分为若干个任务并发执行，从而改善系统性能</h5><h4 id="多用户多任务"><a href="#多用户多任务" class="headerlink" title="多用户多任务"></a>多用户多任务</h4><h5 id="允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能"><a href="#允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能" class="headerlink" title="允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能"></a>允许多个用户上机，也允许用户程序分为若干个任务并发执行，从而改善系统性能</h5><h2 id="1-6-操作系统基本特征"><a href="#1-6-操作系统基本特征" class="headerlink" title="1.6.     操作系统基本特征"></a>1.6.     操作系统基本特征</h2><h3 id="1-6-1-并发"><a href="#1-6-1-并发" class="headerlink" title="1.6.1.     并发"></a>1.6.1.     并发</h3><h4 id="多个事件同一时间段发生"><a href="#多个事件同一时间段发生" class="headerlink" title="多个事件同一时间段发生"></a>多个事件同一时间段发生</h4><h4 id="ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行"><a href="#ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行" class="headerlink" title="ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行"></a>ps：并行指多个事件同一时刻发生。多道程序处理时宏观并发，微观交替执行</h4><h3 id="1-6-2-共享"><a href="#1-6-2-共享" class="headerlink" title="1.6.2.     共享"></a>1.6.2.     共享</h3><h4 id="计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问"><a href="#计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问" class="headerlink" title="计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问"></a>计算机资源在同一个时间段被多个程序交替使用；分为互斥共享和同时访问</h4><h3 id="1-6-3-虚拟"><a href="#1-6-3-虚拟" class="headerlink" title="1.6.3.     虚拟"></a>1.6.3.     虚拟</h3><h4 id="一个物理实体映射为多个逻辑实体——分时或分空间"><a href="#一个物理实体映射为多个逻辑实体——分时或分空间" class="headerlink" title="一个物理实体映射为多个逻辑实体——分时或分空间"></a>一个物理实体映射为多个逻辑实体——分时或分空间</h4><h3 id="1-6-4-异步"><a href="#1-6-4-异步" class="headerlink" title="1.6.4.     异步"></a>1.6.4.     异步</h3><h4 id="又称不确定性；指进程的执行顺序和执行时间的不确定性。"><a href="#又称不确定性；指进程的执行顺序和执行时间的不确定性。" class="headerlink" title="又称不确定性；指进程的执行顺序和执行时间的不确定性。"></a>又称不确定性；指进程的执行顺序和执行时间的不确定性。</h4><h2 id="1-7-操作系统组成"><a href="#1-7-操作系统组成" class="headerlink" title="1.7.     操作系统组成"></a>1.7.     操作系统组成</h2><h3 id="1-7-1-管理模块"><a href="#1-7-1-管理模块" class="headerlink" title="1.7.1.     管理模块"></a>1.7.1.     管理模块</h3><h4 id="针对不同管理对象模块的程序模块（通常被称为操作系统核心）"><a href="#针对不同管理对象模块的程序模块（通常被称为操作系统核心）" class="headerlink" title="针对不同管理对象模块的程序模块（通常被称为操作系统核心）"></a>针对不同管理对象模块的程序模块（通常被称为操作系统核心）</h4><h3 id="1-7-2-用户接口"><a href="#1-7-2-用户接口" class="headerlink" title="1.7.2.     用户接口"></a>1.7.2.     用户接口</h3><h4 id="如外壳（shell）、窗口系统"><a href="#如外壳（shell）、窗口系统" class="headerlink" title="如外壳（shell）、窗口系统"></a>如外壳（shell）、窗口系统</h4><h2 id="1-8-操作系统主要功能"><a href="#1-8-操作系统主要功能" class="headerlink" title="1.8.     操作系统主要功能"></a>1.8.     操作系统主要功能</h2><h3 id="1-8-1-存储管理"><a href="#1-8-1-存储管理" class="headerlink" title="1.8.1.     存储管理"></a>1.8.1.     存储管理</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><h5 id="提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行"><a href="#提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行" class="headerlink" title="提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行"></a>提高存储器利用率，方便用户使用，提供足够存储空间，方便进程并发运行</h5><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="1、存储分配和回收"><a href="#1、存储分配和回收" class="headerlink" title="1、存储分配和回收"></a>1、存储分配和回收</h5><h5 id="2、存储保护"><a href="#2、存储保护" class="headerlink" title="2、存储保护"></a>2、存储保护</h5><h6 id="保证进程互不干扰"><a href="#保证进程互不干扰" class="headerlink" title="保证进程互不干扰"></a>保证进程互不干扰</h6><h5 id="3、地址映射"><a href="#3、地址映射" class="headerlink" title="3、地址映射"></a>3、地址映射</h5><h6 id="进程逻辑地址到内存物理地址的映射"><a href="#进程逻辑地址到内存物理地址的映射" class="headerlink" title="进程逻辑地址到内存物理地址的映射"></a>进程逻辑地址到内存物理地址的映射</h6><h5 id="4、内存扩充"><a href="#4、内存扩充" class="headerlink" title="4、内存扩充"></a>4、内存扩充</h5><h6 id="覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间"><a href="#覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间" class="headerlink" title="覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间"></a>覆盖、交换和虚拟存储：提高内存利用率，扩大进程的内存空间</h6><h3 id="1-8-2-处理机管理"><a href="#1-8-2-处理机管理" class="headerlink" title="1.8.2.     处理机管理"></a>1.8.2.     处理机管理</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><h5 id="处理机资源的分配调度"><a href="#处理机资源的分配调度" class="headerlink" title="处理机资源的分配调度"></a>处理机资源的分配调度</h5><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><h5 id="1、进程控制"><a href="#1、进程控制" class="headerlink" title="1、进程控制"></a>1、进程控制</h5><h6 id="创建、撤销、挂起、改变优先级等"><a href="#创建、撤销、挂起、改变优先级等" class="headerlink" title="创建、撤销、挂起、改变优先级等"></a>创建、撤销、挂起、改变优先级等</h6><h5 id="2、进程同步"><a href="#2、进程同步" class="headerlink" title="2、进程同步"></a>2、进程同步</h5><h6 id="协调并发进程之间的推进步骤，以协调资源共享"><a href="#协调并发进程之间的推进步骤，以协调资源共享" class="headerlink" title="协调并发进程之间的推进步骤，以协调资源共享"></a>协调并发进程之间的推进步骤，以协调资源共享</h6><h5 id="3、进程通信"><a href="#3、进程通信" class="headerlink" title="3、进程通信"></a>3、进程通信</h5><h6 id="进程之间传输数据，协调合作"><a href="#进程之间传输数据，协调合作" class="headerlink" title="进程之间传输数据，协调合作"></a>进程之间传输数据，协调合作</h6><h5 id="4、调度"><a href="#4、调度" class="headerlink" title="4、调度"></a>4、调度</h5><h6 id="作业或进程的运行切换"><a href="#作业或进程的运行切换" class="headerlink" title="作业或进程的运行切换"></a>作业或进程的运行切换</h6><h3 id="1-8-3-设备管理"><a href="#1-8-3-设备管理" class="headerlink" title="1.8.3.     设备管理"></a>1.8.3.     设备管理</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><h5 id="方便用户使用设备、提高CPU和I-O利用率"><a href="#方便用户使用设备、提高CPU和I-O利用率" class="headerlink" title="方便用户使用设备、提高CPU和I/O利用率"></a>方便用户使用设备、提高CPU和I/O利用率</h5><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><h5 id="1、设备操作"><a href="#1、设备操作" class="headerlink" title="1、设备操作"></a>1、设备操作</h5><h6 id="利用设备驱动程序完成对设备的操作"><a href="#利用设备驱动程序完成对设备的操作" class="headerlink" title="利用设备驱动程序完成对设备的操作"></a>利用设备驱动程序完成对设备的操作</h6><h5 id="2、设备独立性"><a href="#2、设备独立性" class="headerlink" title="2、设备独立性"></a>2、设备独立性</h5><h6 id="提供统一的I-O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容"><a href="#提供统一的I-O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容" class="headerlink" title="提供统一的I/O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容"></a>提供统一的I/O接口，使应用程序独立于物理设备，在同样的接口和操作下打印不同的内容</h6><h5 id="3、设备分配与回收"><a href="#3、设备分配与回收" class="headerlink" title="3、设备分配与回收"></a>3、设备分配与回收</h5><h6 id="多用户间共享I-O设备"><a href="#多用户间共享I-O设备" class="headerlink" title="多用户间共享I/O设备"></a>多用户间共享I/O设备</h6><h3 id="1-8-4-文件管理"><a href="#1-8-4-文件管理" class="headerlink" title="1.8.4.     文件管理"></a>1.8.4.     文件管理</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><h5 id="管理用户文件和系统文件方便用户使用，并保证文件安全性"><a href="#管理用户文件和系统文件方便用户使用，并保证文件安全性" class="headerlink" title="管理用户文件和系统文件方便用户使用，并保证文件安全性"></a>管理用户文件和系统文件方便用户使用，并保证文件安全性</h5><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><h5 id="1、文件存储空间管理"><a href="#1、文件存储空间管理" class="headerlink" title="1、文件存储空间管理"></a>1、文件存储空间管理</h5><h5 id="2、目录管理"><a href="#2、目录管理" class="headerlink" title="2、目录管理"></a>2、目录管理</h5><h6 id="解决文件检索问题"><a href="#解决文件检索问题" class="headerlink" title="解决文件检索问题"></a>解决文件检索问题</h6><h5 id="3、文件读写管理与存取控制"><a href="#3、文件读写管理与存取控制" class="headerlink" title="3、文件读写管理与存取控制"></a>3、文件读写管理与存取控制</h5><h5 id="4、软件管理"><a href="#4、软件管理" class="headerlink" title="4、软件管理"></a>4、软件管理</h5><h6 id="软件版本、相互依赖关系、安装和卸载等"><a href="#软件版本、相互依赖关系、安装和卸载等" class="headerlink" title="软件版本、相互依赖关系、安装和卸载等"></a>软件版本、相互依赖关系、安装和卸载等</h6><h3 id="1-8-5-用户接口"><a href="#1-8-5-用户接口" class="headerlink" title="1.8.5.     用户接口"></a>1.8.5.     用户接口</h3><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><h5 id="提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供"><a href="#提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供" class="headerlink" title="提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供"></a>提供一个友好的用户访问操作系统的接口，通常以命令或系统调用的形式提供</h5><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><h5 id="1、命令接口"><a href="#1、命令接口" class="headerlink" title="1、命令接口"></a>1、命令接口</h5><h6 id="联机用户接口：为联机用户提供，由键盘操作命令-命令解释程序组成"><a href="#联机用户接口：为联机用户提供，由键盘操作命令-命令解释程序组成" class="headerlink" title="联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成"></a>联机用户接口：为联机用户提供，由键盘操作命令+命令解释程序组成</h6><h6 id="脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成"><a href="#脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成" class="headerlink" title="脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成"></a>脱机用户接口：为批处理作业用户提供，由作业控制语言JCL组成</h6><h5 id="2、程序接口"><a href="#2、程序接口" class="headerlink" title="2、程序接口"></a>2、程序接口</h5><h6 id="用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成"><a href="#用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成" class="headerlink" title="用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成"></a>用户程序用来访问系统资源，是取得操作系统服务的路径，由一组系统调用组成</h6><h5 id="3、图形接口"><a href="#3、图形接口" class="headerlink" title="3、图形接口"></a>3、图形接口</h5><h6 id="用鼠标通过菜单框来完成对应用程序和文件的操作"><a href="#用鼠标通过菜单框来完成对应用程序和文件的操作" class="headerlink" title="用鼠标通过菜单框来完成对应用程序和文件的操作"></a>用鼠标通过菜单框来完成对应用程序和文件的操作</h6><h2 id="1-9-双模式操作"><a href="#1-9-双模式操作" class="headerlink" title="1.9.     双模式操作"></a>1.9.     双模式操作</h2><h3 id="1-9-1-分类"><a href="#1-9-1-分类" class="headerlink" title="1.9.1.     分类"></a>1.9.1.     分类</h3><h4 id="1、用户模式（目态—模式位1）"><a href="#1、用户模式（目态—模式位1）" class="headerlink" title="1、用户模式（目态—模式位1）"></a>1、用户模式（目态—模式位1）</h4><h4 id="2、监控模式（管态—模式位0）"><a href="#2、监控模式（管态—模式位0）" class="headerlink" title="2、监控模式（管态—模式位0）"></a>2、监控模式（管态—模式位0）</h4><h3 id="1-9-2-切换"><a href="#1-9-2-切换" class="headerlink" title="1.9.2.     切换"></a>1.9.2.     切换</h3><h4 id="用户态-gt-系统态"><a href="#用户态-gt-系统态" class="headerlink" title="用户态-&gt;系统态"></a>用户态-&gt;系统态</h4><h5 id="中断、故障、系统调用（用户需要操作系统的服务）"><a href="#中断、故障、系统调用（用户需要操作系统的服务）" class="headerlink" title="中断、故障、系统调用（用户需要操作系统的服务）"></a>中断、故障、系统调用（用户需要操作系统的服务）</h5><h4 id="系统态-gt-用户态"><a href="#系统态-gt-用户态" class="headerlink" title="系统态-&gt;用户态"></a>系统态-&gt;用户态</h4><h5 id="OS设置用户态"><a href="#OS设置用户态" class="headerlink" title="OS设置用户态"></a>OS设置用户态</h5><h3 id="1-9-3-作用"><a href="#1-9-3-作用" class="headerlink" title="1.9.3.     作用"></a>1.9.3.     作用</h3><h4 id="确保系统和用户程序不受错误的系统程序的影响"><a href="#确保系统和用户程序不受错误的系统程序的影响" class="headerlink" title="确保系统和用户程序不受错误的系统程序的影响"></a>确保系统和用户程序不受错误的系统程序的影响</h4><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统"><a href="#将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统" class="headerlink" title="将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统"></a>将能引起损害的机器指令设置为特权指令，只能在系统态下执行，用户态试图执行硬件就认为该指令方法，以陷阱形式通知操作系统</h5><h3 id="1-9-4-特权指令"><a href="#1-9-4-特权指令" class="headerlink" title="1.9.4.     特权指令"></a>1.9.4.     特权指令</h3><h4 id="1、有关I-O设备的指令"><a href="#1、有关I-O设备的指令" class="headerlink" title="1、有关I/O设备的指令"></a>1、有关I/O设备的指令</h4><h4 id="2、访问程序状态的指令"><a href="#2、访问程序状态的指令" class="headerlink" title="2、访问程序状态的指令"></a>2、访问程序状态的指令</h4><h4 id="3、存储特殊寄存器的指令"><a href="#3、存储特殊寄存器的指令" class="headerlink" title="3、存储特殊寄存器的指令"></a>3、存储特殊寄存器的指令</h4><h4 id="4、其他指令"><a href="#4、其他指令" class="headerlink" title="4、其他指令"></a>4、其他指令</h4><h2 id="1-10-操作系统保护机制"><a href="#1-10-操作系统保护机制" class="headerlink" title="1.10.   操作系统保护机制"></a>1.10.   操作系统保护机制</h2><h3 id="1-10-1-I-O保护"><a href="#1-10-1-I-O保护" class="headerlink" title="1.10.1.   I/O保护"></a>1.10.1.   I/O保护</h3><h4 id="所有的I-O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权"><a href="#所有的I-O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权" class="headerlink" title="所有的I/O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权"></a>所有的I/O指令都是特权指令，必须确保所有的用户程序不能获得管态下操作系统所拥有的对系统的控制权</h4><h3 id="1-10-2-存储保护"><a href="#1-10-2-存储保护" class="headerlink" title="1.10.2.   存储保护"></a>1.10.2.   存储保护</h3><h4 id="某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区"><a href="#某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区" class="headerlink" title="某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区"></a>某进程不可以访问其他进程的地址空间（非共享情况）；用户进程必须通过系统调用访问OS核心区</h4><h4 id="为了实现存储保护，增加两个寄存器"><a href="#为了实现存储保护，增加两个寄存器" class="headerlink" title="为了实现存储保护，增加两个寄存器"></a>为了实现存储保护，增加两个寄存器</h4><h5 id="基地址寄存器：存放本进程最低的内存物理地址"><a href="#基地址寄存器：存放本进程最低的内存物理地址" class="headerlink" title="基地址寄存器：存放本进程最低的内存物理地址"></a>基地址寄存器：存放本进程最低的内存物理地址</h5><h5 id="界限寄存器：存放本进程的存储区域大小"><a href="#界限寄存器：存放本进程的存储区域大小" class="headerlink" title="界限寄存器：存放本进程的存储区域大小"></a>界限寄存器：存放本进程的存储区域大小</h5><h4 id="硬件保护原则"><a href="#硬件保护原则" class="headerlink" title="硬件保护原则"></a>硬件保护原则</h4><h5 id="管态下OS可以无限制访问核心和所有用户程序的地址空间"><a href="#管态下OS可以无限制访问核心和所有用户程序的地址空间" class="headerlink" title="管态下OS可以无限制访问核心和所有用户程序的地址空间"></a>管态下OS可以无限制访问核心和所有用户程序的地址空间</h5><h4 id="修改基地址寄存器和界限寄存器的指令属于特权指令"><a href="#修改基地址寄存器和界限寄存器的指令属于特权指令" class="headerlink" title="修改基地址寄存器和界限寄存器的指令属于特权指令"></a>修改基地址寄存器和界限寄存器的指令属于特权指令</h4><h3 id="1-10-3-CPU保护"><a href="#1-10-3-CPU保护" class="headerlink" title="1.10.3.   CPU保护"></a>1.10.3.   CPU保护</h3><h4 id="为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断"><a href="#为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断" class="headerlink" title="为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断"></a>为了防止用户程序是死循环使得OS始终不能获得CPU控制器的情况，硬件设置时钟——定时中断</h4><h4 id="定时时钟是实现分时操作系统的基础"><a href="#定时时钟是实现分时操作系统的基础" class="headerlink" title="定时时钟是实现分时操作系统的基础"></a>定时时钟是实现分时操作系统的基础</h4><h4 id="修改定时时钟的指令为特权指令"><a href="#修改定时时钟的指令为特权指令" class="headerlink" title="修改定时时钟的指令为特权指令"></a>修改定时时钟的指令为特权指令</h4><h1 id="2-二、进程的描述与控制"><a href="#2-二、进程的描述与控制" class="headerlink" title="2.    二、进程的描述与控制"></a>2.    二、进程的描述与控制</h1><h2 id="2-1-进程描述"><a href="#2-1-进程描述" class="headerlink" title="2.1.     进程描述"></a>2.1.     进程描述</h2><h3 id="2-1-1-进程定义"><a href="#2-1-1-进程定义" class="headerlink" title="2.1.1.     进程定义"></a>2.1.1.     进程定义</h3><h4 id="一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程"><a href="#一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程" class="headerlink" title="一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程"></a>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程</h4><h4 id="是资源分配和管理的基本单位"><a href="#是资源分配和管理的基本单位" class="headerlink" title="是资源分配和管理的基本单位"></a>是资源分配和管理的基本单位</h4><h3 id="2-1-2-进程执行方式"><a href="#2-1-2-进程执行方式" class="headerlink" title="2.1.2.     进程执行方式"></a>2.1.2.     进程执行方式</h3><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><h6 id="1、顺序性"><a href="#1、顺序性" class="headerlink" title="1、顺序性"></a>1、顺序性</h6><h6 id="2、封闭性"><a href="#2、封闭性" class="headerlink" title="2、封闭性"></a>2、封闭性</h6><p>独占全部资源</p>
<h6 id="3、可再现性"><a href="#3、可再现性" class="headerlink" title="3、可再现性"></a>3、可再现性</h6><p>初始条件相同则结果相同</p>
<h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><h6 id="提高资源利用率"><a href="#提高资源利用率" class="headerlink" title="提高资源利用率"></a>提高资源利用率</h6><h5 id="特征（不加入任何系统控制）"><a href="#特征（不加入任何系统控制）" class="headerlink" title="特征（不加入任何系统控制）"></a>特征（不加入任何系统控制）</h5><h6 id="1、间断性"><a href="#1、间断性" class="headerlink" title="1、间断性"></a>1、间断性</h6><h6 id="2、失去封闭性：共享资源"><a href="#2、失去封闭性：共享资源" class="headerlink" title="2、失去封闭性：共享资源"></a>2、失去封闭性：共享资源</h6><h6 id="3、失去可再现性"><a href="#3、失去可再现性" class="headerlink" title="3、失去可再现性"></a>3、失去可再现性</h6><h5 id="执行条件"><a href="#执行条件" class="headerlink" title="执行条件"></a>执行条件</h5><h6 id="达到封闭性和可再现性"><a href="#达到封闭性和可再现性" class="headerlink" title="达到封闭性和可再现性"></a>达到封闭性和可再现性</h6><h3 id="2-1-3-与程序的关系"><a href="#2-1-3-与程序的关系" class="headerlink" title="2.1.3.     与程序的关系"></a>2.1.3.     与程序的关系</h3><h4 id="一个进程多个线程，一个线程对应一个进程"><a href="#一个进程多个线程，一个线程对应一个进程" class="headerlink" title="一个进程多个线程，一个线程对应一个进程"></a>一个进程多个线程，一个线程对应一个进程</h4><h3 id="2-1-4-进程特征"><a href="#2-1-4-进程特征" class="headerlink" title="2.1.4.     进程特征"></a>2.1.4.     进程特征</h3><h4 id="1、动态性"><a href="#1、动态性" class="headerlink" title="1、动态性"></a>1、动态性</h4><h4 id="2、并发性"><a href="#2、并发性" class="headerlink" title="2、并发性"></a>2、并发性</h4><h4 id="3、独立性"><a href="#3、独立性" class="headerlink" title="3、独立性"></a>3、独立性</h4><h5 id="资源分配的基本单位"><a href="#资源分配的基本单位" class="headerlink" title="资源分配的基本单位"></a>资源分配的基本单位</h5><h4 id="4、异步性"><a href="#4、异步性" class="headerlink" title="4、异步性"></a>4、异步性</h4><h5 id="进程各自独立，推进速度不可预知"><a href="#进程各自独立，推进速度不可预知" class="headerlink" title="进程各自独立，推进速度不可预知"></a>进程各自独立，推进速度不可预知</h5><h4 id="5、结构化"><a href="#5、结构化" class="headerlink" title="5、结构化"></a>5、结构化</h4><h5 id="代码段-数据段-程序控制块（PCB）"><a href="#代码段-数据段-程序控制块（PCB）" class="headerlink" title="代码段+数据段+程序控制块（PCB）"></a>代码段+数据段+程序控制块（PCB）</h5><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><h3 id="2-1-5-进程基本状态及转换"><a href="#2-1-5-进程基本状态及转换" class="headerlink" title="2.1.5.     进程基本状态及转换"></a>2.1.5.     进程基本状态及转换</h3><h4 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h4><h5 id="就绪（Ready）状态"><a href="#就绪（Ready）状态" class="headerlink" title="就绪（Ready）状态"></a>就绪（Ready）状态</h5><h5 id="执行（Running）状态"><a href="#执行（Running）状态" class="headerlink" title="执行（Running）状态"></a>执行（Running）状态</h5><h5 id="阻塞（Block）状态"><a href="#阻塞（Block）状态" class="headerlink" title="阻塞（Block）状态"></a>阻塞（Block）状态</h5><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><h5 id="PPT-6"><a href="#PPT-6" class="headerlink" title="PPT-6"></a>PPT-6</h5><h2 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2.     进程控制"></a>2.2.     进程控制</h2><h3 id="2-2-1-程序控制块PCB"><a href="#2-2-1-程序控制块PCB" class="headerlink" title="2.2.1.     程序控制块PCB"></a>2.2.1.     程序控制块PCB</h3><h4 id="1、是描述进程的数据结构，保存与该进程有关的各种数据信息"><a href="#1、是描述进程的数据结构，保存与该进程有关的各种数据信息" class="headerlink" title="1、是描述进程的数据结构，保存与该进程有关的各种数据信息"></a>1、是描述进程的数据结构，保存与该进程有关的各种数据信息</h4><h5 id="1、进程描述信息：进程标识符"><a href="#1、进程描述信息：进程标识符" class="headerlink" title="1、进程描述信息：进程标识符"></a>1、进程描述信息：进程标识符</h5><h5 id="2、处理机状态信息：保存进程运行现场信息"><a href="#2、处理机状态信息：保存进程运行现场信息" class="headerlink" title="2、处理机状态信息：保存进程运行现场信息"></a>2、处理机状态信息：保存进程运行现场信息</h5><h5 id="3、进程调度信息"><a href="#3、进程调度信息" class="headerlink" title="3、进程调度信息"></a>3、进程调度信息</h5><h5 id="4、进程控制信息"><a href="#4、进程控制信息" class="headerlink" title="4、进程控制信息"></a>4、进程控制信息</h5><h4 id="2、进程的唯一标识，每个进程在OS的登记表项"><a href="#2、进程的唯一标识，每个进程在OS的登记表项" class="headerlink" title="2、进程的唯一标识，每个进程在OS的登记表项"></a>2、进程的唯一标识，每个进程在OS的登记表项</h4><h4 id="3、进程创建时生成，终止时回收"><a href="#3、进程创建时生成，终止时回收" class="headerlink" title="3、进程创建时生成，终止时回收"></a>3、进程创建时生成，终止时回收</h4><h4 id="4、在内存核心区，系统调用间接访问"><a href="#4、在内存核心区，系统调用间接访问" class="headerlink" title="4、在内存核心区，系统调用间接访问"></a>4、在内存核心区，系统调用间接访问</h4><h4 id="5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表"><a href="#5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表" class="headerlink" title="5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表"></a>5、OS专门开辟PCB区，把所有PCB组织成若干队列或链表</h4><h5 id="OS怎么管理PCB进行进程调度？"><a href="#OS怎么管理PCB进行进程调度？" class="headerlink" title="OS怎么管理PCB进行进程调度？"></a>OS怎么管理PCB进行进程调度？</h5><h6 id="作业队列：所有进程集合"><a href="#作业队列：所有进程集合" class="headerlink" title="作业队列：所有进程集合"></a>作业队列：所有进程集合</h6><h6 id="就绪队列：就绪进程集合"><a href="#就绪队列：就绪进程集合" class="headerlink" title="就绪队列：就绪进程集合"></a>就绪队列：就绪进程集合</h6><h6 id="设备队列：等待I-O设备的进程集合"><a href="#设备队列：等待I-O设备的进程集合" class="headerlink" title="设备队列：等待I/O设备的进程集合"></a>设备队列：等待I/O设备的进程集合</h6><h6 id="令进程在各种不同的队列中迁移"><a href="#令进程在各种不同的队列中迁移" class="headerlink" title="令进程在各种不同的队列中迁移"></a>令进程在各种不同的队列中迁移</h6><h5 id="PCB组织方式"><a href="#PCB组织方式" class="headerlink" title="PCB组织方式"></a>PCB组织方式</h5><h6 id="同一状态进程的PCB构成一个链表"><a href="#同一状态进程的PCB构成一个链表" class="headerlink" title="同一状态进程的PCB构成一个链表"></a>同一状态进程的PCB构成一个链表</h6><h6 id="同一状态进程归入一个index表，由index指向PCB"><a href="#同一状态进程归入一个index表，由index指向PCB" class="headerlink" title="同一状态进程归入一个index表，由index指向PCB"></a>同一状态进程归入一个index表，由index指向PCB</h6><h3 id="2-2-2-进程管理"><a href="#2-2-2-进程管理" class="headerlink" title="2.2.2.     进程管理"></a>2.2.2.     进程管理</h3><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h5><h6 id="创建、运行、等待、唤醒、终止"><a href="#创建、运行、等待、唤醒、终止" class="headerlink" title="创建、运行、等待、唤醒、终止"></a>创建、运行、等待、唤醒、终止</h6><h5 id="进程控制任务"><a href="#进程控制任务" class="headerlink" title="进程控制任务"></a>进程控制任务</h5><h6 id="进程创建、终止、状态转变"><a href="#进程创建、终止、状态转变" class="headerlink" title="进程创建、终止、状态转变"></a>进程创建、终止、状态转变</h6><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="OS内核原语实现"><a href="#OS内核原语实现" class="headerlink" title="OS内核原语实现"></a>OS内核原语实现</h6><p>原语：若干条指令构成的原子操作</p>
<p>许多系统调用是原语，但不是全部</p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h5 id="引起创建的事件"><a href="#引起创建的事件" class="headerlink" title="引起创建的事件"></a>引起创建的事件</h5><h6 id="1、用户登录"><a href="#1、用户登录" class="headerlink" title="1、用户登录"></a>1、用户登录</h6><h6 id="2、作业调度"><a href="#2、作业调度" class="headerlink" title="2、作业调度"></a>2、作业调度</h6><h6 id="3、提供服务"><a href="#3、提供服务" class="headerlink" title="3、提供服务"></a>3、提供服务</h6><h6 id="4、应用请求"><a href="#4、应用请求" class="headerlink" title="4、应用请求"></a>4、应用请求</h6><h5 id="创建步骤（原语CREATE（））"><a href="#创建步骤（原语CREATE（））" class="headerlink" title="创建步骤（原语CREATE（））"></a>创建步骤（原语CREATE（））</h5><h6 id="1、申请空白PCB"><a href="#1、申请空白PCB" class="headerlink" title="1、申请空白PCB"></a>1、申请空白PCB</h6><h6 id="2、为新进程分配资源"><a href="#2、为新进程分配资源" class="headerlink" title="2、为新进程分配资源"></a>2、为新进程分配资源</h6><h6 id="3、初始化PCB"><a href="#3、初始化PCB" class="headerlink" title="3、初始化PCB"></a>3、初始化PCB</h6><h6 id="4、将新进程插入就绪队列"><a href="#4、将新进程插入就绪队列" class="headerlink" title="4、将新进程插入就绪队列"></a>4、将新进程插入就绪队列</h6><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><h5 id="引起终止的事件"><a href="#引起终止的事件" class="headerlink" title="引起终止的事件"></a>引起终止的事件</h5><h6 id="1、正常结束"><a href="#1、正常结束" class="headerlink" title="1、正常结束"></a>1、正常结束</h6><h6 id="2、异常结束"><a href="#2、异常结束" class="headerlink" title="2、异常结束"></a>2、异常结束</h6><h6 id="3、外界干预"><a href="#3、外界干预" class="headerlink" title="3、外界干预"></a>3、外界干预</h6><h5 id="终止步骤（原语EXIT（））"><a href="#终止步骤（原语EXIT（））" class="headerlink" title="终止步骤（原语EXIT（））"></a>终止步骤（原语EXIT（））</h5><h6 id="1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态"><a href="#1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态" class="headerlink" title="1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态"></a>1、根据进程标识符从PCB集合中检索该进程PCB，读取该进程状态</h6><h6 id="2、若处于执行状态，终止该进程，置调度标志为1，重新调度"><a href="#2、若处于执行状态，终止该进程，置调度标志为1，重新调度" class="headerlink" title="2、若处于执行状态，终止该进程，置调度标志为1，重新调度"></a>2、若处于执行状态，终止该进程，置调度标志为1，重新调度</h6><h6 id="3、有子孙进程就终止"><a href="#3、有子孙进程就终止" class="headerlink" title="3、有子孙进程就终止"></a>3、有子孙进程就终止</h6><h6 id="4、进程资源归还给父进程或者系统"><a href="#4、进程资源归还给父进程或者系统" class="headerlink" title="4、进程资源归还给父进程或者系统"></a>4、进程资源归还给父进程或者系统</h6><h6 id="5、进程PCB移出所在队列"><a href="#5、进程PCB移出所在队列" class="headerlink" title="5、进程PCB移出所在队列"></a>5、进程PCB移出所在队列</h6><h4 id="进程阻塞与唤醒"><a href="#进程阻塞与唤醒" class="headerlink" title="进程阻塞与唤醒"></a>进程阻塞与唤醒</h4><h5 id="引起阻塞与唤醒的事件"><a href="#引起阻塞与唤醒的事件" class="headerlink" title="引起阻塞与唤醒的事件"></a>引起阻塞与唤醒的事件</h5><h6 id="1、请求系统共享资源服务"><a href="#1、请求系统共享资源服务" class="headerlink" title="1、请求系统共享资源服务"></a>1、请求系统共享资源服务</h6><h6 id="2、启动某种操作（例如I-O）"><a href="#2、启动某种操作（例如I-O）" class="headerlink" title="2、启动某种操作（例如I/O）"></a>2、启动某种操作（例如I/O）</h6><h6 id="3、新数据尚未到达"><a href="#3、新数据尚未到达" class="headerlink" title="3、新数据尚未到达"></a>3、新数据尚未到达</h6><h6 id="4、等待新任务的到达"><a href="#4、等待新任务的到达" class="headerlink" title="4、等待新任务的到达"></a>4、等待新任务的到达</h6><h5 id="阻塞步骤（原语BLOCK（））"><a href="#阻塞步骤（原语BLOCK（））" class="headerlink" title="阻塞步骤（原语BLOCK（））"></a>阻塞步骤（原语BLOCK（））</h5><h6 id="1、保存当前进程的CPU现场"><a href="#1、保存当前进程的CPU现场" class="headerlink" title="1、保存当前进程的CPU现场"></a>1、保存当前进程的CPU现场</h6><h6 id="2、置该进程状态（变为阻塞态）"><a href="#2、置该进程状态（变为阻塞态）" class="headerlink" title="2、置该进程状态（变为阻塞态）"></a>2、置该进程状态（变为阻塞态）</h6><h6 id="3、PCB进入等待队列"><a href="#3、PCB进入等待队列" class="headerlink" title="3、PCB进入等待队列"></a>3、PCB进入等待队列</h6><h6 id="4、转进程调度"><a href="#4、转进程调度" class="headerlink" title="4、转进程调度"></a>4、转进程调度</h6><h5 id="唤醒步骤（原语WAKEUP（））"><a href="#唤醒步骤（原语WAKEUP（））" class="headerlink" title="唤醒步骤（原语WAKEUP（））"></a>唤醒步骤（原语WAKEUP（））</h5><h6 id="1、等待队列中摘下被唤醒进程"><a href="#1、等待队列中摘下被唤醒进程" class="headerlink" title="1、等待队列中摘下被唤醒进程"></a>1、等待队列中摘下被唤醒进程</h6><h6 id="2、置该进程状态（变为就绪态）"><a href="#2、置该进程状态（变为就绪态）" class="headerlink" title="2、置该进程状态（变为就绪态）"></a>2、置该进程状态（变为就绪态）</h6><h6 id="3、进入就绪队列"><a href="#3、进入就绪队列" class="headerlink" title="3、进入就绪队列"></a>3、进入就绪队列</h6><h6 id="4、转进程调度或返回"><a href="#4、转进程调度或返回" class="headerlink" title="4、转进程调度或返回"></a>4、转进程调度或返回</h6><h4 id="进程挂起与激活"><a href="#进程挂起与激活" class="headerlink" title="进程挂起与激活"></a>进程挂起与激活</h4><h5 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h5><h6 id="挂起引入原因"><a href="#挂起引入原因" class="headerlink" title="挂起引入原因"></a>挂起引入原因</h6><p>1、终端用户请求</p>
<p>2、父进程请求</p>
<p>3、负荷调节需要</p>
<p>4、OS需要</p>
<h6 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h6><p>合理且充分的利用系统资源</p>
<h6 id="挂起步骤（原语SUSPEND（））"><a href="#挂起步骤（原语SUSPEND（））" class="headerlink" title="挂起步骤（原语SUSPEND（））"></a>挂起步骤（原语SUSPEND（））</h6><p>1、从内存调到外存，改变进程状态</p>
<p>2、若活动就绪/阻塞，转为静止就绪/阻塞</p>
<p>3、若正在执行，则转向调度程序重新调度</p>
<h5 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h5><h6 id="激活引入原因"><a href="#激活引入原因" class="headerlink" title="激活引入原因"></a>激活引入原因</h6><p>1、终端用户请求</p>
<p>2、父进程请求</p>
<p>3、内存空间足够</p>
<h6 id="激活步骤（原语ACTIVE（））"><a href="#激活步骤（原语ACTIVE（））" class="headerlink" title="激活步骤（原语ACTIVE（））"></a>激活步骤（原语ACTIVE（））</h6><p>1、从外存调到内存，改变进程状态</p>
<p>2、也可能引起处理机调度（比较被激活进程优先级和当前进程优先级）</p>
<h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3.     进程同步"></a>2.3.     进程同步</h2><h3 id="2-3-1-基本概念"><a href="#2-3-1-基本概念" class="headerlink" title="2.3.1.     基本概念"></a>2.3.1.     基本概念</h3><h4 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h4><h5 id="间接制约"><a href="#间接制约" class="headerlink" title="间接制约"></a>间接制约</h5><h6 id="进程之间共享某种系统资源而形成的相互制约"><a href="#进程之间共享某种系统资源而形成的相互制约" class="headerlink" title="进程之间共享某种系统资源而形成的相互制约"></a>进程之间共享某种系统资源而形成的相互制约</h6><h5 id="直接制约"><a href="#直接制约" class="headerlink" title="直接制约"></a>直接制约</h5><h6 id="进程间由于合作形成的相互制约"><a href="#进程间由于合作形成的相互制约" class="headerlink" title="进程间由于合作形成的相互制约"></a>进程间由于合作形成的相互制约</h6><h4 id="进程两大关系"><a href="#进程两大关系" class="headerlink" title="进程两大关系"></a>进程两大关系</h4><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><h6 id="由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权"><a href="#由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权" class="headerlink" title="由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权"></a>由于共享资源的排他性，进程之间相互竞争来得到这些资源的使用权</h6><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><h6 id="多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务"><a href="#多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务" class="headerlink" title="多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务"></a>多个进程之间发生的事件存在时序关系，必须协同工作，相互配合，以共同完成一项任务</h6><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><h5 id="一段时间内只允许一个进程访问的资源"><a href="#一段时间内只允许一个进程访问的资源" class="headerlink" title="一段时间内只允许一个进程访问的资源"></a>一段时间内只允许一个进程访问的资源</h5><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><h5 id="每个进程访问临界资源的那段代码被称为临界区"><a href="#每个进程访问临界资源的那段代码被称为临界区" class="headerlink" title="每个进程访问临界资源的那段代码被称为临界区"></a>每个进程访问临界资源的那段代码被称为临界区</h5><h3 id="2-3-2-基本准则"><a href="#2-3-2-基本准则" class="headerlink" title="2.3.2.     基本准则"></a>2.3.2.     基本准则</h3><h4 id="空闲则入"><a href="#空闲则入" class="headerlink" title="空闲则入"></a>空闲则入</h4><h4 id="忙则等待"><a href="#忙则等待" class="headerlink" title="忙则等待"></a>忙则等待</h4><h4 id="有限等待：不能死等"><a href="#有限等待：不能死等" class="headerlink" title="有限等待：不能死等"></a>有限等待：不能死等</h4><h4 id="让权等待：不能进入临界区的进程要释放CPU"><a href="#让权等待：不能进入临界区的进程要释放CPU" class="headerlink" title="让权等待：不能进入临界区的进程要释放CPU"></a>让权等待：不能进入临界区的进程要释放CPU</h4><h3 id="2-3-3-信号量机制"><a href="#2-3-3-信号量机制" class="headerlink" title="2.3.3.     信号量机制"></a>2.3.3.     信号量机制</h3><h4 id="1、整型信号量机制"><a href="#1、整型信号量机制" class="headerlink" title="1、整型信号量机制"></a>1、整型信号量机制</h4><h5 id="表示资源数目的整型量s和原子操作wait-s-signal-s"><a href="#表示资源数目的整型量s和原子操作wait-s-signal-s" class="headerlink" title="表示资源数目的整型量s和原子操作wait(s)+signal(s)"></a>表示资源数目的整型量s和原子操作wait(s)+signal(s)</h5><h4 id="2、记录型信号量机制"><a href="#2、记录型信号量机制" class="headerlink" title="2、记录型信号量机制"></a>2、记录型信号量机制</h4><h5 id="信号量s"><a href="#信号量s" class="headerlink" title="信号量s"></a>信号量s</h5><h6 id="s-count-处置表示某类资源的数目"><a href="#s-count-处置表示某类资源的数目" class="headerlink" title="s.count:处置表示某类资源的数目"></a>s.count:处置表示某类资源的数目</h6><h6 id="s-queue-阻塞在该信号量的各个进程的PCB链成的队列"><a href="#s-queue-阻塞在该信号量的各个进程的PCB链成的队列" class="headerlink" title="s.queue:阻塞在该信号量的各个进程的PCB链成的队列"></a>s.queue:阻塞在该信号量的各个进程的PCB链成的队列</h6><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><h6 id="wait-–s-count-if-s-count-lt-0-block-s-queue"><a href="#wait-–s-count-if-s-count-lt-0-block-s-queue" class="headerlink" title="wait():–s.count;if(s.count&lt;0) block(s.queue);"></a>wait():–s.count;if(s.count&lt;0) block(s.queue);</h6><h6 id="signal-s-count-if-s-count-lt-0-block-s-queue"><a href="#signal-s-count-if-s-count-lt-0-block-s-queue" class="headerlink" title="signal():++s,count;if(s.count&lt;=0) block(s.queue);"></a>signal():++s,count;if(s.count&lt;=0) block(s.queue);</h6><h4 id="3、AND型信号量"><a href="#3、AND型信号量" class="headerlink" title="3、AND型信号量"></a>3、AND型信号量</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><h6 id="将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放"><a href="#将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放" class="headerlink" title="将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放"></a>将进程在整个运行中需要的所有资源一次性全分配给进程，进程使用完后一起释放</h6><h5 id="原子操作-1"><a href="#原子操作-1" class="headerlink" title="原子操作"></a>原子操作</h5><h6 id="Swait"><a href="#Swait" class="headerlink" title="Swait()"></a>Swait()</h6><h4 id="4、二进制信号量"><a href="#4、二进制信号量" class="headerlink" title="4、二进制信号量"></a>4、二进制信号量</h4><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><h6 id="S1-1；S2-0；C-代表共享资源的初始值"><a href="#S1-1；S2-0；C-代表共享资源的初始值" class="headerlink" title="S1=1；S2=0；C=代表共享资源的初始值"></a>S1=1；S2=0；C=代表共享资源的初始值</h6><h3 id="2-3-4-信号量的应用"><a href="#2-3-4-信号量的应用" class="headerlink" title="2.3.4.     信号量的应用"></a>2.3.4.     信号量的应用</h3><h4 id="1、信号量实现互斥"><a href="#1、信号量实现互斥" class="headerlink" title="1、信号量实现互斥"></a>1、信号量实现互斥</h4><h5 id="设置互斥信号量mutex，初值为1"><a href="#设置互斥信号量mutex，初值为1" class="headerlink" title="设置互斥信号量mutex，初值为1"></a>设置互斥信号量mutex，初值为1</h5><h6 id="mutex-1，无进程进入临界区"><a href="#mutex-1，无进程进入临界区" class="headerlink" title="mutex=1，无进程进入临界区"></a>mutex=1，无进程进入临界区</h6><h6 id="mutex-0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列"><a href="#mutex-0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列" class="headerlink" title="mutex=0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列"></a>mutex=0，有一个进入临界区，另一个必须等待，要将他挂入阻塞队列</h6><h6 id="mutex-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒"><a href="#mutex-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒" class="headerlink" title="mutex=-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒"></a>mutex=-1，有一个进入临界区运行，另一个阻塞在信号量队列中，需要当前进程退出后唤醒</h6><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><h6 id="wait-mutex-；临界区；signal-mutex-；剩余区"><a href="#wait-mutex-；临界区；signal-mutex-；剩余区" class="headerlink" title="wait(mutex)；临界区；signal(mutex)；剩余区"></a>wait(mutex)；临界区；signal(mutex)；剩余区</h6><h4 id="2、信号量实现同步"><a href="#2、信号量实现同步" class="headerlink" title="2、信号量实现同步"></a>2、信号量实现同步</h4><h5 id="为每个前驱关系设置一个信号量"><a href="#为每个前驱关系设置一个信号量" class="headerlink" title="为每个前驱关系设置一个信号量"></a>为每个前驱关系设置一个信号量</h5><h3 id="2-3-5-经典的进程同步问题"><a href="#2-3-5-经典的进程同步问题" class="headerlink" title="2.3.5.     经典的进程同步问题"></a>2.3.5.     经典的进程同步问题</h3><h4 id="1、生产者消费者问题"><a href="#1、生产者消费者问题" class="headerlink" title="1、生产者消费者问题"></a>1、生产者消费者问题</h4><h4 id="2、读者写者问题"><a href="#2、读者写者问题" class="headerlink" title="2、读者写者问题"></a>2、读者写者问题</h4><h4 id="3、哲学家进餐问题"><a href="#3、哲学家进餐问题" class="headerlink" title="3、哲学家进餐问题"></a>3、哲学家进餐问题</h4><h2 id="2-4-进程通信"><a href="#2-4-进程通信" class="headerlink" title="2.4.     进程通信"></a>2.4.     进程通信</h2><h3 id="2-4-1-基本概念：进程之间的信息交换"><a href="#2-4-1-基本概念：进程之间的信息交换" class="headerlink" title="2.4.1.     基本概念：进程之间的信息交换"></a>2.4.1.     基本概念：进程之间的信息交换</h3><h4 id="低级通信"><a href="#低级通信" class="headerlink" title="低级通信"></a>低级通信</h4><h5 id="效率低"><a href="#效率低" class="headerlink" title="效率低"></a>效率低</h5><h5 id="通信对用户不透明"><a href="#通信对用户不透明" class="headerlink" title="通信对用户不透明"></a>通信对用户不透明</h5><h5 id="包括信号量和管程机制"><a href="#包括信号量和管程机制" class="headerlink" title="包括信号量和管程机制"></a>包括信号量和管程机制</h5><h4 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h4><h5 id="指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高"><a href="#指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高" class="headerlink" title="指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高"></a>指利用较复杂的一种特定的数据结构进行较大信息量的通信，效率高</h5><h5 id="使用方便；高效地传送大量数据"><a href="#使用方便；高效地传送大量数据" class="headerlink" title="使用方便；高效地传送大量数据"></a>使用方便；高效地传送大量数据</h5><h5 id="包括下面三种系统"><a href="#包括下面三种系统" class="headerlink" title="包括下面三种系统"></a>包括下面三种系统</h5><h3 id="2-4-2-进程通信类型"><a href="#2-4-2-进程通信类型" class="headerlink" title="2.4.2.     进程通信类型"></a>2.4.2.     进程通信类型</h3><h4 id="1、共享存储器系统"><a href="#1、共享存储器系统" class="headerlink" title="1、共享存储器系统"></a>1、共享存储器系统</h4><h5 id="1、共享数据结构"><a href="#1、共享数据结构" class="headerlink" title="1、共享数据结构"></a>1、共享数据结构</h5><h6 id="低级通信-1"><a href="#低级通信-1" class="headerlink" title="低级通信"></a>低级通信</h6><h5 id="2、共享存储区"><a href="#2、共享存储区" class="headerlink" title="2、共享存储区"></a>2、共享存储区</h5><h4 id="2、消息传递系统"><a href="#2、消息传递系统" class="headerlink" title="2、消息传递系统"></a>2、消息传递系统</h4><h5 id="系统提供一组通信原语"><a href="#系统提供一组通信原语" class="headerlink" title="系统提供一组通信原语"></a>系统提供一组通信原语</h5><h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h6><p>发送进程利用OS提供的发送原语把消息之间发送给目标进程</p>
<h6 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h6><p>借助收发进程以外的共享数据结构（比如信箱）作为通信中转</p>
<h4 id="3、管道通信系统"><a href="#3、管道通信系统" class="headerlink" title="3、管道通信系统"></a>3、管道通信系统</h4><h5 id="连接读写进程的一个共享文件，pipe文件"><a href="#连接读写进程的一个共享文件，pipe文件" class="headerlink" title="连接读写进程的一个共享文件，pipe文件"></a>连接读写进程的一个共享文件，pipe文件</h5><h5 id="必须提供的协调能力"><a href="#必须提供的协调能力" class="headerlink" title="必须提供的协调能力"></a>必须提供的协调能力</h5><h6 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h6><h6 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h6><h6 id="确定对方是否存在，只有对方存在才能通信"><a href="#确定对方是否存在，只有对方存在才能通信" class="headerlink" title="确定对方是否存在，只有对方存在才能通信"></a>确定对方是否存在，只有对方存在才能通信</h6><h2 id="2-5-线程Thread简介"><a href="#2-5-线程Thread简介" class="headerlink" title="2.5.     线程Thread简介"></a>2.5.     线程Thread简介</h2><h3 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1.     定义"></a>2.5.1.     定义</h3><h4 id="进程当中的一条执行流程"><a href="#进程当中的一条执行流程" class="headerlink" title="进程当中的一条执行流程"></a>进程当中的一条执行流程</h4><h3 id="2-5-2-属性"><a href="#2-5-2-属性" class="headerlink" title="2.5.2.     属性"></a>2.5.2.     属性</h3><h4 id="1、共享进程资源"><a href="#1、共享进程资源" class="headerlink" title="1、共享进程资源"></a>1、共享进程资源</h4><h4 id="2、轻型实体：每个线程只拥有少量资源"><a href="#2、轻型实体：每个线程只拥有少量资源" class="headerlink" title="2、轻型实体：每个线程只拥有少量资源"></a>2、轻型实体：每个线程只拥有少量资源</h4><h4 id="3、处理机调度的单位"><a href="#3、处理机调度的单位" class="headerlink" title="3、处理机调度的单位"></a>3、处理机调度的单位</h4><h4 id="4、可并发执行"><a href="#4、可并发执行" class="headerlink" title="4、可并发执行"></a>4、可并发执行</h4><h3 id="2-5-3-优缺点"><a href="#2-5-3-优缺点" class="headerlink" title="2.5.3.     优缺点"></a>2.5.3.     优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><h5 id="1、一个进程可对应多个线程"><a href="#1、一个进程可对应多个线程" class="headerlink" title="1、一个进程可对应多个线程"></a>1、一个进程可对应多个线程</h5><h5 id="2、可并发执行"><a href="#2、可并发执行" class="headerlink" title="2、可并发执行"></a>2、可并发执行</h5><h5 id="3、创建和终止时间比进程短"><a href="#3、创建和终止时间比进程短" class="headerlink" title="3、创建和终止时间比进程短"></a>3、创建和终止时间比进程短</h5><h5 id="4、各个线程资源共享，可直接通信不通过OS内核"><a href="#4、各个线程资源共享，可直接通信不通过OS内核" class="headerlink" title="4、各个线程资源共享，可直接通信不通过OS内核"></a>4、各个线程资源共享，可直接通信不通过OS内核</h5><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><h5 id="一个线程崩溃会导致所属进程的所有线程崩溃"><a href="#一个线程崩溃会导致所属进程的所有线程崩溃" class="headerlink" title="一个线程崩溃会导致所属进程的所有线程崩溃"></a>一个线程崩溃会导致所属进程的所有线程崩溃</h5><h3 id="2-5-4-OS支持线程的方法"><a href="#2-5-4-OS支持线程的方法" class="headerlink" title="2.5.4.     OS支持线程的方法"></a>2.5.4.     OS支持线程的方法</h3><h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><h5 id="1、存在于用户空间，内核不了解"><a href="#1、存在于用户空间，内核不了解" class="headerlink" title="1、存在于用户空间，内核不了解"></a>1、存在于用户空间，内核不了解</h5><h5 id="2、应用进程利用线程库函数来控制用户线程"><a href="#2、应用进程利用线程库函数来控制用户线程" class="headerlink" title="2、应用进程利用线程库函数来控制用户线程"></a>2、应用进程利用线程库函数来控制用户线程</h5><h5 id="3、一个线程阻塞，整个进程等待"><a href="#3、一个线程阻塞，整个进程等待" class="headerlink" title="3、一个线程阻塞，整个进程等待"></a>3、一个线程阻塞，整个进程等待</h5><h5 id="4、时间片分配给进程，线程多了每个线程执行时间相对就少"><a href="#4、时间片分配给进程，线程多了每个线程执行时间相对就少" class="headerlink" title="4、时间片分配给进程，线程多了每个线程执行时间相对就少"></a>4、时间片分配给进程，线程多了每个线程执行时间相对就少</h5><h4 id="2、内核线程"><a href="#2、内核线程" class="headerlink" title="2、内核线程"></a>2、内核线程</h4><h5 id="1、OS支持，负责线程的创建、切换等操作"><a href="#1、OS支持，负责线程的创建、切换等操作" class="headerlink" title="1、OS支持，负责线程的创建、切换等操作"></a>1、OS支持，负责线程的创建、切换等操作</h5><h5 id="2、线程的管理慢于用户级线程"><a href="#2、线程的管理慢于用户级线程" class="headerlink" title="2、线程的管理慢于用户级线程"></a>2、线程的管理慢于用户级线程</h5><h5 id="3、一个线程阻塞，整个进程不会阻塞"><a href="#3、一个线程阻塞，整个进程不会阻塞" class="headerlink" title="3、一个线程阻塞，整个进程不会阻塞"></a>3、一个线程阻塞，整个进程不会阻塞</h5><h4 id="ps：多线程模型"><a href="#ps：多线程模型" class="headerlink" title="ps：多线程模型"></a>ps：多线程模型</h4><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><h1 id="3-三、处理机调度和死锁"><a href="#3-三、处理机调度和死锁" class="headerlink" title="3.    三、处理机调度和死锁"></a>3.    三、处理机调度和死锁</h1><h2 id="3-1-处理机调度算法的层次"><a href="#3-1-处理机调度算法的层次" class="headerlink" title="3.1.     处理机调度算法的层次"></a>3.1.     处理机调度算法的层次</h2><h3 id="3-1-1-高级调度"><a href="#3-1-1-高级调度" class="headerlink" title="3.1.1.     高级调度"></a>3.1.1.     高级调度</h3><h4 id="又称：长程调度或作业调度"><a href="#又称：长程调度或作业调度" class="headerlink" title="又称：长程调度或作业调度"></a>又称：长程调度或作业调度</h4><h4 id="调度对象：作业（用户利用计算机进行一次运行所需工作的集合）"><a href="#调度对象：作业（用户利用计算机进行一次运行所需工作的集合）" class="headerlink" title="调度对象：作业（用户利用计算机进行一次运行所需工作的集合）"></a>调度对象：作业（用户利用计算机进行一次运行所需工作的集合）</h4><h4 id="主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列"><a href="#主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列" class="headerlink" title="主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列"></a>主要功能：根据某种算法，决定将后备队列中的哪几个作业调入内存，为它们创建进程、分配必要资源，并将它们放入就绪队列</h4><h4 id="相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度"><a href="#相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度" class="headerlink" title="相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度"></a>相关系统：高级调度主要用于多道批处理系统，而在分时和实时系统中不设置高级调度</h4><h3 id="3-1-2-低级调度"><a href="#3-1-2-低级调度" class="headerlink" title="3.1.2.     低级调度"></a>3.1.2.     低级调度</h3><h4 id="进程调度或短程调度"><a href="#进程调度或短程调度" class="headerlink" title="进程调度或短程调度"></a>进程调度或短程调度</h4><h5 id="非抢先式调度"><a href="#非抢先式调度" class="headerlink" title="非抢先式调度"></a>非抢先式调度</h5><h6 id="拥有处理机的进程完成或阻塞时才把处理机分配给其他进程"><a href="#拥有处理机的进程完成或阻塞时才把处理机分配给其他进程" class="headerlink" title="拥有处理机的进程完成或阻塞时才把处理机分配给其他进程"></a>拥有处理机的进程完成或阻塞时才把处理机分配给其他进程</h6><h5 id="抢先式调度"><a href="#抢先式调度" class="headerlink" title="抢先式调度"></a>抢先式调度</h5><h6 id="允许暂停拥有处理机的进程，重新分配处理机给另一个进程"><a href="#允许暂停拥有处理机的进程，重新分配处理机给另一个进程" class="headerlink" title="允许暂停拥有处理机的进程，重新分配处理机给另一个进程"></a>允许暂停拥有处理机的进程，重新分配处理机给另一个进程</h6><h6 id="时间片原则；优先权原则"><a href="#时间片原则；优先权原则" class="headerlink" title="时间片原则；优先权原则"></a>时间片原则；优先权原则</h6><h4 id="调度对象：进程（或内核级线程）"><a href="#调度对象：进程（或内核级线程）" class="headerlink" title="调度对象：进程（或内核级线程）"></a>调度对象：进程（或内核级线程）</h4><h4 id="主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）"><a href="#主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）" class="headerlink" title="主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）"></a>主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机给被选中的进程。（运行频率最高）</h4><h4 id="相关系统：多道、分时、实时三种类型的OS中，都必须配置"><a href="#相关系统：多道、分时、实时三种类型的OS中，都必须配置" class="headerlink" title="相关系统：多道、分时、实时三种类型的OS中，都必须配置"></a>相关系统：多道、分时、实时三种类型的OS中，都必须配置</h4><h3 id="3-1-3-中级调度"><a href="#3-1-3-中级调度" class="headerlink" title="3.1.3.     中级调度"></a>3.1.3.     中级调度</h3><h4 id="又称：内存调度"><a href="#又称：内存调度" class="headerlink" title="又称：内存调度"></a>又称：内存调度</h4><h4 id="使用目的：提高内存利用率和系统吞吐量"><a href="#使用目的：提高内存利用率和系统吞吐量" class="headerlink" title="使用目的：提高内存利用率和系统吞吐量"></a>使用目的：提高内存利用率和系统吞吐量</h4><h4 id="主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态"><a href="#主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态" class="headerlink" title="主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态"></a>主要功能：把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态</h4><h2 id="3-2-选择处理机调度方式和算法的准则"><a href="#3-2-选择处理机调度方式和算法的准则" class="headerlink" title="3.2.     选择处理机调度方式和算法的准则"></a>3.2.     选择处理机调度方式和算法的准则</h2><h3 id="3-2-1-面向用户"><a href="#3-2-1-面向用户" class="headerlink" title="3.2.1.     面向用户"></a>3.2.1.     面向用户</h3><h4 id="周转时间短"><a href="#周转时间短" class="headerlink" title="周转时间短"></a>周转时间短</h4><h5 id="批处理系统的重要指标：作业从提交到完成（得到结果）"><a href="#批处理系统的重要指标：作业从提交到完成（得到结果）" class="headerlink" title="批处理系统的重要指标：作业从提交到完成（得到结果）"></a>批处理系统的重要指标：作业从提交到完成（得到结果）</h5><h5 id="平均周转时间：完成时间-提交时间"><a href="#平均周转时间：完成时间-提交时间" class="headerlink" title="平均周转时间：完成时间-提交时间"></a>平均周转时间：完成时间-提交时间</h5><h5 id="平均带权周转时间：平均周转时间-CPU执行时间"><a href="#平均带权周转时间：平均周转时间-CPU执行时间" class="headerlink" title="平均带权周转时间：平均周转时间/CPU执行时间"></a>平均带权周转时间：平均周转时间/CPU执行时间</h5><h4 id="响应时间快"><a href="#响应时间快" class="headerlink" title="响应时间快"></a>响应时间快</h4><h5 id="分时系统的重要指标：输入请求到系统给出首次响应的时间"><a href="#分时系统的重要指标：输入请求到系统给出首次响应的时间" class="headerlink" title="分时系统的重要指标：输入请求到系统给出首次响应的时间"></a>分时系统的重要指标：输入请求到系统给出首次响应的时间</h5><h4 id="保证截止时间"><a href="#保证截止时间" class="headerlink" title="保证截止时间"></a>保证截止时间</h4><h5 id="实时系统的重要指标：开始截止时间和完成截止时间"><a href="#实时系统的重要指标：开始截止时间和完成截止时间" class="headerlink" title="实时系统的重要指标：开始截止时间和完成截止时间"></a>实时系统的重要指标：开始截止时间和完成截止时间</h5><h4 id="优先权原则"><a href="#优先权原则" class="headerlink" title="优先权原则"></a>优先权原则</h4><h5 id="批处理、分时、实时系统都可遵循"><a href="#批处理、分时、实时系统都可遵循" class="headerlink" title="批处理、分时、实时系统都可遵循"></a>批处理、分时、实时系统都可遵循</h5><h5 id="公平性：不因为作业或进程本身特性而使上述指标恶化。"><a href="#公平性：不因为作业或进程本身特性而使上述指标恶化。" class="headerlink" title="公平性：不因为作业或进程本身特性而使上述指标恶化。"></a>公平性：不因为作业或进程本身特性而使上述指标恶化。</h5><h3 id="3-2-2-面向系统"><a href="#3-2-2-面向系统" class="headerlink" title="3.2.2.     面向系统"></a>3.2.2.     面向系统</h3><h4 id="系统吞吐量高"><a href="#系统吞吐量高" class="headerlink" title="系统吞吐量高"></a>系统吞吐量高</h4><h5 id="批处理系统的重要指标"><a href="#批处理系统的重要指标" class="headerlink" title="批处理系统的重要指标"></a>批处理系统的重要指标</h5><h5 id="吞吐量：单位时间内所完成的作业数"><a href="#吞吐量：单位时间内所完成的作业数" class="headerlink" title="吞吐量：单位时间内所完成的作业数"></a>吞吐量：单位时间内所完成的作业数</h5><h4 id="处理机利用率高"><a href="#处理机利用率高" class="headerlink" title="处理机利用率高"></a>处理机利用率高</h4><h4 id="资源的平衡利用"><a href="#资源的平衡利用" class="headerlink" title="资源的平衡利用"></a>资源的平衡利用</h4><h3 id="3-2-3-调度算法本身的调度性能准则"><a href="#3-2-3-调度算法本身的调度性能准则" class="headerlink" title="3.2.3.     调度算法本身的调度性能准则"></a>3.2.3.     调度算法本身的调度性能准则</h3><h4 id="易于实现"><a href="#易于实现" class="headerlink" title="易于实现"></a>易于实现</h4><h4 id="执行开销比"><a href="#执行开销比" class="headerlink" title="执行开销比"></a>执行开销比</h4><h2 id="3-3-调度算法"><a href="#3-3-调度算法" class="headerlink" title="3.3.     调度算法"></a>3.3.     调度算法</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1.     定义"></a>3.3.1.     定义</h3><h4 id="根据系统的资源分配策略所规定的资源分配算法"><a href="#根据系统的资源分配策略所规定的资源分配算法" class="headerlink" title="根据系统的资源分配策略所规定的资源分配算法"></a>根据系统的资源分配策略所规定的资源分配算法</h4><h3 id="3-3-2-分类"><a href="#3-3-2-分类" class="headerlink" title="3.3.2.     分类"></a>3.3.2.     分类</h3><h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。"><a href="#按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。" class="headerlink" title="按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。"></a>按作业提交或进程变为就绪状态的先后次序分派CPU，非抢占方式，最简单的算法。</h6><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><h6 id="利于长作业而不利于短作业"><a href="#利于长作业而不利于短作业" class="headerlink" title="利于长作业而不利于短作业"></a>利于长作业而不利于短作业</h6><h6 id="利于CPU繁忙的作业而不利于I-O繁忙的作业"><a href="#利于CPU繁忙的作业而不利于I-O繁忙的作业" class="headerlink" title="利于CPU繁忙的作业而不利于I/O繁忙的作业"></a>利于CPU繁忙的作业而不利于I/O繁忙的作业</h6><h4 id="短作业（进程）优先调度算法（SJF-SPF）"><a href="#短作业（进程）优先调度算法（SJF-SPF）" class="headerlink" title="短作业（进程）优先调度算法（SJF/SPF）"></a>短作业（进程）优先调度算法（SJF/SPF）</h4><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式"><a href="#对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式" class="headerlink" title="对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式"></a>对预计执行时间短的作业（进程）优先分派处理机，通常是非抢占方式</h6><h6 id="对FCFS的改进，目标减少平均周转时间"><a href="#对FCFS的改进，目标减少平均周转时间" class="headerlink" title="对FCFS的改进，目标减少平均周转时间"></a>对FCFS的改进，目标减少平均周转时间</h6><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><p>比FCFS改善平均周转时间和平均带权周转时间</p>
<p>提高系统吞吐量</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>对长作业非常不利</p>
<p>未能根据作业的紧迫程度来划分执行的优先级</p>
<p>不能准确估计作业的执行时间，从而影响调度性能</p>
<h5 id="变型"><a href="#变型" class="headerlink" title="变型"></a>变型</h5><h6 id="最短剩余时间优先（SRT）"><a href="#最短剩余时间优先（SRT）" class="headerlink" title="最短剩余时间优先（SRT）"></a>最短剩余时间优先（SRT）</h6><p>允许抢占</p>
<h6 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h6><p>响应比=（等待时间+要求执行时间）/要求执行时间</p>
<p>FCFS和SJF的折衷</p>
<h4 id="优先权调度算法"><a href="#优先权调度算法" class="headerlink" title="优先权调度算法"></a>优先权调度算法</h4><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h6><p>算法用于作业调度时，系统从后备队列中选择优先权最高的作业装入内存</p>
<h6 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h6><p>算法用于进程调度时，系统从就绪队列中选择优先权最高的作业派发处理机</p>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><p>抢占式和非抢占式，可抢占程度越高，对实时系统满足度越好</p>
<h5 id="优先权类型"><a href="#优先权类型" class="headerlink" title="优先权类型"></a>优先权类型</h5><h6 id="静态优先级"><a href="#静态优先级" class="headerlink" title="静态优先级"></a>静态优先级</h6><p>概念</p>
<p>依据进程类型、对资源需求、用户要求等在创建进程使就确定进程优先级，直到进程终止前都不改变</p>
<p>特点</p>
<p>简单，系统开销小</p>
<p>不精确，仅在要求不高的系统中使用</p>
<h6 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h6><p>概念</p>
<p>在创建时赋予的优先级可以在运行时改变，以便获得更好的调度性能</p>
<h5 id="高响应比优先调度算法（HRRN）"><a href="#高响应比优先调度算法（HRRN）" class="headerlink" title="高响应比优先调度算法（HRRN）"></a>高响应比优先调度算法（HRRN）</h5><h6 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h6><p>服务时间越短/等待时间越长，优先级越高</p>
<h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><p>响应比的计算增加系统开销</p>
<h6 id="响应比-（等待时间-要求执行时间）-要求执行时间"><a href="#响应比-（等待时间-要求执行时间）-要求执行时间" class="headerlink" title="响应比=（等待时间+要求执行时间）/要求执行时间"></a>响应比=（等待时间+要求执行时间）/要求执行时间</h6><h4 id="时间片轮转法（RR）"><a href="#时间片轮转法（RR）" class="headerlink" title="时间片轮转法（RR）"></a>时间片轮转法（RR）</h4><h5 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个"><a href="#就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个" class="headerlink" title="就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个"></a>就绪进程按FCFS原则排成队列，时间片分发给队首进程，时间片完发生时钟中断，暂停执行分发调度机给下一个</h6><h6 id="设计目标：提高资源利用率"><a href="#设计目标：提高资源利用率" class="headerlink" title="设计目标：提高资源利用率"></a>设计目标：提高资源利用率</h6><h5 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h5><h6 id="时间片长度的影响"><a href="#时间片长度的影响" class="headerlink" title="时间片长度的影响"></a>时间片长度的影响</h6><p>太长：退化为FCFS</p>
<p>太短：响应时间长</p>
<h6 id="就绪进程越多，时间片越小"><a href="#就绪进程越多，时间片越小" class="headerlink" title="就绪进程越多，时间片越小"></a>就绪进程越多，时间片越小</h6><h6 id="系统的处理能力应当使用户输入通常在一个时间片内能处理完"><a href="#系统的处理能力应当使用户输入通常在一个时间片内能处理完" class="headerlink" title="系统的处理能力应当使用户输入通常在一个时间片内能处理完"></a>系统的处理能力应当使用户输入通常在一个时间片内能处理完</h6><h4 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h4><h5 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长"><a href="#设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长" class="headerlink" title="设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长"></a>设置多个就绪队列，分别赋予不同的优先级，规定优先级越低则时间片越长</h6><h6 id="当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降"><a href="#当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降" class="headerlink" title="当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降"></a>当一个队列1一个时间片未能执行完，就降低优先级投入到下一个队列的末尾，下一个时间片这个队列1又未完成，就再次下降</h6><h6 id="较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾"><a href="#较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾" class="headerlink" title="较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾"></a>较高优先级队列完成后才执行降低较低优先级的队列；又新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</h6><h5 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h5><h6 id="终端型进程（I-O）"><a href="#终端型进程（I-O）" class="headerlink" title="终端型进程（I/O）"></a>终端型进程（I/O）</h6><p>最高优先级</p>
<h6 id="计算型进程（长批处理作业）"><a href="#计算型进程（长批处理作业）" class="headerlink" title="计算型进程（长批处理作业）"></a>计算型进程（长批处理作业）</h6><p>每次执行完时间片降低优先级</p>
<h6 id="短批处理作业"><a href="#短批处理作业" class="headerlink" title="短批处理作业"></a>短批处理作业</h6><p>先放入最高级，一般1-2级完成</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><h6 id="为提高I-O资源利用率和缩短响应时间照顾I-O型进程"><a href="#为提高I-O资源利用率和缩短响应时间照顾I-O型进程" class="headerlink" title="为提高I/O资源利用率和缩短响应时间照顾I/O型进程"></a>为提高I/O资源利用率和缩短响应时间照顾I/O型进程</h6><h6 id="为提高系统吞吐量和缩短平均周转时间而照顾短进程"><a href="#为提高系统吞吐量和缩短平均周转时间而照顾短进程" class="headerlink" title="为提高系统吞吐量和缩短平均周转时间而照顾短进程"></a>为提高系统吞吐量和缩短平均周转时间而照顾短进程</h6><h6 id="不用估计进程执行时间，动态调节"><a href="#不用估计进程执行时间，动态调节" class="headerlink" title="不用估计进程执行时间，动态调节"></a>不用估计进程执行时间，动态调节</h6><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4.     实时调度"></a>3.4.     实时调度</h2><h3 id="3-4-1-基本条件"><a href="#3-4-1-基本条件" class="headerlink" title="3.4.1.     基本条件"></a>3.4.1.     基本条件</h3><h4 id="1、提供必要信息"><a href="#1、提供必要信息" class="headerlink" title="1、提供必要信息"></a>1、提供必要信息</h4><h5 id="就绪时间"><a href="#就绪时间" class="headerlink" title="就绪时间"></a>就绪时间</h5><h5 id="开始截止时间-结束截止时间"><a href="#开始截止时间-结束截止时间" class="headerlink" title="开始截止时间+结束截止时间"></a>开始截止时间+结束截止时间</h5><h5 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h5><h5 id="资源要求"><a href="#资源要求" class="headerlink" title="资源要求"></a>资源要求</h5><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><h4 id="2、系统处理能力强"><a href="#2、系统处理能力强" class="headerlink" title="2、系统处理能力强"></a>2、系统处理能力强</h4><h5 id="单处理机"><a href="#单处理机" class="headerlink" title="单处理机"></a>单处理机</h5><h6 id="处理时间Ci-周期时间Pi之和-lt-1"><a href="#处理时间Ci-周期时间Pi之和-lt-1" class="headerlink" title="处理时间Ci/周期时间Pi之和&lt;=1"></a>处理时间Ci/周期时间Pi之和&lt;=1</h6><h5 id="多处理机"><a href="#多处理机" class="headerlink" title="多处理机"></a>多处理机</h5><h6 id="处理时间Ci-周期时间Pi之和-lt-N"><a href="#处理时间Ci-周期时间Pi之和-lt-N" class="headerlink" title="处理时间Ci/周期时间Pi之和&lt;=N"></a>处理时间Ci/周期时间Pi之和&lt;=N</h6><h4 id="3、抢占式调度机制"><a href="#3、抢占式调度机制" class="headerlink" title="3、抢占式调度机制"></a>3、抢占式调度机制</h4><h4 id="4、快速切换机制"><a href="#4、快速切换机制" class="headerlink" title="4、快速切换机制"></a>4、快速切换机制</h4><h5 id="对外部中断快速响应"><a href="#对外部中断快速响应" class="headerlink" title="对外部中断快速响应"></a>对外部中断快速响应</h5><h5 id="快速任务分配"><a href="#快速任务分配" class="headerlink" title="快速任务分配"></a>快速任务分配</h5><h3 id="3-4-2-分类"><a href="#3-4-2-分类" class="headerlink" title="3.4.2.     分类"></a>3.4.2.     分类</h3><h4 id="1、非抢占式调度算法"><a href="#1、非抢占式调度算法" class="headerlink" title="1、非抢占式调度算法"></a>1、非抢占式调度算法</h4><h5 id="1、非抢占式轮转调度算法：同RR"><a href="#1、非抢占式轮转调度算法：同RR" class="headerlink" title="1、非抢占式轮转调度算法：同RR"></a>1、非抢占式轮转调度算法：同RR</h5><h5 id="2、非抢占式优先调度算法：严格按优先级"><a href="#2、非抢占式优先调度算法：严格按优先级" class="headerlink" title="2、非抢占式优先调度算法：严格按优先级"></a>2、非抢占式优先调度算法：严格按优先级</h5><h4 id="2、抢占式调度算法"><a href="#2、抢占式调度算法" class="headerlink" title="2、抢占式调度算法"></a>2、抢占式调度算法</h4><h5 id="1、基于时钟中断的抢占式优先权调度算法"><a href="#1、基于时钟中断的抢占式优先权调度算法" class="headerlink" title="1、基于时钟中断的抢占式优先权调度算法"></a>1、基于时钟中断的抢占式优先权调度算法</h5><h6 id="优先级低于当前任务就等待"><a href="#优先级低于当前任务就等待" class="headerlink" title="优先级低于当前任务就等待"></a>优先级低于当前任务就等待</h6><h5 id="2、立即抢占"><a href="#2、立即抢占" class="headerlink" title="2、立即抢占"></a>2、立即抢占</h5><h6 id="立即响应外部中断"><a href="#立即响应外部中断" class="headerlink" title="立即响应外部中断"></a>立即响应外部中断</h6><h3 id="3-4-3-常用实时调度算法"><a href="#3-4-3-常用实时调度算法" class="headerlink" title="3.4.3.     常用实时调度算法"></a>3.4.3.     常用实时调度算法</h3><h4 id="1、最早截止时间优先（EDF）"><a href="#1、最早截止时间优先（EDF）" class="headerlink" title="1、最早截止时间优先（EDF）"></a>1、最早截止时间优先（EDF）</h4><h5 id="抢占-非抢占都可"><a href="#抢占-非抢占都可" class="headerlink" title="抢占/非抢占都可"></a>抢占/非抢占都可</h5><h6 id="子主题"><a href="#子主题" class="headerlink" title="子主题"></a>子主题</h6><h5 id="非抢占式调度方式-gt-非周期实时任务；抢占式调度方式-gt-周期实时任务"><a href="#非抢占式调度方式-gt-非周期实时任务；抢占式调度方式-gt-周期实时任务" class="headerlink" title="非抢占式调度方式-&gt;非周期实时任务；抢占式调度方式-&gt;周期实时任务"></a>非抢占式调度方式-&gt;非周期实时任务；抢占式调度方式-&gt;周期实时任务</h5><h4 id="2、最低松弛度优先算法（LLF）"><a href="#2、最低松弛度优先算法（LLF）" class="headerlink" title="2、最低松弛度优先算法（LLF）"></a>2、最低松弛度优先算法（LLF）</h4><h5 id="主要可抢占"><a href="#主要可抢占" class="headerlink" title="主要可抢占"></a>主要可抢占</h5><h5 id="松弛度越低（紧急度越高），优先级越高"><a href="#松弛度越低（紧急度越高），优先级越高" class="headerlink" title="松弛度越低（紧急度越高），优先级越高"></a>松弛度越低（紧急度越高），优先级越高</h5><h5 id="松弛度-必须完成时间-本身运行时间-当前时间"><a href="#松弛度-必须完成时间-本身运行时间-当前时间" class="headerlink" title="松弛度=必须完成时间-本身运行时间-当前时间"></a>松弛度=必须完成时间-本身运行时间-当前时间</h5><h2 id="3-5-死锁"><a href="#3-5-死锁" class="headerlink" title="3.5.     死锁"></a>3.5.     死锁</h2><h3 id="3-5-1-概念"><a href="#3-5-1-概念" class="headerlink" title="3.5.1.     概念"></a>3.5.1.     概念</h3><h4 id="多个进程争夺资源造成的僵局"><a href="#多个进程争夺资源造成的僵局" class="headerlink" title="多个进程争夺资源造成的僵局"></a>多个进程争夺资源造成的僵局</h4><h3 id="3-5-2-死锁起因"><a href="#3-5-2-死锁起因" class="headerlink" title="3.5.2.     死锁起因"></a>3.5.2.     死锁起因</h3><h4 id="竞争资源"><a href="#竞争资源" class="headerlink" title="竞争资源"></a>竞争资源</h4><h5 id="概念：资源数目不能满足进程需要"><a href="#概念：资源数目不能满足进程需要" class="headerlink" title="概念：资源数目不能满足进程需要"></a>概念：资源数目不能满足进程需要</h5><h5 id="竞争不可抢占性资源-临时性资源"><a href="#竞争不可抢占性资源-临时性资源" class="headerlink" title="竞争不可抢占性资源/临时性资源"></a>竞争不可抢占性资源/临时性资源</h5><h4 id="顺序不当"><a href="#顺序不当" class="headerlink" title="顺序不当"></a>顺序不当</h4><h5 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h5><h3 id="3-5-3-产生死锁的必要条件（同时满足）"><a href="#3-5-3-产生死锁的必要条件（同时满足）" class="headerlink" title="3.5.3.     产生死锁的必要条件（同时满足）"></a>3.5.3.     产生死锁的必要条件（同时满足）</h3><h4 id="1、互斥：任一个时刻只允许一个进程使用资源"><a href="#1、互斥：任一个时刻只允许一个进程使用资源" class="headerlink" title="1、互斥：任一个时刻只允许一个进程使用资源"></a>1、互斥：任一个时刻只允许一个进程使用资源</h4><h4 id="2、请求和保持：进程保持了至少一个资源，但又请求新的资源"><a href="#2、请求和保持：进程保持了至少一个资源，但又请求新的资源" class="headerlink" title="2、请求和保持：进程保持了至少一个资源，但又请求新的资源"></a>2、请求和保持：进程保持了至少一个资源，但又请求新的资源</h4><h4 id="3、不可抢占：已占用资源不可被抢占"><a href="#3、不可抢占：已占用资源不可被抢占" class="headerlink" title="3、不可抢占：已占用资源不可被抢占"></a>3、不可抢占：已占用资源不可被抢占</h4><h4 id="4、环路等待"><a href="#4、环路等待" class="headerlink" title="4、环路等待"></a>4、环路等待</h4><h3 id="3-5-4-处理死锁方法"><a href="#3-5-4-处理死锁方法" class="headerlink" title="3.5.4.     处理死锁方法"></a>3.5.4.     处理死锁方法</h3><h4 id="1、预防死锁"><a href="#1、预防死锁" class="headerlink" title="1、预防死锁"></a>1、预防死锁</h4><h5 id="概念：限制并发进程对资源的请求，使之不同时满足四个条件"><a href="#概念：限制并发进程对资源的请求，使之不同时满足四个条件" class="headerlink" title="概念：限制并发进程对资源的请求，使之不同时满足四个条件"></a>概念：限制并发进程对资源的请求，使之不同时满足四个条件</h5><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5><h6 id="1、摒弃”请求保持“"><a href="#1、摒弃”请求保持“" class="headerlink" title="1、摒弃”请求保持“"></a>1、摒弃”请求保持“</h6><p>预先静态分配法：预先分配全部资源，保证不等待</p>
<p>优点：简单、安全、容易实现</p>
<p>缺点：资源被严重浪费，降低了资源利用率，较低进程并发程度；有可能无法预先知道所有资源</p>
<h6 id="2、摒弃”不可剥夺“"><a href="#2、摒弃”不可剥夺“" class="headerlink" title="2、摒弃”不可剥夺“"></a>2、摒弃”不可剥夺“</h6><p>进程保持了至少一个资源，但又请求新的资源但没得到满足时。立即释放所持有的资源</p>
<p>缺点</p>
<p>实现复杂，要付出代价</p>
<p>重复申请释放资源，降低系统吞吐率</p>
<h6 id="3、摒弃”环路等待“"><a href="#3、摒弃”环路等待“" class="headerlink" title="3、摒弃”环路等待“"></a>3、摒弃”环路等待“</h6><p>有序资源使用法：资源分类按顺序排列，进程按顺序请求</p>
<p>缺点：</p>
<p>资源序号固定，限制新设备增加</p>
<p>降低资源利用率</p>
<p>限制用户简单自主的编程</p>
<h4 id="2、避免死锁"><a href="#2、避免死锁" class="headerlink" title="2、避免死锁"></a>2、避免死锁</h4><h5 id="概念：资源动态分配过程中，防止系统进入不安全状态"><a href="#概念：资源动态分配过程中，防止系统进入不安全状态" class="headerlink" title="概念：资源动态分配过程中，防止系统进入不安全状态"></a>概念：资源动态分配过程中，防止系统进入不安全状态</h5><h5 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h5><h6 id="按照安全序列为进程分配资源使每个进程都可以顺利完成"><a href="#按照安全序列为进程分配资源使每个进程都可以顺利完成" class="headerlink" title="按照安全序列为进程分配资源使每个进程都可以顺利完成"></a>按照安全序列为进程分配资源使每个进程都可以顺利完成</h6><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><h6 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h6><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p>允许互斥、部分分配和不可抢占，可提高资源利用率</p>
<p>要求事先说明最大资源要求，在现实中很困难</p>
<h4 id="3、检测死锁"><a href="#3、检测死锁" class="headerlink" title="3、检测死锁"></a>3、检测死锁</h4><h5 id="概念：允许系统进入死锁，但及时检测"><a href="#概念：允许系统进入死锁，但及时检测" class="headerlink" title="概念：允许系统进入死锁，但及时检测"></a>概念：允许系统进入死锁，但及时检测</h5><h5 id="死锁定理："><a href="#死锁定理：" class="headerlink" title="死锁定理："></a>死锁定理：</h5><h6 id="S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程"><a href="#S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程" class="headerlink" title="S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程"></a>S为死锁状态的充分条件是：当且仅当S状态的资源分配图不可完全简化，其中的有边进程为死锁进程</h6><h6 id="资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤"><a href="#资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤" class="headerlink" title="资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤"></a>资源分配图的化简方法：删除不处于等待状态而且不独立的进程的所有弧，该点变为孤立点，重复步骤</h6><h5 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h5><h5 id="死锁检测算法的应用"><a href="#死锁检测算法的应用" class="headerlink" title="死锁检测算法的应用"></a>死锁检测算法的应用</h5><h4 id="4、解除死锁"><a href="#4、解除死锁" class="headerlink" title="4、解除死锁"></a>4、解除死锁</h4><h5 id="概念：检测到死锁，采取措施解除"><a href="#概念：检测到死锁，采取措施解除" class="headerlink" title="概念：检测到死锁，采取措施解除"></a>概念：检测到死锁，采取措施解除</h5><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h6><p>1、终止所有死锁进程，代价大、容易实现</p>
<p>2、一次只终止一个进程直到消除环路</p>
<h6 id="剥夺资源"><a href="#剥夺资源" class="headerlink" title="剥夺资源"></a>剥夺资源</h6><p>选择一个牺牲者：代价最小</p>
<p>后退：退回到安全状态，重新启动进程/完全回滚，终止进程后重新开始</p>
<p>饿死：避免某进程”饿死“，增加一个元素：做牺牲品的次数</p>
<h1 id="4-四、存储器管理"><a href="#4-四、存储器管理" class="headerlink" title="4.    四、存储器管理"></a>4.    四、存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1.     存储器的层次结构"></a>4.1.     存储器的层次结构</h2><h3 id="4-1-1-存储管理概念"><a href="#4-1-1-存储管理概念" class="headerlink" title="4.1.1.     存储管理概念"></a>4.1.1.     存储管理概念</h3><h4 id="OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存"><a href="#OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存" class="headerlink" title="OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存"></a>OS的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制；而设备和文件管理负责辅存</h4><h4 id="可执行存储器：寄存器-主存"><a href="#可执行存储器：寄存器-主存" class="headerlink" title="可执行存储器：寄存器+主存"></a>可执行存储器：寄存器+主存</h4><h3 id="4-1-2-层次结构"><a href="#4-1-2-层次结构" class="headerlink" title="4.1.2.     层次结构"></a>4.1.2.     层次结构</h3><h4 id="CPU寄存器"><a href="#CPU寄存器" class="headerlink" title="CPU寄存器"></a>CPU寄存器</h4><h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><h6 id="CPU访问速度最快"><a href="#CPU访问速度最快" class="headerlink" title="CPU访问速度最快"></a>CPU访问速度最快</h6><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><h5 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h5><h6 id="备份主存常用数据；减少对主存访问速度"><a href="#备份主存常用数据；减少对主存访问速度" class="headerlink" title="备份主存常用数据；减少对主存访问速度"></a>备份主存常用数据；减少对主存访问速度</h6><h5 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h5><h6 id="保存进程运行时程序和数据，速度远低于处理机执行"><a href="#保存进程运行时程序和数据，速度远低于处理机执行" class="headerlink" title="保存进程运行时程序和数据，速度远低于处理机执行"></a>保存进程运行时程序和数据，速度远低于处理机执行</h6><h5 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h5><h6 id="备份磁盘常用数据，不是独立的存储器（是主存的部分空间）"><a href="#备份磁盘常用数据，不是独立的存储器（是主存的部分空间）" class="headerlink" title="备份磁盘常用数据，不是独立的存储器（是主存的部分空间）"></a>备份磁盘常用数据，不是独立的存储器（是主存的部分空间）</h6><h4 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h4><h5 id="固定磁盘"><a href="#固定磁盘" class="headerlink" title="固定磁盘"></a>固定磁盘</h5><h5 id="可移动存储介质"><a href="#可移动存储介质" class="headerlink" title="可移动存储介质"></a>可移动存储介质</h5><h2 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2.     程序的装入和链接"></a>4.2.     程序的装入和链接</h2><h3 id="4-2-1-程序的处理步骤"><a href="#4-2-1-程序的处理步骤" class="headerlink" title="4.2.1.     程序的处理步骤"></a>4.2.1.     程序的处理步骤</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><h5 id="由编译程序将源程序-cpp-asm-编译成目标模块-obj"><a href="#由编译程序将源程序-cpp-asm-编译成目标模块-obj" class="headerlink" title="由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)"></a>由编译程序将源程序(.cpp,.asm)编译成目标模块(.obj)</h5><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="由链接程序把目标模块-obj-和它们所需要的库函数链接在一起形成装入模块-EXE-DLL"><a href="#由链接程序把目标模块-obj-和它们所需要的库函数链接在一起形成装入模块-EXE-DLL" class="headerlink" title="由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE/DLL)"></a>由链接程序把目标模块(.obj)和它们所需要的库函数链接在一起形成装入模块(EXE/DLL)</h5><h4 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h4><h5 id="由装入程序将装入模块-EXE-DLL-装入内存-成为进程"><a href="#由装入程序将装入模块-EXE-DLL-装入内存-成为进程" class="headerlink" title="由装入程序将装入模块(EXE/DLL)装入内存,成为进程"></a>由装入程序将装入模块(EXE/DLL)装入内存,成为进程</h5><h3 id="4-2-2-程序的装入"><a href="#4-2-2-程序的装入" class="headerlink" title="4.2.2.     程序的装入"></a>4.2.2.     程序的装入</h3><h4 id="1、绝对装入"><a href="#1、绝对装入" class="headerlink" title="1、绝对装入"></a>1、绝对装入</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><h6 id="编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码"><a href="#编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码" class="headerlink" title="编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码"></a>编译程序知道程序将驻留在内存的地址，产生绝对地址（物理地址）的代码</h6><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h6><p>装入过程简单</p>
<h6 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h6><p>依赖硬件结构，适用于单道而不适用于多道程序</p>
<h4 id="2、可重定位装入"><a href="#2、可重定位装入" class="headerlink" title="2、可重定位装入"></a>2、可重定位装入</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><h6 id="装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量"><a href="#装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量" class="headerlink" title="装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量"></a>装入时根据定位的内存地址去修改每个重定位地址项，添加相对偏移量</h6><h6 id="地址变换装入时一次完成，进程不再移动，故称为静态重定位"><a href="#地址变换装入时一次完成，进程不再移动，故称为静态重定位" class="headerlink" title="地址变换装入时一次完成，进程不再移动，故称为静态重定位"></a>地址变换装入时一次完成，进程不再移动，故称为静态重定位</h6><h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h6><p>不需要硬件支持，可放入多道程序</p>
<h6 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h6><p>一个程序装入需要连续的内存空间，装入后不能移动，不易共享</p>
<h4 id="3、动态运行时装入"><a href="#3、动态运行时装入" class="headerlink" title="3、动态运行时装入"></a>3、动态运行时装入</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><h6 id="进程开始执行时部分装入，运行时需要哪个装哪个"><a href="#进程开始执行时部分装入，运行时需要哪个装哪个" class="headerlink" title="进程开始执行时部分装入，运行时需要哪个装哪个"></a>进程开始执行时部分装入，运行时需要哪个装哪个</h6><h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h6><p>可以将一个程序分散在不连续的内存空间中，可以移动，有利于共享</p>
<p>支持程序执行中的地址引用，比如指针变量</p>
<h6 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h6><p>需要硬件支持（通常指CPU），OS实现复杂，是虚拟存储的基础</p>
<h3 id="4-2-3-程序的链接"><a href="#4-2-3-程序的链接" class="headerlink" title="4.2.3.     程序的链接"></a>4.2.3.     程序的链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><h5 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h5><h6 id="程序运行前把目标模块和库函数直接链接，以后不再拆开"><a href="#程序运行前把目标模块和库函数直接链接，以后不再拆开" class="headerlink" title="程序运行前把目标模块和库函数直接链接，以后不再拆开"></a>程序运行前把目标模块和库函数直接链接，以后不再拆开</h6><h6 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h6><p>修改相对地址；变换外部调用符号</p>
<h5 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h6><p>简单易操作</p>
<h6 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h6><p>多用户、多任务冗余（库函数重复）</p>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><h5 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h5><h6 id="边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址"><a href="#边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址" class="headerlink" title="边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址"></a>边装入边链接，即装入一个目标模块时发现由外部模块调用，就去找相应的模块装入并修改相对地址</h6><h5 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h6><p>共享：多个进程共享一个模块</p>
<p>便于修改更新</p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><h5 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h5><h6 id="将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上"><a href="#将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上" class="headerlink" title="将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上"></a>将某些模块的链接推迟到执行时，即执行发现有模块未装入，OS找到该模块并装入，并将其链接到调用者模块上</h6><h5 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h5><h6 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h6><p>部分装入</p>
<p>局部代码修改</p>
<p>便于适应运行环境</p>
<h6 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h6><p>链接开销</p>
<p>管理开销</p>
<h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3.     连续分配存储管理方式"></a>4.3.     连续分配存储管理方式</h2><h3 id="4-3-1-单一连续分配"><a href="#4-3-1-单一连续分配" class="headerlink" title="4.3.1.     单一连续分配"></a>4.3.1.     单一连续分配</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><h5 id="内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间"><a href="#内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间" class="headerlink" title="内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间"></a>内存分为系统区，用户区，应用程序装入用户区，可使用用户区全部空间</h5><h4 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h5><h6 id="最简单，适用于单用户、单任务，易于管理"><a href="#最简单，适用于单用户、单任务，易于管理" class="headerlink" title="最简单，适用于单用户、单任务，易于管理"></a>最简单，适用于单用户、单任务，易于管理</h6><h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><h6 id="不常用的进程也占用内存"><a href="#不常用的进程也占用内存" class="headerlink" title="不常用的进程也占用内存"></a>不常用的进程也占用内存</h6><h6 id="对要求内存空间少的进程，造成内存浪费"><a href="#对要求内存空间少的进程，造成内存浪费" class="headerlink" title="对要求内存空间少的进程，造成内存浪费"></a>对要求内存空间少的进程，造成内存浪费</h6><h3 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2.     固定分区分配"></a>4.3.2.     固定分区分配</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><h5 id="划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）"><a href="#划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）" class="headerlink" title="划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）"></a>划分固定大小（可以不等）的连续分区，每个分区装入一个进程（最简单多道存储管理方式）</h5><h4 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h5><h6 id="易于实现，开销小"><a href="#易于实现，开销小" class="headerlink" title="易于实现，开销小"></a>易于实现，开销小</h6><h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h5><h6 id="内碎片浪费，分区总数固定，限制了并发执行的程序数目"><a href="#内碎片浪费，分区总数固定，限制了并发执行的程序数目" class="headerlink" title="内碎片浪费，分区总数固定，限制了并发执行的程序数目"></a>内碎片浪费，分区总数固定，限制了并发执行的程序数目</h6><h4 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h4><h5 id="分区之内未利用空间"><a href="#分区之内未利用空间" class="headerlink" title="分区之内未利用空间"></a>分区之内未利用空间</h5><h4 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h4><h5 id="分区之间空闲分区（通常是小空闲分区）"><a href="#分区之间空闲分区（通常是小空闲分区）" class="headerlink" title="分区之间空闲分区（通常是小空闲分区）"></a>分区之间空闲分区（通常是小空闲分区）</h5><h3 id="4-3-3-动态分区分配"><a href="#4-3-3-动态分区分配" class="headerlink" title="4.3.3.     动态分区分配"></a>4.3.3.     动态分区分配</h3><h4 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h4><h5 id="OS根据进程的实际需要为各进程分配连续的内存空间"><a href="#OS根据进程的实际需要为各进程分配连续的内存空间" class="headerlink" title="OS根据进程的实际需要为各进程分配连续的内存空间"></a>OS根据进程的实际需要为各进程分配连续的内存空间</h5><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="1、空闲分区表"><a href="#1、空闲分区表" class="headerlink" title="1、空闲分区表"></a>1、空闲分区表</h5><h5 id="2、空闲分区链表"><a href="#2、空闲分区链表" class="headerlink" title="2、空闲分区链表"></a>2、空闲分区链表</h5><h4 id="动态分区算法分类"><a href="#动态分区算法分类" class="headerlink" title="动态分区算法分类"></a>动态分区算法分类</h4><h5 id="1、首次适应算法（first-fit）"><a href="#1、首次适应算法（first-fit）" class="headerlink" title="1、首次适应算法（first-fit）"></a>1、首次适应算法（first-fit）</h5><h6 id="概念：按分区先后次序查找"><a href="#概念：按分区先后次序查找" class="headerlink" title="概念：按分区先后次序查找"></a>概念：按分区先后次序查找</h6><h6 id="优点：分配和释放时间性能较好，空闲分区多分布在内存高端"><a href="#优点：分配和释放时间性能较好，空闲分区多分布在内存高端" class="headerlink" title="优点：分配和释放时间性能较好，空闲分区多分布在内存高端"></a>优点：分配和释放时间性能较好，空闲分区多分布在内存高端</h6><h6 id="缺点：查找时间会逐渐增大"><a href="#缺点：查找时间会逐渐增大" class="headerlink" title="缺点：查找时间会逐渐增大"></a>缺点：查找时间会逐渐增大</h6><h5 id="2、循环首次适应算法（next-fit）"><a href="#2、循环首次适应算法（next-fit）" class="headerlink" title="2、循环首次适应算法（next-fit）"></a>2、循环首次适应算法（next-fit）</h5><h6 id="概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针"><a href="#概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针" class="headerlink" title="概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针"></a>概念：从上次分配的下一个分区开始查找（循环），要设置起始查询指针</h6><h6 id="优点：分配和释放时间性能较好，空闲分区分布均匀"><a href="#优点：分配和释放时间性能较好，空闲分区分布均匀" class="headerlink" title="优点：分配和释放时间性能较好，空闲分区分布均匀"></a>优点：分配和释放时间性能较好，空闲分区分布均匀</h6><h6 id="缺点：较大的空闲分区不宜保留"><a href="#缺点：较大的空闲分区不宜保留" class="headerlink" title="缺点：较大的空闲分区不宜保留"></a>缺点：较大的空闲分区不宜保留</h6><h5 id="3、最佳适应算法（best-fit）"><a href="#3、最佳适应算法（best-fit）" class="headerlink" title="3、最佳适应算法（best-fit）"></a>3、最佳适应算法（best-fit）</h5><h6 id="概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区"><a href="#概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区" class="headerlink" title="概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区"></a>概念：空闲分区表按从小到大排序，找到与进程大小相差最小的分区</h6><h6 id="优点：速度较快，可以保留较大的空闲分区"><a href="#优点：速度较快，可以保留较大的空闲分区" class="headerlink" title="优点：速度较快，可以保留较大的空闲分区"></a>优点：速度较快，可以保留较大的空闲分区</h6><h6 id="缺点：会形成较多外碎片"><a href="#缺点：会形成较多外碎片" class="headerlink" title="缺点：会形成较多外碎片"></a>缺点：会形成较多外碎片</h6><h5 id="4、最坏适应法（worst-fit）"><a href="#4、最坏适应法（worst-fit）" class="headerlink" title="4、最坏适应法（worst-fit）"></a>4、最坏适应法（worst-fit）</h5><h6 id="概念：空闲分区表按从大到小排序，找到最大的空闲分区"><a href="#概念：空闲分区表按从大到小排序，找到最大的空闲分区" class="headerlink" title="概念：空闲分区表按从大到小排序，找到最大的空闲分区"></a>概念：空闲分区表按从大到小排序，找到最大的空闲分区</h6><h6 id="优点：基本不留下小空闲分区"><a href="#优点：基本不留下小空闲分区" class="headerlink" title="优点：基本不留下小空闲分区"></a>优点：基本不留下小空闲分区</h6><h6 id="缺点：较大的空闲分区不被保留"><a href="#缺点：较大的空闲分区不被保留" class="headerlink" title="缺点：较大的空闲分区不被保留"></a>缺点：较大的空闲分区不被保留</h6><h5 id="5、快速适应算法"><a href="#5、快速适应算法" class="headerlink" title="5、快速适应算法"></a>5、快速适应算法</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><p>空闲分区根据容量分类，每类分区容量相同</p>
<p>1、设置空闲分区链表分别指向每类分区</p>
<p>2、管理索引表指向每类空闲分区链表表头</p>
<h6 id="优点：查找效率高，能保留较大分区"><a href="#优点：查找效率高，能保留较大分区" class="headerlink" title="优点：查找效率高，能保留较大分区"></a>优点：查找效率高，能保留较大分区</h6><h6 id="缺点：回收分区时开销大；空闲分区划分越细，浪费越严重"><a href="#缺点：回收分区时开销大；空闲分区划分越细，浪费越严重" class="headerlink" title="缺点：回收分区时开销大；空闲分区划分越细，浪费越严重"></a>缺点：回收分区时开销大；空闲分区划分越细，浪费越严重</h6><h5 id="6、伙伴系统"><a href="#6、伙伴系统" class="headerlink" title="6、伙伴系统"></a>6、伙伴系统</h5><h6 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h6><p>动态分区分配和固定分区分配的折衷方案</p>
<p>规定分配的分区和空闲分区大小都是2的k次方，1&lt;=k&lt;=m</p>
<p>算法性能取决于查找空闲分区的位置和分割、回收空闲分区所花费的时间</p>
<p>分区回收方法：由伙伴碎片就合并，继而又有伙伴碎片，持续往下合并</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>快速搜索合并；外碎片少</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>内部碎片多</p>
<p>按2的幂划分可能产生的内碎片大</p>
<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><h6 id="利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区"><a href="#利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区" class="headerlink" title="利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区"></a>利用某种分配算法，从空闲分区表（链表）中找到所需大小的分区</h6><h5 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h5><h6 id="1、与前一个空闲分区相邻"><a href="#1、与前一个空闲分区相邻" class="headerlink" title="1、与前一个空闲分区相邻"></a>1、与前一个空闲分区相邻</h6><h6 id="2、与后一个空闲分区相邻"><a href="#2、与后一个空闲分区相邻" class="headerlink" title="2、与后一个空闲分区相邻"></a>2、与后一个空闲分区相邻</h6><h6 id="3、与前、后空闲分区相邻"><a href="#3、与前、后空闲分区相邻" class="headerlink" title="3、与前、后空闲分区相邻"></a>3、与前、后空闲分区相邻</h6><h6 id="4、不与空闲分区相邻"><a href="#4、不与空闲分区相邻" class="headerlink" title="4、不与空闲分区相邻"></a>4、不与空闲分区相邻</h6><h3 id="4-3-4-动态重定位分区分配"><a href="#4-3-4-动态重定位分区分配" class="headerlink" title="4.3.4.     动态重定位分区分配"></a>4.3.4.     动态重定位分区分配</h3><h4 id="1、紧凑"><a href="#1、紧凑" class="headerlink" title="1、紧凑"></a>1、紧凑</h4><h5 id="各个占用分区向内存一端移动，使空闲分区合并在另一端"><a href="#各个占用分区向内存一端移动，使空闲分区合并在另一端" class="headerlink" title="各个占用分区向内存一端移动，使空闲分区合并在另一端"></a>各个占用分区向内存一端移动，使空闲分区合并在另一端</h5><h5 id="何时执行紧凑"><a href="#何时执行紧凑" class="headerlink" title="何时执行紧凑"></a>何时执行紧凑</h5><h6 id="每个分区释放后、或者内存分配找不到满足条件的空闲分区时"><a href="#每个分区释放后、或者内存分配找不到满足条件的空闲分区时" class="headerlink" title="每个分区释放后、或者内存分配找不到满足条件的空闲分区时"></a>每个分区释放后、或者内存分配找不到满足条件的空闲分区时</h6><h4 id="2、动态重定位"><a href="#2、动态重定位" class="headerlink" title="2、动态重定位"></a>2、动态重定位</h4><h5 id="不用修改程序，用新起始地址置换原来的起始地址即可"><a href="#不用修改程序，用新起始地址置换原来的起始地址即可" class="headerlink" title="不用修改程序，用新起始地址置换原来的起始地址即可"></a>不用修改程序，用新起始地址置换原来的起始地址即可</h5><h4 id="3、动态重定位分区分配算法"><a href="#3、动态重定位分区分配算法" class="headerlink" title="3、动态重定位分区分配算法"></a>3、动态重定位分区分配算法</h4><h5 id="找得到按动态分区方式分配"><a href="#找得到按动态分区方式分配" class="headerlink" title="找得到按动态分区方式分配"></a>找得到按动态分区方式分配</h5><h5 id="找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回"><a href="#找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回" class="headerlink" title="找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回"></a>找不到就计算剩余空闲分区总和：大于执行紧凑，再分配；小于分配失败，返回</h5><h2 id="4-4-覆盖"><a href="#4-4-覆盖" class="headerlink" title="4.4.     覆盖"></a>4.4.     覆盖</h2><h3 id="4-4-1-引入目标"><a href="#4-4-1-引入目标" class="headerlink" title="4.4.1.     引入目标"></a>4.4.1.     引入目标</h3><h4 id="在较小内存运行较大的程序，常与固定分区配合"><a href="#在较小内存运行较大的程序，常与固定分区配合" class="headerlink" title="在较小内存运行较大的程序，常与固定分区配合"></a>在较小内存运行较大的程序，常与固定分区配合</h4><h3 id="4-4-2-原理"><a href="#4-4-2-原理" class="headerlink" title="4.4.2.     原理"></a>4.4.2.     原理</h3><h4 id="程序的几个代码段和数据段按时间顺序先后占用同一内存空间"><a href="#程序的几个代码段和数据段按时间顺序先后占用同一内存空间" class="headerlink" title="程序的几个代码段和数据段按时间顺序先后占用同一内存空间"></a>程序的几个代码段和数据段按时间顺序先后占用同一内存空间</h4><h5 id="1、必要部分常驻内存"><a href="#1、必要部分常驻内存" class="headerlink" title="1、必要部分常驻内存"></a>1、必要部分常驻内存</h5><h5 id="2、不常用部分其他程序模块实现，平时在外存，要用调入内存"><a href="#2、不常用部分其他程序模块实现，平时在外存，要用调入内存" class="headerlink" title="2、不常用部分其他程序模块实现，平时在外存，要用调入内存"></a>2、不常用部分其他程序模块实现，平时在外存，要用调入内存</h5><h5 id="3、不存在调用关系的模块不提示调入内存，可以相互覆盖"><a href="#3、不存在调用关系的模块不提示调入内存，可以相互覆盖" class="headerlink" title="3、不存在调用关系的模块不提示调入内存，可以相互覆盖"></a>3、不存在调用关系的模块不提示调入内存，可以相互覆盖</h5><h3 id="4-4-3-缺点"><a href="#4-4-3-缺点" class="headerlink" title="4.4.3.     缺点"></a>4.4.3.     缺点</h3><h4 id="增加了编程复杂度：程序员必须了解程序模块之间的划分关系"><a href="#增加了编程复杂度：程序员必须了解程序模块之间的划分关系" class="headerlink" title="增加了编程复杂度：程序员必须了解程序模块之间的划分关系"></a>增加了编程复杂度：程序员必须了解程序模块之间的划分关系</h4><h4 id="外存覆盖内存速度慢，时间换空间"><a href="#外存覆盖内存速度慢，时间换空间" class="headerlink" title="外存覆盖内存速度慢，时间换空间"></a>外存覆盖内存速度慢，时间换空间</h4><h2 id="4-5-对换"><a href="#4-5-对换" class="headerlink" title="4.5.     对换"></a>4.5.     对换</h2><h3 id="4-5-1-概念"><a href="#4-5-1-概念" class="headerlink" title="4.5.1.     概念"></a>4.5.1.     概念</h3><h4 id="将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进-滚出（roll-in-roll-out）"><a href="#将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进-滚出（roll-in-roll-out）" class="headerlink" title="将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进/滚出（roll-in/roll-out）"></a>将暂时不能执行的程序或数据送到外存中，常用于多道程序或小型分时系统，与可重定位分区分配配合使用，又称滚进/滚出（roll-in/roll-out）</h4><h4 id="交换单位"><a href="#交换单位" class="headerlink" title="交换单位"></a>交换单位</h4><h5 id="整个进程的地址空间"><a href="#整个进程的地址空间" class="headerlink" title="整个进程的地址空间"></a>整个进程的地址空间</h5><h3 id="4-5-2-原理"><a href="#4-5-2-原理" class="headerlink" title="4.5.2.     原理"></a>4.5.2.     原理</h3><h4 id="换入"><a href="#换入" class="headerlink" title="换入"></a>换入</h4><h5 id="OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入"><a href="#OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入" class="headerlink" title="OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入"></a>OS定期查看进程状态，内存有空时，选就绪且等待时间最久的进程换入</h5><h4 id="换出"><a href="#换出" class="headerlink" title="换出"></a>换出</h4><h5 id="内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存"><a href="#内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存" class="headerlink" title="内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存"></a>内存无空间时，OS选择阻塞且优先级低的进程换出到对换区，修改PCB，回收内存</h5><h3 id="4-5-3-优缺点"><a href="#4-5-3-优缺点" class="headerlink" title="4.5.3.     优缺点"></a>4.5.3.     优缺点</h3><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><h5 id="增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率"><a href="#增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率" class="headerlink" title="增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率"></a>增加并发进程数目，并给用户提供适当响应时间；提高系统吞吐率</h5><h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><h5 id="对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性"><a href="#对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性" class="headerlink" title="对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性"></a>对换入换出的控制增加处理机开销；对整个进程的地址空间传送，没有考虑执行过程中地址访问的统计特性</h5><h3 id="4-5-4-与覆盖对比"><a href="#4-5-4-与覆盖对比" class="headerlink" title="4.5.4.     与覆盖对比"></a>4.5.4.     与覆盖对比</h3><h4 id="1、交换不要求程序员了解程序段之间的覆盖结构"><a href="#1、交换不要求程序员了解程序段之间的覆盖结构" class="headerlink" title="1、交换不要求程序员了解程序段之间的覆盖结构"></a>1、交换不要求程序员了解程序段之间的覆盖结构</h4><h4 id="2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行"><a href="#2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行" class="headerlink" title="2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行"></a>2、交换在作业或进程之间进行，覆盖在同一作业或进程内执行</h4><h4 id="3、覆盖只能覆盖与覆盖程序段无关的程序段"><a href="#3、覆盖只能覆盖与覆盖程序段无关的程序段" class="headerlink" title="3、覆盖只能覆盖与覆盖程序段无关的程序段"></a>3、覆盖只能覆盖与覆盖程序段无关的程序段</h4><h2 id="4-6-离散分配存储管理方式"><a href="#4-6-离散分配存储管理方式" class="headerlink" title="4.6.     离散分配存储管理方式"></a>4.6.     离散分配存储管理方式</h2><h3 id="4-6-1-连续分配带来的问题：形成内外碎片；紧凑带来开销"><a href="#4-6-1-连续分配带来的问题：形成内外碎片；紧凑带来开销" class="headerlink" title="4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销"></a>4.6.1.     连续分配带来的问题：形成内外碎片；紧凑带来开销</h3><h3 id="4-6-2-分页存储管理方式"><a href="#4-6-2-分页存储管理方式" class="headerlink" title="4.6.2.     分页存储管理方式"></a>4.6.2.     分页存储管理方式</h3><h4 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h4><h5 id="将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB"><a href="#将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB" class="headerlink" title="将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB"></a>将用户程序地地址空间划分为若干固定大小的区域，称为页或页面；页的容量在硬件设计时固定，一般1KB到2KB</h5><h5 id="内存空间划分为和页对应大小的块，称为物理块或页框"><a href="#内存空间划分为和页对应大小的块，称为物理块或页框" class="headerlink" title="内存空间划分为和页对应大小的块，称为物理块或页框"></a>内存空间划分为和页对应大小的块，称为物理块或页框</h5><h5 id="页和块一一对应，由页面映像表记录"><a href="#页和块一一对应，由页面映像表记录" class="headerlink" title="页和块一一对应，由页面映像表记录"></a>页和块一一对应，由页面映像表记录</h5><h4 id="进程装载"><a href="#进程装载" class="headerlink" title="进程装载"></a>进程装载</h4><h5 id="装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。"><a href="#装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。" class="headerlink" title="装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。"></a>装入进程时寻找空闲页框，OS需要将这些页框分配给装入的进程，页框不要求连续，一个页占一个页框，没装满页框就形成页内碎片。</h5><h5 id="要解决地址映像，需要硬件支持"><a href="#要解决地址映像，需要硬件支持" class="headerlink" title="要解决地址映像，需要硬件支持"></a>要解决地址映像，需要硬件支持</h5><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="进程页表："><a href="#进程页表：" class="headerlink" title="进程页表："></a>进程页表：</h5><h6 id="每个进程一个进程页表，描述进程每个页对应的页框"><a href="#每个进程一个进程页表，描述进程每个页对应的页框" class="headerlink" title="每个进程一个进程页表，描述进程每个页对应的页框"></a>每个进程一个进程页表，描述进程每个页对应的页框</h6><h5 id="物理页面表"><a href="#物理页面表" class="headerlink" title="物理页面表"></a>物理页面表</h5><h6 id="描述每个物理页框的分配使用情况；数据结构：位示图-空闲页面列表"><a href="#描述每个物理页框的分配使用情况；数据结构：位示图-空闲页面列表" class="headerlink" title="描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表"></a>描述每个物理页框的分配使用情况；数据结构：位示图+空闲页面列表</h6><h5 id="请求表"><a href="#请求表" class="headerlink" title="请求表"></a>请求表</h5><h6 id="描述系统内各个进程页表的位置和大小，用于地址转换"><a href="#描述系统内各个进程页表的位置和大小，用于地址转换" class="headerlink" title="描述系统内各个进程页表的位置和大小，用于地址转换"></a>描述系统内各个进程页表的位置和大小，用于地址转换</h6><h6 id="请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号"><a href="#请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号" class="headerlink" title="请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号"></a>请求表也可以结合到各进程的PCB里，此时PCB里同时记录对应的物理页框号</h6><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><h5 id="逻辑页号（m-n）-页内偏移量（n位）"><a href="#逻辑页号（m-n）-页内偏移量（n位）" class="headerlink" title="逻辑页号（m-n）+页内偏移量（n位）"></a>逻辑页号（m-n）+页内偏移量（n位）</h5><h5 id="逻辑地址空间2的m次方，页框大小2的n次方"><a href="#逻辑地址空间2的m次方，页框大小2的n次方" class="headerlink" title="逻辑地址空间2的m次方，页框大小2的n次方"></a>逻辑地址空间2的m次方，页框大小2的n次方</h5><h4 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h5><h6 id="没有外碎片，内碎片大小不超过页大小"><a href="#没有外碎片，内碎片大小不超过页大小" class="headerlink" title="没有外碎片，内碎片大小不超过页大小"></a>没有外碎片，内碎片大小不超过页大小</h6><h6 id="程序不必连续存放，便于改变程序占用空间的大小"><a href="#程序不必连续存放，便于改变程序占用空间的大小" class="headerlink" title="程序不必连续存放，便于改变程序占用空间的大小"></a>程序不必连续存放，便于改变程序占用空间的大小</h6><h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h5><h6 id="程序全部装入内存"><a href="#程序全部装入内存" class="headerlink" title="程序全部装入内存"></a>程序全部装入内存</h6><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><h6 id="逻辑地址-逻辑页号-页内偏移地址"><a href="#逻辑地址-逻辑页号-页内偏移地址" class="headerlink" title="逻辑地址=逻辑页号+页内偏移地址"></a>逻辑地址=逻辑页号+页内偏移地址</h6><h6 id="物理地址-页框号-页框内偏移地址"><a href="#物理地址-页框号-页框内偏移地址" class="headerlink" title="物理地址=页框号+页框内偏移地址"></a>物理地址=页框号+页框内偏移地址</h6><h6 id="根据页号查进程页表转换为页框号，页内偏移地址-页框内偏移地址"><a href="#根据页号查进程页表转换为页框号，页内偏移地址-页框内偏移地址" class="headerlink" title="根据页号查进程页表转换为页框号，页内偏移地址=页框内偏移地址"></a>根据页号查进程页表转换为页框号，页内偏移地址=页框内偏移地址</h6><h5 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><h6 id="大多数页表存储在内存中，需访问两次"><a href="#大多数页表存储在内存中，需访问两次" class="headerlink" title="大多数页表存储在内存中，需访问两次"></a>大多数页表存储在内存中，需访问两次</h6><p>第一次读取页表</p>
<p>第二次访问数据</p>
<h6 id="联想（关联）存储器（快表TLB）"><a href="#联想（关联）存储器（快表TLB）" class="headerlink" title="联想（关联）存储器（快表TLB）"></a>联想（关联）存储器（快表TLB）</h6><p>具有并行查找功能的高速缓冲寄存器</p>
<p>根据程序局部性原理，将页表的一部分放在里面（8~32个）</p>
<h6 id="地址变换步骤"><a href="#地址变换步骤" class="headerlink" title="地址变换步骤"></a>地址变换步骤</h6><p>1、首先查找快表，直接命中生成物理地址，访存一次</p>
<p>2、不命中查找内存，置换页表再生成，访存两次</p>
<h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><h5 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h5><h6 id="页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法"><a href="#页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法" class="headerlink" title="页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法"></a>页表过大，解决方法有分散存储和不需要的页表暂存磁盘两种方法</h6><h6 id="分散存储"><a href="#分散存储" class="headerlink" title="分散存储"></a>分散存储</h6><p>将页表分页，每个页面大小与物理页框大小相同，解决难以找到连续的物理内存的问题</p>
<h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><h6 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h6><p>增加页表的页表（外层页表），也叫页目录表，存放页表起始地址</p>
<h6 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><p>外层页号（页表目录）+外存页内地址（页表）+页内地址</p>
<h6 id="访存次数"><a href="#访存次数" class="headerlink" title="访存次数"></a>访存次数</h6><p>3次</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><h6 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h6><p>增加多个页表的页表（外层页表）</p>
<h6 id="访存次数-1"><a href="#访存次数-1" class="headerlink" title="访存次数"></a>访存次数</h6><p>n+1</p>
<h6 id="计算方法："><a href="#计算方法：" class="headerlink" title="计算方法："></a>计算方法：</h6><p>把逻辑地址转换为二进制，根据每位0/1查找页表，加上页内偏移地址就是对应的物理地址了（PPT27）</p>
<h5 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h5><h6 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h6><p>每个进程一张页表，页表按照进程的逻辑地址顺序排序，内容位物理块号（页框号）</p>
<h6 id="检索方式"><a href="#检索方式" class="headerlink" title="检索方式"></a>检索方式</h6><p>根据进程id和页号检索</p>
<h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><p>系统只有一张页表，每个物理页框在页表中只有一项</p>
<p>访问查页表速度慢，可能需要查找整张表</p>
<p>不易于实现页面共享</p>
<h3 id="4-6-3-分段存储管理方式"><a href="#4-6-3-分段存储管理方式" class="headerlink" title="4.6.3.     分段存储管理方式"></a>4.6.3.     分段存储管理方式</h3><h4 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h4><h5 id="按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始"><a href="#按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始" class="headerlink" title="按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始"></a>按逻辑关系划分段，有独立的段名，各段逻辑地址从0开始</h5><h5 id="程序划分为数据段、代码段、和共享段，可以分别编写编译"><a href="#程序划分为数据段、代码段、和共享段，可以分别编写编译" class="headerlink" title="程序划分为数据段、代码段、和共享段，可以分别编写编译"></a>程序划分为数据段、代码段、和共享段，可以分别编写编译</h5><h4 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h4><h5 id="方便编程"><a href="#方便编程" class="headerlink" title="方便编程"></a>方便编程</h5><h5 id="分段共享"><a href="#分段共享" class="headerlink" title="分段共享"></a>分段共享</h5><h5 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h5><h6 id="根据不同类型的段采取不同的保护措施"><a href="#根据不同类型的段采取不同的保护措施" class="headerlink" title="根据不同类型的段采取不同的保护措施"></a>根据不同类型的段采取不同的保护措施</h6><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><h6 id="进程开始时只装入主模块，运行时再根据需要装入其他模块"><a href="#进程开始时只装入主模块，运行时再根据需要装入其他模块" class="headerlink" title="进程开始时只装入主模块，运行时再根据需要装入其他模块"></a>进程开始时只装入主模块，运行时再根据需要装入其他模块</h6><h5 id="动态增长"><a href="#动态增长" class="headerlink" title="动态增长"></a>动态增长</h5><h6 id="比如数据段可能根据需要增大"><a href="#比如数据段可能根据需要增大" class="headerlink" title="比如数据段可能根据需要增大"></a>比如数据段可能根据需要增大</h6><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="进程段表："><a href="#进程段表：" class="headerlink" title="进程段表："></a>进程段表：</h5><h6 id="每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长"><a href="#每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长" class="headerlink" title="每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长"></a>每个进程一个进程段表，描述进程每个段在内存的起始地址（段基址）和段长</h6><h5 id="系统段表"><a href="#系统段表" class="headerlink" title="系统段表"></a>系统段表</h5><h6 id="描述每个占用段的分配使用情况"><a href="#描述每个占用段的分配使用情况" class="headerlink" title="描述每个占用段的分配使用情况"></a>描述每个占用段的分配使用情况</h6><h5 id="空闲段表"><a href="#空闲段表" class="headerlink" title="空闲段表"></a>空闲段表</h5><h6 id="描述每个空闲段，可以结合到系统段表中"><a href="#描述每个空闲段，可以结合到系统段表中" class="headerlink" title="描述每个空闲段，可以结合到系统段表中"></a>描述每个空闲段，可以结合到系统段表中</h6><h4 id="逻辑地址结构-2"><a href="#逻辑地址结构-2" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><h5 id="段号（m-n）-段内地址（n位）"><a href="#段号（m-n）-段内地址（n位）" class="headerlink" title="段号（m-n）+段内地址（n位）"></a>段号（m-n）+段内地址（n位）</h5><h4 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h5><h6 id="没有内碎片，外碎片可以紧凑来消除"><a href="#没有内碎片，外碎片可以紧凑来消除" class="headerlink" title="没有内碎片，外碎片可以紧凑来消除"></a>没有内碎片，外碎片可以紧凑来消除</h6><h6 id="程序不必连续存放，便于改变程序占用空间的大小-1"><a href="#程序不必连续存放，便于改变程序占用空间的大小-1" class="headerlink" title="程序不必连续存放，便于改变程序占用空间的大小"></a>程序不必连续存放，便于改变程序占用空间的大小</h6><h5 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h5><h6 id="程序全部装入内存-1"><a href="#程序全部装入内存-1" class="headerlink" title="程序全部装入内存"></a>程序全部装入内存</h6><h4 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="基本地址变换机构-1"><a href="#基本地址变换机构-1" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h5><h6 id="逻辑地址-段号S-段内地址d"><a href="#逻辑地址-段号S-段内地址d" class="headerlink" title="逻辑地址=段号S+段内地址d"></a>逻辑地址=段号S+段内地址d</h6><h6 id="段表寄存器-段表始地址f-段表长度TL"><a href="#段表寄存器-段表始地址f-段表长度TL" class="headerlink" title="段表寄存器=段表始地址f+段表长度TL"></a>段表寄存器=段表始地址f+段表长度TL</h6><h6 id="段表-段长SL-段基址d"><a href="#段表-段长SL-段基址d" class="headerlink" title="段表=段长SL+段基址d"></a>段表=段长SL+段基址d</h6><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>1、比较段号S和段表长度TL，若S&gt;TL，访问越界，产生越界中断信号</p>
<p>2、未越界：根据段表始地址f和段号S，计算该段对应段表项的位置，从而读出该段在内存的起始地址</p>
<p>3、比较段内地址d是否超过该段段长SL，若d&gt;SL,访问越界，产生越界中断信号</p>
<p>4、未越界，段基址d与段内地址d相加得到物理地址</p>
<h5 id="具有快表的地址变换机构-1"><a href="#具有快表的地址变换机构-1" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h5><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><h5 id="1、单位：页是物理单位，段是逻辑单位。"><a href="#1、单位：页是物理单位，段是逻辑单位。" class="headerlink" title="1、单位：页是物理单位，段是逻辑单位。"></a>1、单位：页是物理单位，段是逻辑单位。</h5><h5 id="2、目的：分页目的是系统管理，分段目的是用户需要"><a href="#2、目的：分页目的是系统管理，分段目的是用户需要" class="headerlink" title="2、目的：分页目的是系统管理，分段目的是用户需要"></a>2、目的：分页目的是系统管理，分段目的是用户需要</h5><h5 id="3、大小：页大小系统固定，段不固定"><a href="#3、大小：页大小系统固定，段不固定" class="headerlink" title="3、大小：页大小系统固定，段不固定"></a>3、大小：页大小系统固定，段不固定</h5><h5 id="4、地址空间：分页一维（页号），分段二维（段号-段内地址）"><a href="#4、地址空间：分页一维（页号），分段二维（段号-段内地址）" class="headerlink" title="4、地址空间：分页一维（页号），分段二维（段号+段内地址）"></a>4、地址空间：分页一维（页号），分段二维（段号+段内地址）</h5><h5 id="5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度"><a href="#5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度" class="headerlink" title="5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度"></a>5、缩短时间：段比页大，因而段表比页表短，可以提高查询速度</h5><h5 id="6、共享：分段方便共享代码"><a href="#6、共享：分段方便共享代码" class="headerlink" title="6、共享：分段方便共享代码"></a>6、共享：分段方便共享代码</h5><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><h5 id="能共享的代码必须是可重入代码"><a href="#能共享的代码必须是可重入代码" class="headerlink" title="能共享的代码必须是可重入代码"></a>能共享的代码必须是可重入代码</h5><h5 id="可重入代码："><a href="#可重入代码：" class="headerlink" title="可重入代码："></a>可重入代码：</h5><h6 id="允许多个进程同时访问，代码执行时不允许修改"><a href="#允许多个进程同时访问，代码执行时不允许修改" class="headerlink" title="允许多个进程同时访问，代码执行时不允许修改"></a>允许多个进程同时访问，代码执行时不允许修改</h6><h5 id="调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量"><a href="#调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量" class="headerlink" title="调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量"></a>调用可重入代码的进程都有自己的局部数据区，用来拷贝执行过程中可能改变的变量</h5><h3 id="4-6-4-段页式存储管理方式"><a href="#4-6-4-段页式存储管理方式" class="headerlink" title="4.6.4.     段页式存储管理方式"></a>4.6.4.     段页式存储管理方式</h3><h4 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h4><h5 id="段内分页，先将用户程序分为若干段，每个段再分为若干页"><a href="#段内分页，先将用户程序分为若干段，每个段再分为若干页" class="headerlink" title="段内分页，先将用户程序分为若干段，每个段再分为若干页"></a>段内分页，先将用户程序分为若干段，每个段再分为若干页</h5><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="每个进程一张段表，每个段一张页表。"><a href="#每个进程一张段表，每个段一张页表。" class="headerlink" title="每个进程一张段表，每个段一张页表。"></a>每个进程一张段表，每个段一张页表。</h5><h5 id="段表-段表大小-段表首地址"><a href="#段表-段表大小-段表首地址" class="headerlink" title="段表=段表大小+段表首地址"></a>段表=段表大小+段表首地址</h5><h5 id="页表-段号-段内页号-页内偏移量"><a href="#页表-段号-段内页号-页内偏移量" class="headerlink" title="页表=段号+段内页号+页内偏移量"></a>页表=段号+段内页号+页内偏移量</h5><h4 id="地址变换机构-2"><a href="#地址变换机构-2" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><h5 id="暂定"><a href="#暂定" class="headerlink" title="暂定"></a>暂定</h5><h1 id="5-五、虚拟存储器"><a href="#5-五、虚拟存储器" class="headerlink" title="5.    五、虚拟存储器"></a>5.    五、虚拟存储器</h1><h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1.     虚拟存储器概述"></a>5.1.     虚拟存储器概述</h2><h3 id="5-1-1-问题"><a href="#5-1-1-问题" class="headerlink" title="5.1.1.     问题"></a>5.1.1.     问题</h3><h4 id="前面介绍的方式：1、进程一次性装入内存-2、有大量进程等待运行，但实际内存不足以全部装入"><a href="#前面介绍的方式：1、进程一次性装入内存-2、有大量进程等待运行，但实际内存不足以全部装入" class="headerlink" title="前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入"></a>前面介绍的方式：1、进程一次性装入内存 2、有大量进程等待运行，但实际内存不足以全部装入</h4><h3 id="5-1-2-常规存储管理方式特征"><a href="#5-1-2-常规存储管理方式特征" class="headerlink" title="5.1.2.     常规存储管理方式特征"></a>5.1.2.     常规存储管理方式特征</h3><h4 id="1、一次性"><a href="#1、一次性" class="headerlink" title="1、一次性"></a>1、一次性</h4><h4 id="2、程序的驻留性"><a href="#2、程序的驻留性" class="headerlink" title="2、程序的驻留性"></a>2、程序的驻留性</h4><h5 id="装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用"><a href="#装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用" class="headerlink" title="装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用"></a>装入的进程一直在内存（即使阻塞），但装入的程序不一定马上作用</h5><h3 id="5-1-3-定义"><a href="#5-1-3-定义" class="headerlink" title="5.1.3.     定义"></a>5.1.3.     定义</h3><h4 id="是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统"><a href="#是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统" class="headerlink" title="是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统"></a>是指具有请求调入和置换功能，逻辑上扩充内存的存储器系统</h4><h4 id="借助于外存空间，允许一个进程在其运行过程只部分装入"><a href="#借助于外存空间，允许一个进程在其运行过程只部分装入" class="headerlink" title="借助于外存空间，允许一个进程在其运行过程只部分装入"></a>借助于外存空间，允许一个进程在其运行过程只部分装入</h4><h4 id="虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和"><a href="#虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和" class="headerlink" title="虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和"></a>虚拟地址空间大小由指令的寻址空间决定，但进程实际大小不可超过物理内存和外存之和</h4><h4 id="对用户透明，用户地址空间称为虚存空间或虚地址空间"><a href="#对用户透明，用户地址空间称为虚存空间或虚地址空间" class="headerlink" title="对用户透明，用户地址空间称为虚存空间或虚地址空间"></a>对用户透明，用户地址空间称为虚存空间或虚地址空间</h4><h3 id="5-1-4-工作过程"><a href="#5-1-4-工作过程" class="headerlink" title="5.1.4.     工作过程"></a>5.1.4.     工作过程</h3><h4 id="1、进程部分装入"><a href="#1、进程部分装入" class="headerlink" title="1、进程部分装入"></a>1、进程部分装入</h4><h4 id="2、执行时内容不在内存（缺页-缺段），请求调入"><a href="#2、执行时内容不在内存（缺页-缺段），请求调入" class="headerlink" title="2、执行时内容不在内存（缺页/缺段），请求调入"></a>2、执行时内容不在内存（缺页/缺段），请求调入</h4><h4 id="3、若此时内存已满，请求置换"><a href="#3、若此时内存已满，请求置换" class="headerlink" title="3、若此时内存已满，请求置换"></a>3、若此时内存已满，请求置换</h4><h3 id="5-1-5-好处"><a href="#5-1-5-好处" class="headerlink" title="5.1.5.     好处"></a>5.1.5.     好处</h3><h4 id="1、较小的内存可以运行较大的进程"><a href="#1、较小的内存可以运行较大的进程" class="headerlink" title="1、较小的内存可以运行较大的进程"></a>1、较小的内存可以运行较大的进程</h4><h4 id="2、容纳更多进程并发执行"><a href="#2、容纳更多进程并发执行" class="headerlink" title="2、容纳更多进程并发执行"></a>2、容纳更多进程并发执行</h4><h4 id="3、不影响编程的程序结构（和覆盖不同）"><a href="#3、不影响编程的程序结构（和覆盖不同）" class="headerlink" title="3、不影响编程的程序结构（和覆盖不同）"></a>3、不影响编程的程序结构（和覆盖不同）</h4><h4 id="4、提供的虚拟内存空间大于物理内存"><a href="#4、提供的虚拟内存空间大于物理内存" class="headerlink" title="4、提供的虚拟内存空间大于物理内存"></a>4、提供的虚拟内存空间大于物理内存</h4><h3 id="5-1-6-局部性原理"><a href="#5-1-6-局部性原理" class="headerlink" title="5.1.6.     局部性原理"></a>5.1.6.     局部性原理</h3><h4 id="指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域"><a href="#指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域" class="headerlink" title="指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域"></a>指程序执行的较短时期，执行的指令地址和指令的操作数地址分别局限与一个较小的区域</h4><h4 id="1、时间局部性"><a href="#1、时间局部性" class="headerlink" title="1、时间局部性"></a>1、时间局部性</h4><h5 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h5><h6 id="指令-数据的执行-访问局限在较短时期"><a href="#指令-数据的执行-访问局限在较短时期" class="headerlink" title="指令/数据的执行/访问局限在较短时期"></a>指令/数据的执行/访问局限在较短时期</h6><h4 id="2、空间局部性"><a href="#2、空间局部性" class="headerlink" title="2、空间局部性"></a>2、空间局部性</h4><h5 id="顺序执行-1"><a href="#顺序执行-1" class="headerlink" title="顺序执行"></a>顺序执行</h5><h6 id="访问的地址局限在一定范围内（例如·数组）"><a href="#访问的地址局限在一定范围内（例如·数组）" class="headerlink" title="访问的地址局限在一定范围内（例如·数组）"></a>访问的地址局限在一定范围内（例如·数组）</h6><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h3 id="5-1-7-实现方式"><a href="#5-1-7-实现方式" class="headerlink" title="5.1.7.     实现方式"></a>5.1.7.     实现方式</h3><h4 id="分页请求系统"><a href="#分页请求系统" class="headerlink" title="分页请求系统"></a>分页请求系统</h4><h5 id="纯分页系统-请求调页-页面置换——页面虚拟存储器"><a href="#纯分页系统-请求调页-页面置换——页面虚拟存储器" class="headerlink" title="纯分页系统+请求调页+页面置换——页面虚拟存储器"></a>纯分页系统+请求调页+页面置换——页面虚拟存储器</h5><h5 id="1、硬件支持"><a href="#1、硬件支持" class="headerlink" title="1、硬件支持"></a>1、硬件支持</h5><h6 id="1、页表增加项"><a href="#1、页表增加项" class="headerlink" title="1、页表增加项"></a>1、页表增加项</h6><h6 id="2、缺页中断"><a href="#2、缺页中断" class="headerlink" title="2、缺页中断"></a>2、缺页中断</h6><h6 id="3、地址变换机构"><a href="#3、地址变换机构" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h6><h5 id="2、实现请求分页的软件"><a href="#2、实现请求分页的软件" class="headerlink" title="2、实现请求分页的软件"></a>2、实现请求分页的软件</h5><h4 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h4><h5 id="纯分段系统-请求调段-分段置换——段式虚拟存储器"><a href="#纯分段系统-请求调段-分段置换——段式虚拟存储器" class="headerlink" title="纯分段系统+请求调段+分段置换——段式虚拟存储器"></a>纯分段系统+请求调段+分段置换——段式虚拟存储器</h5><h5 id="1、硬件支持-1"><a href="#1、硬件支持-1" class="headerlink" title="1、硬件支持"></a>1、硬件支持</h5><h6 id="1、段表增加项"><a href="#1、段表增加项" class="headerlink" title="1、段表增加项"></a>1、段表增加项</h6><h6 id="2、缺段中断"><a href="#2、缺段中断" class="headerlink" title="2、缺段中断"></a>2、缺段中断</h6><h6 id="3、地址变换机构-1"><a href="#3、地址变换机构-1" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h6><h5 id="需要CPU、MMU支持，段页式"><a href="#需要CPU、MMU支持，段页式" class="headerlink" title="需要CPU、MMU支持，段页式"></a>需要CPU、MMU支持，段页式</h5><h3 id="5-1-8-特征"><a href="#5-1-8-特征" class="headerlink" title="5.1.8.     特征"></a>5.1.8.     特征</h3><h4 id="1、多次性"><a href="#1、多次性" class="headerlink" title="1、多次性"></a>1、多次性</h4><h5 id="进程-作业多次调度"><a href="#进程-作业多次调度" class="headerlink" title="进程/作业多次调度"></a>进程/作业多次调度</h5><h4 id="2、对换性"><a href="#2、对换性" class="headerlink" title="2、对换性"></a>2、对换性</h4><h4 id="3、虚拟性"><a href="#3、虚拟性" class="headerlink" title="3、虚拟性"></a>3、虚拟性</h4><h5 id="逻辑地址空间-gt-实际物理内存"><a href="#逻辑地址空间-gt-实际物理内存" class="headerlink" title="逻辑地址空间&gt;实际物理内存"></a>逻辑地址空间&gt;实际物理内存</h5><h4 id="4、离散性"><a href="#4、离散性" class="headerlink" title="4、离散性"></a>4、离散性</h4><h5 id="进程的物理空间不连续"><a href="#进程的物理空间不连续" class="headerlink" title="进程的物理空间不连续"></a>进程的物理空间不连续</h5><h2 id="5-2-请求分页存储器管理方式"><a href="#5-2-请求分页存储器管理方式" class="headerlink" title="5.2.     请求分页存储器管理方式"></a>5.2.     请求分页存储器管理方式</h2><h3 id="5-2-1-概念"><a href="#5-2-1-概念" class="headerlink" title="5.2.1.     概念"></a>5.2.1.     概念</h3><h4 id="在基础分页存储管理基础上增加请求调页和页面置换功能"><a href="#在基础分页存储管理基础上增加请求调页和页面置换功能" class="headerlink" title="在基础分页存储管理基础上增加请求调页和页面置换功能"></a>在基础分页存储管理基础上增加请求调页和页面置换功能</h4><h4 id="基本单位：长度固定的页"><a href="#基本单位：长度固定的页" class="headerlink" title="基本单位：长度固定的页"></a>基本单位：长度固定的页</h4><h4 id="ps-虚拟存储是最常用的实现方式"><a href="#ps-虚拟存储是最常用的实现方式" class="headerlink" title="ps:虚拟存储是最常用的实现方式"></a>ps:虚拟存储是最常用的实现方式</h4><h3 id="5-2-2-硬件支持"><a href="#5-2-2-硬件支持" class="headerlink" title="5.2.2.     硬件支持"></a>5.2.2.     硬件支持</h3><h4 id="1、进程页表：增加项"><a href="#1、进程页表：增加项" class="headerlink" title="1、进程页表：增加项"></a>1、进程页表：增加项</h4><h5 id="1、状态位：在内存还是外存"><a href="#1、状态位：在内存还是外存" class="headerlink" title="1、状态位：在内存还是外存"></a>1、状态位：在内存还是外存</h5><h5 id="2、修改位：该页是否修改过"><a href="#2、修改位：该页是否修改过" class="headerlink" title="2、修改位：该页是否修改过"></a>2、修改位：该页是否修改过</h5><h5 id="3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔"><a href="#3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔" class="headerlink" title="3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔"></a>3、访问字段：被访问过的次数或最近访问时间点到现在的时间间隔</h5><h5 id="4、外存地址：磁盘地址"><a href="#4、外存地址：磁盘地址" class="headerlink" title="4、外存地址：磁盘地址"></a>4、外存地址：磁盘地址</h5><h4 id="2、缺页中断机构"><a href="#2、缺页中断机构" class="headerlink" title="2、缺页中断机构"></a>2、缺页中断机构</h4><h5 id="概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序"><a href="#概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序" class="headerlink" title="概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序"></a>概念：当进程访问的页不在内存，产生缺页中断，调用OS提供的中断处理程序</h5><h5 id="缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）"><a href="#缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）" class="headerlink" title="缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）"></a>缺页中断的特殊性：缺页中断可能在指令执行期间产生和处理，所缺的页被调入内存后，立即执行被中断的指令（从取指开始）</h5><h4 id="3、地址变换机构-2"><a href="#3、地址变换机构-2" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h4><h5 id="在原基础上增加缺页中断，具体看PPT29"><a href="#在原基础上增加缺页中断，具体看PPT29" class="headerlink" title="在原基础上增加缺页中断，具体看PPT29"></a>在原基础上增加缺页中断，具体看PPT29</h5><h3 id="5-2-3-内存分配"><a href="#5-2-3-内存分配" class="headerlink" title="5.2.3.     内存分配"></a>5.2.3.     内存分配</h3><h4 id="1、最小物理块数的确定"><a href="#1、最小物理块数的确定" class="headerlink" title="1、最小物理块数的确定"></a>1、最小物理块数的确定</h4><h5 id="OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行"><a href="#OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行" class="headerlink" title="OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行"></a>OS需要保证进程运行所需最小物理块数，少了缺页中断频繁，甚至进程无法运行</h5><h5 id="进程运行最小页框数和指令系统有关"><a href="#进程运行最小页框数和指令系统有关" class="headerlink" title="进程运行最小页框数和指令系统有关"></a>进程运行最小页框数和指令系统有关</h5><h6 id="1、单地址-直接寻址"><a href="#1、单地址-直接寻址" class="headerlink" title="1、单地址+直接寻址"></a>1、单地址+直接寻址</h6><p>2个页面</p>
<h6 id="2、间接寻址"><a href="#2、间接寻址" class="headerlink" title="2、间接寻址"></a>2、间接寻址</h6><p>3个页面</p>
<h6 id="3、如swap-A，B"><a href="#3、如swap-A，B" class="headerlink" title="3、如swap A，B"></a>3、如swap A，B</h6><p>至少6个</p>
<h4 id="2、物理块的分配策略"><a href="#2、物理块的分配策略" class="headerlink" title="2、物理块的分配策略"></a>2、物理块的分配策略</h4><h5 id="1、固定分配局部置换"><a href="#1、固定分配局部置换" class="headerlink" title="1、固定分配局部置换"></a>1、固定分配局部置换</h5><h6 id="每个进程分配固定页框"><a href="#每个进程分配固定页框" class="headerlink" title="每个进程分配固定页框"></a>每个进程分配固定页框</h6><h6 id="缺页从该进程所属页框调出旧页面，换出新页面"><a href="#缺页从该进程所属页框调出旧页面，换出新页面" class="headerlink" title="缺页从该进程所属页框调出旧页面，换出新页面"></a>缺页从该进程所属页框调出旧页面，换出新页面</h6><h6 id="困难点："><a href="#困难点：" class="headerlink" title="困难点："></a>困难点：</h6><p>分配多少页框合适</p>
<p>多了内存可装入进程减少</p>
<p>少了缺页中断频繁</p>
<h5 id="2、可变分配全局置换（最易实现）"><a href="#2、可变分配全局置换（最易实现）" class="headerlink" title="2、可变分配全局置换（最易实现）"></a>2、可变分配全局置换（最易实现）</h5><h6 id="每个进程分配固定页框，OS控制一定数量的空闲页框"><a href="#每个进程分配固定页框，OS控制一定数量的空闲页框" class="headerlink" title="每个进程分配固定页框，OS控制一定数量的空闲页框"></a>每个进程分配固定页框，OS控制一定数量的空闲页框</h6><h6 id="缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框"><a href="#缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框" class="headerlink" title="缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框"></a>缺页先给该进程分配空闲页框，若快用完空闲页框，OS根据需要随意从进程中调出一个页框</h6><h6 id="困难点：-1"><a href="#困难点：-1" class="headerlink" title="困难点："></a>困难点：</h6><p>不公平</p>
<h5 id="2、可变分配局部置换"><a href="#2、可变分配局部置换" class="headerlink" title="2、可变分配局部置换"></a>2、可变分配局部置换</h5><h6 id="每个进程分配固定页框，OS控制一定数量空闲页框"><a href="#每个进程分配固定页框，OS控制一定数量空闲页框" class="headerlink" title="每个进程分配固定页框，OS控制一定数量空闲页框"></a>每个进程分配固定页框，OS控制一定数量空闲页框</h6><h6 id="缺页先计算缺页中断率"><a href="#缺页先计算缺页中断率" class="headerlink" title="缺页先计算缺页中断率"></a>缺页先计算缺页中断率</h6><p>中断率低：从该进程所属页框调出旧页面，换出新页面</p>
<p>中断率高：OS给该进程分配空闲页框</p>
<h6 id="困难点：-2"><a href="#困难点：-2" class="headerlink" title="困难点："></a>困难点：</h6><p>统计缺页中断率增加系统开销</p>
<h4 id="3、物理块的分配算法"><a href="#3、物理块的分配算法" class="headerlink" title="3、物理块的分配算法"></a>3、物理块的分配算法</h4><h5 id="1、平均分配"><a href="#1、平均分配" class="headerlink" title="1、平均分配"></a>1、平均分配</h5><h5 id="2、按比例分配"><a href="#2、按比例分配" class="headerlink" title="2、按比例分配"></a>2、按比例分配</h5><h5 id="3、按优先权分配"><a href="#3、按优先权分配" class="headerlink" title="3、按优先权分配"></a>3、按优先权分配</h5><h2 id="5-3-页面调入"><a href="#5-3-页面调入" class="headerlink" title="5.3.     页面调入"></a>5.3.     页面调入</h2><h3 id="5-3-1-页面调入策略"><a href="#5-3-1-页面调入策略" class="headerlink" title="5.3.1.     页面调入策略"></a>5.3.1.     页面调入策略</h3><h4 id="OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入"><a href="#OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入" class="headerlink" title="OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入"></a>OS必须在进程执行前将所需要的页面调入内存，问题是：何时何处以及如何调入</h4><h4 id="1、何时调入"><a href="#1、何时调入" class="headerlink" title="1、何时调入"></a>1、何时调入</h4><h5 id="1、预调页"><a href="#1、预调页" class="headerlink" title="1、预调页"></a>1、预调页</h5><h6 id="缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）"><a href="#缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）" class="headerlink" title="缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）"></a>缺页时一次性调入该页及相邻的几个页（基于预测，常用于进程装入）</h6><h5 id="2、请求调页"><a href="#2、请求调页" class="headerlink" title="2、请求调页"></a>2、请求调页</h5><h6 id="缺页只调缺的这一页"><a href="#缺页只调缺的这一页" class="headerlink" title="缺页只调缺的这一页"></a>缺页只调缺的这一页</h6><h4 id="2、何处调入"><a href="#2、何处调入" class="headerlink" title="2、何处调入"></a>2、何处调入</h4><h5 id="1、进程运行前"><a href="#1、进程运行前" class="headerlink" title="1、进程运行前"></a>1、进程运行前</h5><h6 id="全部页面从文件区调入交换区，以后都从交换区调"><a href="#全部页面从文件区调入交换区，以后都从交换区调" class="headerlink" title="全部页面从文件区调入交换区，以后都从交换区调"></a>全部页面从文件区调入交换区，以后都从交换区调</h6><h5 id="2、运行中"><a href="#2、运行中" class="headerlink" title="2、运行中"></a>2、运行中</h5><h6 id="未被修改的页面一直从文件区调"><a href="#未被修改的页面一直从文件区调" class="headerlink" title="未被修改的页面一直从文件区调"></a>未被修改的页面一直从文件区调</h6><h6 id="被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><a href="#被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区" class="headerlink" title="被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"></a>被修改的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</h6><h5 id="3、UNIX方式"><a href="#3、UNIX方式" class="headerlink" title="3、UNIX方式"></a>3、UNIX方式</h5><h6 id="未运行的页面一直从文件区调"><a href="#未运行的页面一直从文件区调" class="headerlink" title="未运行的页面一直从文件区调"></a>未运行的页面一直从文件区调</h6><h6 id="运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"><a href="#运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区" class="headerlink" title="运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区"></a>运行过的页面被置换时先调入交换区，以后都从交换区调它，进程结束时更新文件区</h6><h3 id="5-3-2-页面调入过程"><a href="#5-3-2-页面调入过程" class="headerlink" title="5.3.2.     页面调入过程"></a>5.3.2.     页面调入过程</h3><h4 id="PPT30"><a href="#PPT30" class="headerlink" title="PPT30"></a>PPT30</h4><h3 id="5-3-3-页面调入算法"><a href="#5-3-3-页面调入算法" class="headerlink" title="5.3.3.     页面调入算法"></a>5.3.3.     页面调入算法</h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><h5 id="内存满时，选择内存中哪个页面置换"><a href="#内存满时，选择内存中哪个页面置换" class="headerlink" title="内存满时，选择内存中哪个页面置换"></a>内存满时，选择内存中哪个页面置换</h5><h4 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h4><h5 id="降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”"><a href="#降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”" class="headerlink" title="降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”"></a>降低缺页中断率，应把不使用和较少使用的页面优先调出，通常只能依据局部性原理预测；相反会“抖动”</h5><h4 id="页面锁定"><a href="#页面锁定" class="headerlink" title="页面锁定"></a>页面锁定</h4><h5 id="OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志"><a href="#OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志" class="headerlink" title="OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志"></a>OS的关键部分或事件关键的应用程序必须常驻内存，实现方法为页表加上锁定标志</h5><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><h5 id="1、最佳置换算法（OPT）"><a href="#1、最佳置换算法（OPT）" class="headerlink" title="1、最佳置换算法（OPT）"></a>1、最佳置换算法（OPT）</h5><h6 id="选择“以后不用的”或”离当前位置最远的“页面置换"><a href="#选择“以后不用的”或”离当前位置最远的“页面置换" class="headerlink" title="选择“以后不用的”或”离当前位置最远的“页面置换"></a>选择“以后不用的”或”离当前位置最远的“页面置换</h6><h6 id="理想情况，不能实现，只作为评价依据"><a href="#理想情况，不能实现，只作为评价依据" class="headerlink" title="理想情况，不能实现，只作为评价依据"></a>理想情况，不能实现，只作为评价依据</h6><h5 id="2、先进先出置换算法（FIFO）"><a href="#2、先进先出置换算法（FIFO）" class="headerlink" title="2、先进先出置换算法（FIFO）"></a>2、先进先出置换算法（FIFO）</h5><h6 id="选择“建立最早”页面置换"><a href="#选择“建立最早”页面置换" class="headerlink" title="选择“建立最早”页面置换"></a>选择“建立最早”页面置换</h6><h6 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h6><p>链表表示建立时间先后</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>性能较差，较早进入的页一般也是经常访问的页</p>
<p>可能有Belady现象</p>
<h6 id="Belady现象："><a href="#Belady现象：" class="headerlink" title="Belady现象："></a>Belady现象：</h6><p>OS分配N个内存给进程，对一个访问序列S，N增大时，缺页次数PE（S，N）时而增大，时而减小</p>
<p>现象原因：FIFO置换特征与进程访问内存动态特征矛盾，即，置换页面并不是进程不会访问的</p>
<h5 id="3、最近最久未使用置换算法（LRU）"><a href="#3、最近最久未使用置换算法（LRU）" class="headerlink" title="3、最近最久未使用置换算法（LRU）"></a>3、最近最久未使用置换算法（LRU）</h5><h6 id="利用最近的过去预测最近的将来，选择“最久未使用”页面置换"><a href="#利用最近的过去预测最近的将来，选择“最久未使用”页面置换" class="headerlink" title="利用最近的过去预测最近的将来，选择“最久未使用”页面置换"></a>利用最近的过去预测最近的将来，选择“最久未使用”页面置换</h6><h6 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h6><p>记录首次访问以来过去的时间t</p>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><p>由于记录使用时间，增加系统硬件开销</p>
<h6 id="硬件机构"><a href="#硬件机构" class="headerlink" title="硬件机构"></a>硬件机构</h6><p>1、设立栈：被访问的页面挪到栈顶，于是栈底是最久未访问页面</p>
<p>2、页面设立移位寄存器：被访问时左边最高位置1，短期右移且最高位补0，寄存器值最小则为最久未访问页面</p>
<h5 id="4、Clock置换算法"><a href="#4、Clock置换算法" class="headerlink" title="4、Clock置换算法"></a>4、Clock置换算法</h5><h6 id="又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合"><a href="#又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合" class="headerlink" title="又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合"></a>又称最近未使用算法（NRU）或二次机会算法，是FIFO和LRU的结合</h6><h6 id="一、简单Clock置换算法"><a href="#一、简单Clock置换算法" class="headerlink" title="一、简单Clock置换算法"></a>一、简单Clock置换算法</h6><p>方法：</p>
<p>每页设置访问标志位A，被访问过置1</p>
<p>步骤：</p>
<p>1、按照FIFO算法，寻找A=0做置换页，同时途中改A=1的页为A=0；</p>
<p>2、若所有页面都检查过，回到开头重新开始</p>
<p>3、最后指针停放在置换页的下一页</p>
<h6 id="二、改进Clock置换算法"><a href="#二、改进Clock置换算法" class="headerlink" title="二、改进Clock置换算法"></a>二、改进Clock置换算法</h6><p>方法：</p>
<p>每页设置访问标志位A和修改位M，被访问或修改过置1</p>
<p>步骤：</p>
<p>1、按照FIFO算法，寻找A=0，W=0做置换页，不改A=0；</p>
<p>2、按照FIFO算法，寻找A=0，W=1做置换页，更改A=0；</p>
<p>3、还没找到，回到1、2继续找，这回一定找得到</p>
<h5 id="ps：其他置换算法"><a href="#ps：其他置换算法" class="headerlink" title="ps：其他置换算法"></a>ps：其他置换算法</h5><h6 id="5、最少使用置换算法（LFU）"><a href="#5、最少使用置换算法（LFU）" class="headerlink" title="5、最少使用置换算法（LFU）"></a>5、最少使用置换算法（LFU）</h6><p>又称最不常用算法</p>
<p>选择“最少访问”页面置换</p>
<p>方法：</p>
<p>设置访问计数器，计算访问次数</p>
<p>缺页中断时调入值最小的页面并清空所有计数器</p>
<h6 id="6、页面缓冲算法（PB）"><a href="#6、页面缓冲算法（PB）" class="headerlink" title="6、页面缓冲算法（PB）"></a>6、页面缓冲算法（PB）</h6><p>FIFO的发展，有机会回收刚被置换的页面</p>
<p>方法：设置两个链表</p>
<p>空闲页面链表</p>
<p>已修改页面链表</p>
<p>步骤：</p>
<p>被置换页面未修改，直接归入空闲列表末尾；否则归入已修改链表</p>
<p>调入新页，新页内容读入空闲列表第一项，删除第一项</p>
<p>已修改页面在达到一定值时，一次性写回外存；此期间有被再次访问的页，可以直接在内存调入，减少I/O访问次数</p>
<h2 id="5-4-抖动与工作集"><a href="#5-4-抖动与工作集" class="headerlink" title="5.4.     抖动与工作集"></a>5.4.     抖动与工作集</h2><h3 id="5-4-1-缺页率与页框数"><a href="#5-4-1-缺页率与页框数" class="headerlink" title="5.4.1.     缺页率与页框数"></a>5.4.1.     缺页率与页框数</h3><h4 id="缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点"><a href="#缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点" class="headerlink" title="缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点"></a>缺页率随进程分配到的页框数的增加而降低，但达到某个数后会趋于平稳（拐弯点</h4><h3 id="5-4-2-工作集"><a href="#5-4-2-工作集" class="headerlink" title="5.4.2.     工作集"></a>5.4.2.     工作集</h3><h4 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h4><h5 id="w-△-t-某段时间间隔-t-△-，t-里-t是执行时刻），进程实际要访问的页面的集合"><a href="#w-△-t-某段时间间隔-t-△-，t-里-t是执行时刻），进程实际要访问的页面的集合" class="headerlink" title="w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合"></a>w(△,t) 某段时间间隔[t-△,，t]里(t是执行时刻），进程实际要访问的页面的集合</h5><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><h5 id="随△单调递增"><a href="#随△单调递增" class="headerlink" title="随△单调递增"></a>随△单调递增</h5><h5 id="局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值"><a href="#局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值" class="headerlink" title="局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值"></a>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</h5><h4 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h4><h5 id="依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来"><a href="#依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来" class="headerlink" title="依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来"></a>依据进程访问过的页面集合调整OS分配给该进程的页框数，即过去预测未来</h5><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="OS跟着进程们，分配给进程大于工作集的帧数"><a href="#OS跟着进程们，分配给进程大于工作集的帧数" class="headerlink" title="OS跟着进程们，分配给进程大于工作集的帧数"></a>OS跟着进程们，分配给进程大于工作集的帧数</h5><h5 id="有空闲帧，启动另一个进程"><a href="#有空闲帧，启动另一个进程" class="headerlink" title="有空闲帧，启动另一个进程"></a>有空闲帧，启动另一个进程</h5><h5 id="如果所有工作集之和大于帧总数，OS选择挂起某个进程"><a href="#如果所有工作集之和大于帧总数，OS选择挂起某个进程" class="headerlink" title="如果所有工作集之和大于帧总数，OS选择挂起某个进程"></a>如果所有工作集之和大于帧总数，OS选择挂起某个进程</h5><h4 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h4><h5 id="工作集防止了抖动，提高了程序并发度"><a href="#工作集防止了抖动，提高了程序并发度" class="headerlink" title="工作集防止了抖动，提高了程序并发度"></a>工作集防止了抖动，提高了程序并发度</h5><h4 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h4><h5 id="过去预测未来可能不准确"><a href="#过去预测未来可能不准确" class="headerlink" title="过去预测未来可能不准确"></a>过去预测未来可能不准确</h5><h5 id="记录工作集变化增加了开销，开销大"><a href="#记录工作集变化增加了开销，开销大" class="headerlink" title="记录工作集变化增加了开销，开销大"></a>记录工作集变化增加了开销，开销大</h5><h5 id="△取值难以优化，而且通常该值不断改变"><a href="#△取值难以优化，而且通常该值不断改变" class="headerlink" title="△取值难以优化，而且通常该值不断改变"></a>△取值难以优化，而且通常该值不断改变</h5><h3 id="5-4-3-抖动"><a href="#5-4-3-抖动" class="headerlink" title="5.4.3.     抖动"></a>5.4.3.     抖动</h3><h4 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h4><h5 id="每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动"><a href="#每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动" class="headerlink" title="每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动"></a>每个进程大部分时间由于页面置换导致CPU利用率急剧下降，叫做抖动</h5><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><h5 id="随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）"><a href="#随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）" class="headerlink" title="随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）"></a>随着并发度上升，利用率先上升后下降（后期时间缺页率上升，都用来处理页面置换了）</h5><h5 id="因此要选个合适的进程数目"><a href="#因此要选个合适的进程数目" class="headerlink" title="因此要选个合适的进程数目"></a>因此要选个合适的进程数目</h5><h4 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h4><h5 id="1、引入工作集算法"><a href="#1、引入工作集算法" class="headerlink" title="1、引入工作集算法"></a>1、引入工作集算法</h5><h5 id="2、挂起若干进程"><a href="#2、挂起若干进程" class="headerlink" title="2、挂起若干进程"></a>2、挂起若干进程</h5><h5 id="3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I-O等待队列中）"><a href="#3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I-O等待队列中）" class="headerlink" title="3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I/O等待队列中）"></a>3、采用局部置换策略，把抖动局限在较小范围内（但一旦进程抖动，会长时间在磁盘I/O等待队列中）</h5><h5 id="4、L-S准则：产生缺页的时间L-系统处理缺页的平均时间S，此时CPU利用率最好"><a href="#4、L-S准则：产生缺页的时间L-系统处理缺页的平均时间S，此时CPU利用率最好" class="headerlink" title="4、L=S准则：产生缺页的时间L=系统处理缺页的平均时间S，此时CPU利用率最好"></a>4、L=S准则：产生缺页的时间L=系统处理缺页的平均时间S，此时CPU利用率最好</h5><h2 id="5-5-请求分段存储器管理方式"><a href="#5-5-请求分段存储器管理方式" class="headerlink" title="5.5.     请求分段存储器管理方式"></a>5.5.     请求分段存储器管理方式</h2><h3 id="5-5-1-概念"><a href="#5-5-1-概念" class="headerlink" title="5.5.1.     概念"></a>5.5.1.     概念</h3><h4 id="在基础分段存储管理基础上增加请求调段和段置换功能"><a href="#在基础分段存储管理基础上增加请求调段和段置换功能" class="headerlink" title="在基础分段存储管理基础上增加请求调段和段置换功能"></a>在基础分段存储管理基础上增加请求调段和段置换功能</h4><h4 id="基本单位：长度不固定的段"><a href="#基本单位：长度不固定的段" class="headerlink" title="基本单位：长度不固定的段"></a>基本单位：长度不固定的段</h4><h3 id="5-5-2-硬件支持"><a href="#5-5-2-硬件支持" class="headerlink" title="5.5.2.     硬件支持"></a>5.5.2.     硬件支持</h3><h4 id="1、进程页表：增加项-1"><a href="#1、进程页表：增加项-1" class="headerlink" title="1、进程页表：增加项"></a>1、进程页表：增加项</h4><h5 id="1、存取方式：只执行、只读、读-写"><a href="#1、存取方式：只执行、只读、读-写" class="headerlink" title="1、存取方式：只执行、只读、读/写"></a>1、存取方式：只执行、只读、读/写</h5><h5 id="2、增补位：是否动态增长"><a href="#2、增补位：是否动态增长" class="headerlink" title="2、增补位：是否动态增长"></a>2、增补位：是否动态增长</h5><h5 id="其他和请求分页一样"><a href="#其他和请求分页一样" class="headerlink" title="其他和请求分页一样"></a>其他和请求分页一样</h5><h4 id="2、缺段中断机构"><a href="#2、缺段中断机构" class="headerlink" title="2、缺段中断机构"></a>2、缺段中断机构</h4><h5 id="分段越界中断处理；分段保护中断处理；缺段中断处理"><a href="#分段越界中断处理；分段保护中断处理；缺段中断处理" class="headerlink" title="分段越界中断处理；分段保护中断处理；缺段中断处理"></a>分段越界中断处理；分段保护中断处理；缺段中断处理</h5><h4 id="3、地址变换机构-3"><a href="#3、地址变换机构-3" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h4><h5 id="在原基础上增加缺段中断，具体看PPT32"><a href="#在原基础上增加缺段中断，具体看PPT32" class="headerlink" title="在原基础上增加缺段中断，具体看PPT32"></a>在原基础上增加缺段中断，具体看PPT32</h5><h3 id="5-5-3-分段共享"><a href="#5-5-3-分段共享" class="headerlink" title="5.5.3.     分段共享"></a>5.5.3.     分段共享</h3><h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h5><h6 id="系统中配置一张，所有共享段在该表中都有一项PPT32"><a href="#系统中配置一张，所有共享段在该表中都有一项PPT32" class="headerlink" title="系统中配置一张，所有共享段在该表中都有一项PPT32"></a>系统中配置一张，所有共享段在该表中都有一项PPT32</h6><h4 id="共享段的分配与回收"><a href="#共享段的分配与回收" class="headerlink" title="共享段的分配与回收"></a>共享段的分配与回收</h4><h5 id="1、分配"><a href="#1、分配" class="headerlink" title="1、分配"></a>1、分配</h5><h6 id="首次用共享段，调入内存，填写共享段表项，置共享进程计数count-1"><a href="#首次用共享段，调入内存，填写共享段表项，置共享进程计数count-1" class="headerlink" title="首次用共享段，调入内存，填写共享段表项，置共享进程计数count=1"></a>首次用共享段，调入内存，填写共享段表项，置共享进程计数count=1</h6><h6 id="其他进程使用，count"><a href="#其他进程使用，count" class="headerlink" title="其他进程使用，count++"></a>其他进程使用，count++</h6><h5 id="2、回收"><a href="#2、回收" class="headerlink" title="2、回收"></a>2、回收</h5><h6 id="修改共享段表，count-0"><a href="#修改共享段表，count-0" class="headerlink" title="修改共享段表，count=0"></a>修改共享段表，count=0</h6><h6 id="将该段占用内存回收"><a href="#将该段占用内存回收" class="headerlink" title="将该段占用内存回收"></a>将该段占用内存回收</h6><h5 id="另外，共享段一般不放入外存"><a href="#另外，共享段一般不放入外存" class="headerlink" title="另外，共享段一般不放入外存"></a>另外，共享段一般不放入外存</h5><h3 id="5-5-4-分段保护"><a href="#5-5-4-分段保护" class="headerlink" title="5.5.4.     分段保护"></a>5.5.4.     分段保护</h3><h4 id="1、越界检查"><a href="#1、越界检查" class="headerlink" title="1、越界检查"></a>1、越界检查</h4><h4 id="2、存取控制检查"><a href="#2、存取控制检查" class="headerlink" title="2、存取控制检查"></a>2、存取控制检查</h4><h4 id="3、环保护机构"><a href="#3、环保护机构" class="headerlink" title="3、环保护机构"></a>3、环保护机构</h4><h5 id="低环有高优先权，OS在0环"><a href="#低环有高优先权，OS在0环" class="headerlink" title="低环有高优先权，OS在0环"></a>低环有高优先权，OS在0环</h5><h5 id="访问调用原则"><a href="#访问调用原则" class="headerlink" title="访问调用原则"></a>访问调用原则</h5><h6 id="一个程序可访问相同环或低优先权环的数据"><a href="#一个程序可访问相同环或低优先权环的数据" class="headerlink" title="一个程序可访问相同环或低优先权环的数据"></a>一个程序可访问相同环或低优先权环的数据</h6><h6 id="一个程序可调用相同环或高优先权环的数据"><a href="#一个程序可调用相同环或高优先权环的数据" class="headerlink" title="一个程序可调用相同环或高优先权环的数据"></a>一个程序可调用相同环或高优先权环的数据</h6><h1 id="6-六、设备管理"><a href="#6-六、设备管理" class="headerlink" title="6.    六、设备管理"></a>6.    六、设备管理</h1><h2 id="6-1-设备管理概述"><a href="#6-1-设备管理概述" class="headerlink" title="6.1.     设备管理概述"></a>6.1.     设备管理概述</h2><h3 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1.     概念"></a>6.1.1.     概念</h3><h4 id="OS中负责I-O设备管理的部分叫做I-O系统，完成设备管理功能，对OS影响非常大"><a href="#OS中负责I-O设备管理的部分叫做I-O系统，完成设备管理功能，对OS影响非常大" class="headerlink" title="OS中负责I/O设备管理的部分叫做I/O系统，完成设备管理功能，对OS影响非常大"></a>OS中负责I/O设备管理的部分叫做I/O系统，完成设备管理功能，对OS影响非常大</h4><h4 id="设备管理是最繁杂且与硬件关联最紧密的部分"><a href="#设备管理是最繁杂且与硬件关联最紧密的部分" class="headerlink" title="设备管理是最繁杂且与硬件关联最紧密的部分"></a>设备管理是最繁杂且与硬件关联最紧密的部分</h4><h3 id="6-1-2-主要对象"><a href="#6-1-2-主要对象" class="headerlink" title="6.1.2.     主要对象"></a>6.1.2.     主要对象</h3><h4 id="I-O设备，设备控制器，I-O通道"><a href="#I-O设备，设备控制器，I-O通道" class="headerlink" title="I/O设备，设备控制器，I/O通道"></a>I/O设备，设备控制器，I/O通道</h4><h3 id="6-1-3-基本任务"><a href="#6-1-3-基本任务" class="headerlink" title="6.1.3.     基本任务"></a>6.1.3.     基本任务</h3><h4 id="完成用户I-O请求，提高I-O效率，提高I-O设备利用率"><a href="#完成用户I-O请求，提高I-O效率，提高I-O设备利用率" class="headerlink" title="完成用户I/O请求，提高I/O效率，提高I/O设备利用率"></a>完成用户I/O请求，提高I/O效率，提高I/O设备利用率</h4><h3 id="6-1-4-主要功能"><a href="#6-1-4-主要功能" class="headerlink" title="6.1.4.     主要功能"></a>6.1.4.     主要功能</h3><h4 id="缓存区管理；设备分配-管理；虚拟存储；实现设备独立性"><a href="#缓存区管理；设备分配-管理；虚拟存储；实现设备独立性" class="headerlink" title="缓存区管理；设备分配/管理；虚拟存储；实现设备独立性"></a>缓存区管理；设备分配/管理；虚拟存储；实现设备独立性</h4><h2 id="6-2-I-O系统概述"><a href="#6-2-I-O系统概述" class="headerlink" title="6.2.     I/O系统概述"></a>6.2.     I/O系统概述</h2><h3 id="6-2-1-I-O系统组成"><a href="#6-2-1-I-O系统组成" class="headerlink" title="6.2.1.     I/O系统组成"></a>6.2.1.     I/O系统组成</h3><h4 id="I-O设备，设备控制器及接口，I-O通道，总线等"><a href="#I-O设备，设备控制器及接口，I-O通道，总线等" class="headerlink" title="I/O设备，设备控制器及接口，I/O通道，总线等"></a>I/O设备，设备控制器及接口，I/O通道，总线等</h4><h3 id="6-2-2-I-O设备类型"><a href="#6-2-2-I-O设备类型" class="headerlink" title="6.2.2.     I/O设备类型"></a>6.2.2.     I/O设备类型</h3><h4 id="1、按传输速率"><a href="#1、按传输速率" class="headerlink" title="1、按传输速率"></a>1、按传输速率</h4><h5 id="低-中-高速"><a href="#低-中-高速" class="headerlink" title="低/中/高速"></a>低/中/高速</h5><h4 id="2、按信息交换单位"><a href="#2、按信息交换单位" class="headerlink" title="2、按信息交换单位"></a>2、按信息交换单位</h4><h5 id="块设备——数据块为单位"><a href="#块设备——数据块为单位" class="headerlink" title="块设备——数据块为单位"></a>块设备——数据块为单位</h5><h5 id="字符设备——字符为单位"><a href="#字符设备——字符为单位" class="headerlink" title="字符设备——字符为单位"></a>字符设备——字符为单位</h5><h4 id="3、按设备共享属性"><a href="#3、按设备共享属性" class="headerlink" title="3、按设备共享属性"></a>3、按设备共享属性</h4><h5 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h5><h5 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h5><h5 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h5><h6 id="虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用"><a href="#虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用" class="headerlink" title="虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用"></a>虚拟技术变一台独占设备为若干逻辑设备，使多个进程同时使用</h6><h3 id="6-2-3-设备与控制器之间的接口"><a href="#6-2-3-设备与控制器之间的接口" class="headerlink" title="6.2.3.     设备与控制器之间的接口"></a>6.2.3.     设备与控制器之间的接口</h3><h4 id="设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备"><a href="#设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备" class="headerlink" title="设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备"></a>设备同计算机不直接连接，一般通过专业电缆间接连接控制器与设备</h4><h4 id="控制器与设备传递的信号"><a href="#控制器与设备传递的信号" class="headerlink" title="控制器与设备传递的信号"></a>控制器与设备传递的信号</h4><h5 id="1、数据信号：控制器-gt-设备"><a href="#1、数据信号：控制器-gt-设备" class="headerlink" title="1、数据信号：控制器-&gt;设备"></a>1、数据信号：控制器-&gt;设备</h5><h5 id="2、控制信号：控制器-gt-设备"><a href="#2、控制信号：控制器-gt-设备" class="headerlink" title="2、控制信号：控制器-&gt;设备"></a>2、控制信号：控制器-&gt;设备</h5><h5 id="3、状态信号：设备-gt-控制器"><a href="#3、状态信号：设备-gt-控制器" class="headerlink" title="3、状态信号：设备-&gt;控制器"></a>3、状态信号：设备-&gt;控制器</h5><h2 id="6-3-设备管理目标"><a href="#6-3-设备管理目标" class="headerlink" title="6.3.     设备管理目标"></a>6.3.     设备管理目标</h2><h3 id="6-3-1-1、提供统一界面，方便用户使用"><a href="#6-3-1-1、提供统一界面，方便用户使用" class="headerlink" title="6.3.1.     1、提供统一界面，方便用户使用"></a>6.3.1.     1、提供统一界面，方便用户使用</h3><h3 id="6-3-2-2、发挥系统并行性，提高I-O使用效率"><a href="#6-3-2-2、发挥系统并行性，提高I-O使用效率" class="headerlink" title="6.3.2.     2、发挥系统并行性，提高I/O使用效率"></a>6.3.2.     2、发挥系统并行性，提高I/O使用效率</h3><h3 id="6-3-3-3、设备保护：实现设备的正确安全使用"><a href="#6-3-3-3、设备保护：实现设备的正确安全使用" class="headerlink" title="6.3.3.     3、设备保护：实现设备的正确安全使用"></a>6.3.3.     3、设备保护：实现设备的正确安全使用</h3><h2 id="6-4-缓冲管理"><a href="#6-4-缓冲管理" class="headerlink" title="6.4.     缓冲管理"></a>6.4.     缓冲管理</h2><h3 id="6-4-1-概念"><a href="#6-4-1-概念" class="headerlink" title="6.4.1.     概念"></a>6.4.1.     概念</h3><h4 id="缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域"><a href="#缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域" class="headerlink" title="缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域"></a>缓冲区用来保存两个设备之间或设备和应用程序之间所传输的内存区域</h4><h3 id="6-4-2-引入缓冲区原因"><a href="#6-4-2-引入缓冲区原因" class="headerlink" title="6.4.2.     引入缓冲区原因"></a>6.4.2.     引入缓冲区原因</h3><h4 id="1、处理数据的生产者和消费者速度不匹配"><a href="#1、处理数据的生产者和消费者速度不匹配" class="headerlink" title="1、处理数据的生产者和消费者速度不匹配"></a>1、处理数据的生产者和消费者速度不匹配</h4><h4 id="2、协调传输速度不一致的设备"><a href="#2、协调传输速度不一致的设备" class="headerlink" title="2、协调传输速度不一致的设备"></a>2、协调传输速度不一致的设备</h4><h4 id="3、减少CPU中断频率"><a href="#3、减少CPU中断频率" class="headerlink" title="3、减少CPU中断频率"></a>3、减少CPU中断频率</h4><h4 id="4、提高CPU和I-O设备之间的并行性"><a href="#4、提高CPU和I-O设备之间的并行性" class="headerlink" title="4、提高CPU和I/O设备之间的并行性"></a>4、提高CPU和I/O设备之间的并行性</h4><h3 id="6-4-3-缓冲区分类"><a href="#6-4-3-缓冲区分类" class="headerlink" title="6.4.3.     缓冲区分类"></a>6.4.3.     缓冲区分类</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><h5 id="一个缓冲区，CPU外设轮流使用"><a href="#一个缓冲区，CPU外设轮流使用" class="headerlink" title="一个缓冲区，CPU外设轮流使用"></a>一个缓冲区，CPU外设轮流使用</h5><h4 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h4><h5 id="两个缓冲区，CPU和外设处理速度相近，可以连续处理"><a href="#两个缓冲区，CPU和外设处理速度相近，可以连续处理" class="headerlink" title="两个缓冲区，CPU和外设处理速度相近，可以连续处理"></a>两个缓冲区，CPU和外设处理速度相近，可以连续处理</h5><h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><h5 id="环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大"><a href="#环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大" class="headerlink" title="环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大"></a>环形缓冲——多个缓冲区，CPU和外设的处理速度相差可以比较大</h5><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><h5 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h5><h6 id="1、空闲缓冲区队列emq"><a href="#1、空闲缓冲区队列emq" class="headerlink" title="1、空闲缓冲区队列emq"></a>1、空闲缓冲区队列emq</h6><h6 id="2、输入缓冲区队列inq"><a href="#2、输入缓冲区队列inq" class="headerlink" title="2、输入缓冲区队列inq"></a>2、输入缓冲区队列inq</h6><h6 id="3、输出缓冲区队列outq"><a href="#3、输出缓冲区队列outq" class="headerlink" title="3、输出缓冲区队列outq"></a>3、输出缓冲区队列outq</h6><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><h6 id="1、收容输入"><a href="#1、收容输入" class="headerlink" title="1、收容输入"></a>1、收容输入</h6><p>设备输入data</p>
<h6 id="2、提取输入"><a href="#2、提取输入" class="headerlink" title="2、提取输入"></a>2、提取输入</h6><p>计算机读入data</p>
<h6 id="3、收容输出"><a href="#3、收容输出" class="headerlink" title="3、收容输出"></a>3、收容输出</h6><p>计算机输出data</p>
<h6 id="4、提取输出"><a href="#4、提取输出" class="headerlink" title="4、提取输出"></a>4、提取输出</h6><p>向设备输出data</p>
<h2 id="6-5-I-O软件"><a href="#6-5-I-O软件" class="headerlink" title="6.5.     I/O软件"></a>6.5.     I/O软件</h2><h3 id="6-5-1-设计目标"><a href="#6-5-1-设计目标" class="headerlink" title="6.5.1.     设计目标"></a>6.5.1.     设计目标</h3><h4 id="高效性"><a href="#高效性" class="headerlink" title="高效性"></a>高效性</h4><h5 id="确保I-O设备与CPU并发性，提高资源利用率"><a href="#确保I-O设备与CPU并发性，提高资源利用率" class="headerlink" title="确保I/O设备与CPU并发性，提高资源利用率"></a>确保I/O设备与CPU并发性，提高资源利用率</h5><h4 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h4><h5 id="提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作"><a href="#提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作" class="headerlink" title="提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作"></a>提供简单抽象、统一接口，采用统一标准方法，管理所有设备及所需的操作</h5><h3 id="6-5-2-采用方式"><a href="#6-5-2-采用方式" class="headerlink" title="6.5.2.     采用方式"></a>6.5.2.     采用方式</h3><h4 id="抽象、包装、软件分层"><a href="#抽象、包装、软件分层" class="headerlink" title="抽象、包装、软件分层"></a>抽象、包装、软件分层</h4><h3 id="6-5-3-应达到的目标"><a href="#6-5-3-应达到的目标" class="headerlink" title="6.5.3.     应达到的目标"></a>6.5.3.     应达到的目标</h3><h4 id="1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射"><a href="#1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射" class="headerlink" title="1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射"></a>1、与具体设备无关：抽象逻辑设备提供给高层软件，完成设备的映射</h4><h4 id="2、统一命令"><a href="#2、统一命令" class="headerlink" title="2、统一命令"></a>2、统一命令</h4><h4 id="3、对错误的处理：尽可能低层处理，不涉及高层"><a href="#3、对错误的处理：尽可能低层处理，不涉及高层" class="headerlink" title="3、对错误的处理：尽可能低层处理，不涉及高层"></a>3、对错误的处理：尽可能低层处理，不涉及高层</h4><h4 id="4、缓冲技术"><a href="#4、缓冲技术" class="headerlink" title="4、缓冲技术"></a>4、缓冲技术</h4><h4 id="5、设备的分配和回收"><a href="#5、设备的分配和回收" class="headerlink" title="5、设备的分配和回收"></a>5、设备的分配和回收</h4><h4 id="6、I-O控制方式：不同设备的控制方式不同"><a href="#6、I-O控制方式：不同设备的控制方式不同" class="headerlink" title="6、I/O控制方式：不同设备的控制方式不同"></a>6、I/O控制方式：不同设备的控制方式不同</h4><h3 id="6-5-4-层次结构"><a href="#6-5-4-层次结构" class="headerlink" title="6.5.4.     层次结构"></a>6.5.4.     层次结构</h3><h4 id="1、用户空间软件"><a href="#1、用户空间软件" class="headerlink" title="1、用户空间软件"></a>1、用户空间软件</h4><h5 id="用户层软件必须通过一组系统调用获取OS服务"><a href="#用户层软件必须通过一组系统调用获取OS服务" class="headerlink" title="用户层软件必须通过一组系统调用获取OS服务"></a>用户层软件必须通过一组系统调用获取OS服务</h5><h4 id="2、与设备无关的OS软件（无关层）"><a href="#2、与设备无关的OS软件（无关层）" class="headerlink" title="2、与设备无关的OS软件（无关层）"></a>2、与设备无关的OS软件（无关层）</h4><h5 id="设备独立性概念"><a href="#设备独立性概念" class="headerlink" title="设备独立性概念"></a>设备独立性概念</h5><h6 id="基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件"><a href="#基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件" class="headerlink" title="基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件"></a>基于设备无关性，指除了之间和设备打交道的底层软件之外，其他软件设计不依赖于硬件</h6><h6 id="设备独立性软件设置在驱动程序之上，界限因OS的不同而不同"><a href="#设备独立性软件设置在驱动程序之上，界限因OS的不同而不同" class="headerlink" title="设备独立性软件设置在驱动程序之上，界限因OS的不同而不同"></a>设备独立性软件设置在驱动程序之上，界限因OS的不同而不同</h6><h6 id="使应用程序独立于物理设备"><a href="#使应用程序独立于物理设备" class="headerlink" title="使应用程序独立于物理设备"></a>使应用程序独立于物理设备</h6><h5 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h5><h6 id="1、引入物理设备、逻辑设备"><a href="#1、引入物理设备、逻辑设备" class="headerlink" title="1、引入物理设备、逻辑设备"></a>1、引入物理设备、逻辑设备</h6><h6 id="2、应用程序通过逻辑设备名调用设备，OS负责转换"><a href="#2、应用程序通过逻辑设备名调用设备，OS负责转换" class="headerlink" title="2、应用程序通过逻辑设备名调用设备，OS负责转换"></a>2、应用程序通过逻辑设备名调用设备，OS负责转换</h6><h5 id="设备独立性好处"><a href="#设备独立性好处" class="headerlink" title="设备独立性好处"></a>设备独立性好处</h5><h6 id="1、设备分配的灵活性"><a href="#1、设备分配的灵活性" class="headerlink" title="1、设备分配的灵活性"></a>1、设备分配的灵活性</h6><h6 id="2、实现I-O重定向：实现I-O操作的设备可更换，而不用改变应用程序"><a href="#2、实现I-O重定向：实现I-O操作的设备可更换，而不用改变应用程序" class="headerlink" title="2、实现I/O重定向：实现I/O操作的设备可更换，而不用改变应用程序"></a>2、实现I/O重定向：实现I/O操作的设备可更换，而不用改变应用程序</h6><h5 id="设备独立性软件功能"><a href="#设备独立性软件功能" class="headerlink" title="设备独立性软件功能"></a>设备独立性软件功能</h5><h6 id="1、执行所有设备的公有操作"><a href="#1、执行所有设备的公有操作" class="headerlink" title="1、执行所有设备的公有操作"></a>1、执行所有设备的公有操作</h6><h6 id="2、向用户层软件提供统一接口"><a href="#2、向用户层软件提供统一接口" class="headerlink" title="2、向用户层软件提供统一接口"></a>2、向用户层软件提供统一接口</h6><h5 id="逻辑设备映射到物理设备的方式"><a href="#逻辑设备映射到物理设备的方式" class="headerlink" title="逻辑设备映射到物理设备的方式"></a>逻辑设备映射到物理设备的方式</h5><h6 id="1、逻辑设备表LUT"><a href="#1、逻辑设备表LUT" class="headerlink" title="1、逻辑设备表LUT"></a>1、逻辑设备表LUT</h6><p>逻辑设备名+物理设备名+驱动程序入口地址</p>
<h6 id="2、LUT的实现可以采用两种方式"><a href="#2、LUT的实现可以采用两种方式" class="headerlink" title="2、LUT的实现可以采用两种方式"></a>2、LUT的实现可以采用两种方式</h6><p>整个系统一张（逻辑设备名不能相同）；每个用户一张，放入PCB中</p>
<h4 id="3、设备驱动程序（驱动层）"><a href="#3、设备驱动程序（驱动层）" class="headerlink" title="3、设备驱动程序（驱动层）"></a>3、设备驱动程序（驱动层）</h4><h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><h6 id="1、抽象要求转具体要求"><a href="#1、抽象要求转具体要求" class="headerlink" title="1、抽象要求转具体要求"></a>1、抽象要求转具体要求</h6><h6 id="2、检查I-O请求合法性"><a href="#2、检查I-O请求合法性" class="headerlink" title="2、检查I/O请求合法性"></a>2、检查I/O请求合法性</h6><h6 id="3、读出和检查设备状态"><a href="#3、读出和检查设备状态" class="headerlink" title="3、读出和检查设备状态"></a>3、读出和检查设备状态</h6><h6 id="4、传送参数"><a href="#4、传送参数" class="headerlink" title="4、传送参数"></a>4、传送参数</h6><h6 id="5、设置工作方式"><a href="#5、设置工作方式" class="headerlink" title="5、设置工作方式"></a>5、设置工作方式</h6><h6 id="6、启动I-O设备"><a href="#6、启动I-O设备" class="headerlink" title="6、启动I/O设备"></a>6、启动I/O设备</h6><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><h6 id="1、I-O请求进程与设备控制器之间的桥梁，中转数据和控制"><a href="#1、I-O请求进程与设备控制器之间的桥梁，中转数据和控制" class="headerlink" title="1、I/O请求进程与设备控制器之间的桥梁，中转数据和控制"></a>1、I/O请求进程与设备控制器之间的桥梁，中转数据和控制</h6><h6 id="2、与I-O设备特性、控制方式、硬件密切相关"><a href="#2、与I-O设备特性、控制方式、硬件密切相关" class="headerlink" title="2、与I/O设备特性、控制方式、硬件密切相关"></a>2、与I/O设备特性、控制方式、硬件密切相关</h6><h6 id="3、向上屏蔽设备细节"><a href="#3、向上屏蔽设备细节" class="headerlink" title="3、向上屏蔽设备细节"></a>3、向上屏蔽设备细节</h6><h6 id="4、驱动程序允许可重入"><a href="#4、驱动程序允许可重入" class="headerlink" title="4、驱动程序允许可重入"></a>4、驱动程序允许可重入</h6><h4 id="4、中断处理程序"><a href="#4、中断处理程序" class="headerlink" title="4、中断处理程序"></a>4、中断处理程序</h4><h4 id="5、硬件"><a href="#5、硬件" class="headerlink" title="5、硬件"></a>5、硬件</h4><h4 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h4><h5 id="功能上看，无关层为I-O管理的主要部分"><a href="#功能上看，无关层为I-O管理的主要部分" class="headerlink" title="功能上看，无关层为I/O管理的主要部分"></a>功能上看，无关层为I/O管理的主要部分</h5><h5 id="代码量上看，驱动层为I-O管理的主要部分"><a href="#代码量上看，驱动层为I-O管理的主要部分" class="headerlink" title="代码量上看，驱动层为I/O管理的主要部分"></a>代码量上看，驱动层为I/O管理的主要部分</h5><h3 id="6-5-5-设备分配与回收"><a href="#6-5-5-设备分配与回收" class="headerlink" title="6.5.5.     设备分配与回收"></a>6.5.5.     设备分配与回收</h3><h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><h5 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="1、系统设备表SDT"><a href="#1、系统设备表SDT" class="headerlink" title="1、系统设备表SDT"></a>1、系统设备表SDT</h6><h6 id="2、设备控制表DCT"><a href="#2、设备控制表DCT" class="headerlink" title="2、设备控制表DCT"></a>2、设备控制表DCT</h6><h6 id="3、控制器控制表COCT"><a href="#3、控制器控制表COCT" class="headerlink" title="3、控制器控制表COCT"></a>3、控制器控制表COCT</h6><h6 id="4、通道控制表CHCT"><a href="#4、通道控制表CHCT" class="headerlink" title="4、通道控制表CHCT"></a>4、通道控制表CHCT</h6><h5 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h5><h6 id="1、设备固有属性"><a href="#1、设备固有属性" class="headerlink" title="1、设备固有属性"></a>1、设备固有属性</h6><p>独享；共享；虚拟设备</p>
<h6 id="2、设备分配算法"><a href="#2、设备分配算法" class="headerlink" title="2、设备分配算法"></a>2、设备分配算法</h6><p>先来先服务（FCFS）</p>
<p>基于优先级</p>
<h6 id="3、设备分配的安全性"><a href="#3、设备分配的安全性" class="headerlink" title="3、设备分配的安全性"></a>3、设备分配的安全性</h6><p>安全分配方式：进程发出I/O后阻塞，不占用OS资源</p>
<p>不安全分配方式：多个设备并行操作；可能造成死锁</p>
<h5 id="独占设备的分配程序"><a href="#独占设备的分配程序" class="headerlink" title="独占设备的分配程序"></a>独占设备的分配程序</h5><h6 id="1、分配设备"><a href="#1、分配设备" class="headerlink" title="1、分配设备"></a>1、分配设备</h6><h6 id="2、分配控制器"><a href="#2、分配控制器" class="headerlink" title="2、分配控制器"></a>2、分配控制器</h6><h6 id="3、分配通道"><a href="#3、分配通道" class="headerlink" title="3、分配通道"></a>3、分配通道</h6><h4 id="SPOOLing技术（假脱机）"><a href="#SPOOLing技术（假脱机）" class="headerlink" title="SPOOLing技术（假脱机）"></a>SPOOLing技术（假脱机）</h4><h5 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h5><h6 id="联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机"><a href="#联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机" class="headerlink" title="联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机"></a>联机情况下实现的同时外围操作就叫做SPOOLing操作，也叫假脱机</h6><h6 id="联机I-O，主机直接控制I-O"><a href="#联机I-O，主机直接控制I-O" class="headerlink" title="联机I/O，主机直接控制I/O"></a>联机I/O，主机直接控制I/O</h6><h6 id="脱机I-O，一台外围机控制器代替主机控制I-O"><a href="#脱机I-O，一台外围机控制器代替主机控制I-O" class="headerlink" title="脱机I/O，一台外围机控制器代替主机控制I/O"></a>脱机I/O，一台外围机控制器代替主机控制I/O</h6><h6 id="SPOOLing用联机I-O模拟脱机I-O工作"><a href="#SPOOLing用联机I-O模拟脱机I-O工作" class="headerlink" title="SPOOLing用联机I/O模拟脱机I/O工作"></a>SPOOLing用联机I/O模拟脱机I/O工作</h6><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><h6 id="SPOOLing程序预先从外设输入data并缓冲，称为输入井-时机合适输入到应用程序"><a href="#SPOOLing程序预先从外设输入data并缓冲，称为输入井-时机合适输入到应用程序" class="headerlink" title="SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序"></a>SPOOLing程序预先从外设输入data并缓冲，称为输入井,时机合适输入到应用程序</h6><h6 id="SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设"><a href="#SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设" class="headerlink" title="SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设"></a>SPOOLing程序接收应用程序输出data并缓冲，称为输出井，时机合适输出到外设</h6><h6 id="以上称为实际I-O"><a href="#以上称为实际I-O" class="headerlink" title="以上称为实际I/O"></a>以上称为实际I/O</h6><h6 id="缓冲池中读入和读出就不是实际I-O"><a href="#缓冲池中读入和读出就不是实际I-O" class="headerlink" title="缓冲池中读入和读出就不是实际I/O"></a>缓冲池中读入和读出就不是实际I/O</h6><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><h6 id="1、输入井和输出井：在磁盘"><a href="#1、输入井和输出井：在磁盘" class="headerlink" title="1、输入井和输出井：在磁盘"></a>1、输入井和输出井：在磁盘</h6><h6 id="2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾"><a href="#2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾" class="headerlink" title="2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾"></a>2、输入缓冲区和输出缓冲区：在内存，缓和CPU和磁盘速度不匹配的矛盾</h6><h6 id="3、输入进程和输出进程：守护进程"><a href="#3、输入进程和输出进程：守护进程" class="headerlink" title="3、输入进程和输出进程：守护进程"></a>3、输入进程和输出进程：守护进程</h6><h5 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h5><h6 id="1、高速虚拟I-O操作"><a href="#1、高速虚拟I-O操作" class="headerlink" title="1、高速虚拟I/O操作"></a>1、高速虚拟I/O操作</h6><h6 id="2、实现独享设备的共享"><a href="#2、实现独享设备的共享" class="headerlink" title="2、实现独享设备的共享"></a>2、实现独享设备的共享</h6><h6 id="3、SPOOLing程序提供虚拟设备"><a href="#3、SPOOLing程序提供虚拟设备" class="headerlink" title="3、SPOOLing程序提供虚拟设备"></a>3、SPOOLing程序提供虚拟设备</h6><h2 id="6-6-磁盘调度"><a href="#6-6-磁盘调度" class="headerlink" title="6.6.     磁盘调度"></a>6.6.     磁盘调度</h2><h3 id="6-6-1-磁盘存储器管理"><a href="#6-6-1-磁盘存储器管理" class="headerlink" title="6.6.1.     磁盘存储器管理"></a>6.6.1.     磁盘存储器管理</h3><h4 id="磁盘存储器：随机读写、共享设备，可移动介质"><a href="#磁盘存储器：随机读写、共享设备，可移动介质" class="headerlink" title="磁盘存储器：随机读写、共享设备，可移动介质"></a>磁盘存储器：随机读写、共享设备，可移动介质</h4><h4 id="特点：容量大，速度快"><a href="#特点：容量大，速度快" class="headerlink" title="特点：容量大，速度快"></a>特点：容量大，速度快</h4><h4 id="管理要求：合理分配空间，访问效率高。容错强。"><a href="#管理要求：合理分配空间，访问效率高。容错强。" class="headerlink" title="管理要求：合理分配空间，访问效率高。容错强。"></a>管理要求：合理分配空间，访问效率高。容错强。</h4><h4 id="其性能直接影响文件系统的性能指标"><a href="#其性能直接影响文件系统的性能指标" class="headerlink" title="其性能直接影响文件系统的性能指标"></a>其性能直接影响文件系统的性能指标</h4><h3 id="6-6-2-磁盘性能"><a href="#6-6-2-磁盘性能" class="headerlink" title="6.6.2.     磁盘性能"></a>6.6.2.     磁盘性能</h3><h4 id="数据的组织"><a href="#数据的组织" class="headerlink" title="数据的组织"></a>数据的组织</h4><h5 id="地址格式：驱动器号-磁道号-磁头号-扇区号"><a href="#地址格式：驱动器号-磁道号-磁头号-扇区号" class="headerlink" title="地址格式：驱动器号+磁道号+磁头号+扇区号"></a>地址格式：驱动器号+磁道号+磁头号+扇区号</h5><h4 id="磁盘类型"><a href="#磁盘类型" class="headerlink" title="磁盘类型"></a>磁盘类型</h4><h5 id="固定头磁盘；移动头磁盘"><a href="#固定头磁盘；移动头磁盘" class="headerlink" title="固定头磁盘；移动头磁盘"></a>固定头磁盘；移动头磁盘</h5><h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><h5 id="寻道时间-旋转延迟时间-传输时间"><a href="#寻道时间-旋转延迟时间-传输时间" class="headerlink" title="寻道时间+旋转延迟时间+传输时间"></a>寻道时间+旋转延迟时间+传输时间</h5><h5 id="寻道时间是主要影响参数"><a href="#寻道时间是主要影响参数" class="headerlink" title="寻道时间是主要影响参数"></a>寻道时间是主要影响参数</h5><h4 id="提高速度的途径"><a href="#提高速度的途径" class="headerlink" title="提高速度的途径"></a>提高速度的途径</h4><h5 id="1、硬件解决"><a href="#1、硬件解决" class="headerlink" title="1、硬件解决"></a>1、硬件解决</h5><h5 id="2、好的调度算法"><a href="#2、好的调度算法" class="headerlink" title="2、好的调度算法"></a>2、好的调度算法</h5><h6 id="减少寻道时间"><a href="#减少寻道时间" class="headerlink" title="减少寻道时间"></a>减少寻道时间</h6><h5 id="3、缓冲区"><a href="#3、缓冲区" class="headerlink" title="3、缓冲区"></a>3、缓冲区</h5><h3 id="6-6-3-调度算法"><a href="#6-6-3-调度算法" class="headerlink" title="6.6.3.     调度算法"></a>6.6.3.     调度算法</h3><h4 id="1、先来先服务"><a href="#1、先来先服务" class="headerlink" title="1、先来先服务"></a>1、先来先服务</h4><h5 id="执行顺序为磁盘I-O请求先后顺序"><a href="#执行顺序为磁盘I-O请求先后顺序" class="headerlink" title="执行顺序为磁盘I/O请求先后顺序"></a>执行顺序为磁盘I/O请求先后顺序</h5><h4 id="2、最短寻道时间优先（SSTF）"><a href="#2、最短寻道时间优先（SSTF）" class="headerlink" title="2、最短寻道时间优先（SSTF）"></a>2、最短寻道时间优先（SSTF）</h4><h5 id="选择距当前磁头移动最少的磁盘I-O请求"><a href="#选择距当前磁头移动最少的磁盘I-O请求" class="headerlink" title="选择距当前磁头移动最少的磁盘I/O请求"></a>选择距当前磁头移动最少的磁盘I/O请求</h5><h5 id="不能保证平均寻道时间最短，进程可能饿死"><a href="#不能保证平均寻道时间最短，进程可能饿死" class="headerlink" title="不能保证平均寻道时间最短，进程可能饿死"></a>不能保证平均寻道时间最短，进程可能饿死</h5><h4 id="3、扫描算法（SCAN）"><a href="#3、扫描算法（SCAN）" class="headerlink" title="3、扫描算法（SCAN）"></a>3、扫描算法（SCAN）</h4><h5 id="（电梯调度算法）选择当前磁头前进方向上移动距离最少的I-O请求，没有前进方向的请求才改变方向"><a href="#（电梯调度算法）选择当前磁头前进方向上移动距离最少的I-O请求，没有前进方向的请求才改变方向" class="headerlink" title="（电梯调度算法）选择当前磁头前进方向上移动距离最少的I/O请求，没有前进方向的请求才改变方向"></a>（电梯调度算法）选择当前磁头前进方向上移动距离最少的I/O请求，没有前进方向的请求才改变方向</h5><h5 id="SSTF的改进，没有进程饿死"><a href="#SSTF的改进，没有进程饿死" class="headerlink" title="SSTF的改进，没有进程饿死"></a>SSTF的改进，没有进程饿死</h5><h4 id="4、循环扫描算法（CSCAN）"><a href="#4、循环扫描算法（CSCAN）" class="headerlink" title="4、循环扫描算法（CSCAN）"></a>4、循环扫描算法（CSCAN）</h4><h5 id="选定一个方向扫描，到末尾再返回最里欲访问的磁道"><a href="#选定一个方向扫描，到末尾再返回最里欲访问的磁道" class="headerlink" title="选定一个方向扫描，到末尾再返回最里欲访问的磁道"></a>选定一个方向扫描，到末尾再返回最里欲访问的磁道</h5><h5 id="负载或重负载时，磁盘I-O性能比扫描算法好"><a href="#负载或重负载时，磁盘I-O性能比扫描算法好" class="headerlink" title="负载或重负载时，磁盘I/O性能比扫描算法好"></a>负载或重负载时，磁盘I/O性能比扫描算法好</h5><h4 id="5、N-Step-SCAN算法"><a href="#5、N-Step-SCAN算法" class="headerlink" title="5、N-Step-SCAN算法"></a>5、N-Step-SCAN算法</h4><h5 id="磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法"><a href="#磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法" class="headerlink" title="磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法"></a>磁盘请求队列分为长度为N的段，队列间FCFS，队列里SCAN算法</h5><h5 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h5><h6 id="解决磁臂黏着问题"><a href="#解决磁臂黏着问题" class="headerlink" title="解决磁臂黏着问题"></a>解决磁臂黏着问题</h6><h4 id="6、FSCAN调度算法"><a href="#6、FSCAN调度算法" class="headerlink" title="6、FSCAN调度算法"></a>6、FSCAN调度算法</h4><h5 id="磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法"><a href="#磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法" class="headerlink" title="磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法"></a>磁盘请求队列分为长度为2的段，队列间FCFS，队列里SCAN算法</h5><h5 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h5><h6 id="解决磁臂黏着问题-1"><a href="#解决磁臂黏着问题-1" class="headerlink" title="解决磁臂黏着问题"></a>解决磁臂黏着问题</h6><h3 id="6-6-4-磁盘高速缓存"><a href="#6-6-4-磁盘高速缓存" class="headerlink" title="6.6.4.     磁盘高速缓存"></a>6.6.4.     磁盘高速缓存</h3><h4 id="概念-16"><a href="#概念-16" class="headerlink" title="概念"></a>概念</h4><h5 id="利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存"><a href="#利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存" class="headerlink" title="利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存"></a>利用内存空间暂存从磁盘中读取的盘块信息，逻辑上属于磁盘，物理上属于内存</h5><h4 id="1、磁盘高速缓存形式"><a href="#1、磁盘高速缓存形式" class="headerlink" title="1、磁盘高速缓存形式"></a>1、磁盘高速缓存形式</h4><h5 id="大小固定"><a href="#大小固定" class="headerlink" title="大小固定"></a>大小固定</h5><h5 id="未利用的内存空间组成缓冲池"><a href="#未利用的内存空间组成缓冲池" class="headerlink" title="未利用的内存空间组成缓冲池"></a>未利用的内存空间组成缓冲池</h5><h4 id="2、数据交付方式"><a href="#2、数据交付方式" class="headerlink" title="2、数据交付方式"></a>2、数据交付方式</h4><h5 id="1、磁盘高速缓存中的数据直接传送到请求进程的内存区"><a href="#1、磁盘高速缓存中的数据直接传送到请求进程的内存区" class="headerlink" title="1、磁盘高速缓存中的数据直接传送到请求进程的内存区"></a>1、磁盘高速缓存中的数据直接传送到请求进程的内存区</h5><h5 id="2、磁盘高速缓存中的数据指针传送到请求进程的内存区"><a href="#2、磁盘高速缓存中的数据指针传送到请求进程的内存区" class="headerlink" title="2、磁盘高速缓存中的数据指针传送到请求进程的内存区"></a>2、磁盘高速缓存中的数据指针传送到请求进程的内存区</h5><h4 id="3、置换算法"><a href="#3、置换算法" class="headerlink" title="3、置换算法"></a>3、置换算法</h4><h5 id="LRU-NRU-最少使用算法"><a href="#LRU-NRU-最少使用算法" class="headerlink" title="LRU/NRU/最少使用算法"></a>LRU/NRU/最少使用算法</h5><h4 id="如何保持数据的一致性"><a href="#如何保持数据的一致性" class="headerlink" title="如何保持数据的一致性"></a>如何保持数据的一致性</h4><h5 id="备用电源"><a href="#备用电源" class="headerlink" title="备用电源"></a>备用电源</h5><h5 id="OS定期回写"><a href="#OS定期回写" class="headerlink" title="OS定期回写"></a>OS定期回写</h5><h3 id="6-6-5-提高磁盘I-O速度的其他方法"><a href="#6-6-5-提高磁盘I-O速度的其他方法" class="headerlink" title="6.6.5.     提高磁盘I/O速度的其他方法"></a>6.6.5.     提高磁盘I/O速度的其他方法</h3><h4 id="1、提前读"><a href="#1、提前读" class="headerlink" title="1、提前读"></a>1、提前读</h4><h4 id="2、延迟写"><a href="#2、延迟写" class="headerlink" title="2、延迟写"></a>2、延迟写</h4><h4 id="3、优化物理块的分布"><a href="#3、优化物理块的分布" class="headerlink" title="3、优化物理块的分布"></a>3、优化物理块的分布</h4><h4 id="4、虚拟盘"><a href="#4、虚拟盘" class="headerlink" title="4、虚拟盘"></a>4、虚拟盘</h4><h1 id="7-七、文件管理"><a href="#7-七、文件管理" class="headerlink" title="7.    七、文件管理"></a>7.    七、文件管理</h1><h2 id="7-1-文件管理概述"><a href="#7-1-文件管理概述" class="headerlink" title="7.1.     文件管理概述"></a>7.1.     文件管理概述</h2><h3 id="7-1-1-负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能"><a href="#7-1-1-负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能" class="headerlink" title="7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能"></a>7.1.1.     负责信息的组织、存储、访问；功能就是提供高效、快速和方便的信息存储和访问功能</h3><h2 id="7-2-数据分类"><a href="#7-2-数据分类" class="headerlink" title="7.2.     数据分类"></a>7.2.     数据分类</h2><h3 id="7-2-1-数据项"><a href="#7-2-1-数据项" class="headerlink" title="7.2.1.     数据项"></a>7.2.1.     数据项</h3><h4 id="基本数据项"><a href="#基本数据项" class="headerlink" title="基本数据项"></a>基本数据项</h4><h4 id="组合数据项"><a href="#组合数据项" class="headerlink" title="组合数据项"></a>组合数据项</h4><h3 id="7-2-2-记录"><a href="#7-2-2-记录" class="headerlink" title="7.2.2.     记录"></a>7.2.2.     记录</h3><h4 id="一组相关数据项的集合，由于描述一个对象在某方面的属性"><a href="#一组相关数据项的集合，由于描述一个对象在某方面的属性" class="headerlink" title="一组相关数据项的集合，由于描述一个对象在某方面的属性"></a>一组相关数据项的集合，由于描述一个对象在某方面的属性</h4><h3 id="7-2-3-文件"><a href="#7-2-3-文件" class="headerlink" title="7.2.3.     文件"></a>7.2.3.     文件</h3><h4 id="创建者定义，具有文件名的一组相关元素的集合"><a href="#创建者定义，具有文件名的一组相关元素的集合" class="headerlink" title="创建者定义，具有文件名的一组相关元素的集合"></a>创建者定义，具有文件名的一组相关元素的集合</h4><h4 id="文件体（文件本身信息）-文件属性（文件存储和管理信息）"><a href="#文件体（文件本身信息）-文件属性（文件存储和管理信息）" class="headerlink" title="文件体（文件本身信息）+文件属性（文件存储和管理信息）"></a>文件体（文件本身信息）+文件属性（文件存储和管理信息）</h4><h4 id="文件属性：类型-长度-物理位置-建立时间"><a href="#文件属性：类型-长度-物理位置-建立时间" class="headerlink" title="文件属性：类型/长度/物理位置/建立时间"></a>文件属性：类型/长度/物理位置/建立时间</h4><h2 id="7-3-文件系统"><a href="#7-3-文件系统" class="headerlink" title="7.3.     文件系统"></a>7.3.     文件系统</h2><h3 id="7-3-1-文件类型"><a href="#7-3-1-文件类型" class="headerlink" title="7.3.1.     文件类型"></a>7.3.1.     文件类型</h3><h4 id="1、用途"><a href="#1、用途" class="headerlink" title="1、用途"></a>1、用途</h4><h5 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h5><h5 id="用户文件"><a href="#用户文件" class="headerlink" title="用户文件"></a>用户文件</h5><h5 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h5><h4 id="2、数据形式"><a href="#2、数据形式" class="headerlink" title="2、数据形式"></a>2、数据形式</h4><h5 id="源文件（ASCII-汉字）"><a href="#源文件（ASCII-汉字）" class="headerlink" title="源文件（ASCII/汉字）"></a>源文件（ASCII/汉字）</h5><h5 id="目标文件（obj）"><a href="#目标文件（obj）" class="headerlink" title="目标文件（obj）"></a>目标文件（obj）</h5><h5 id="可执行文件（exe）"><a href="#可执行文件（exe）" class="headerlink" title="可执行文件（exe）"></a>可执行文件（exe）</h5><h4 id="3、存取控制属性"><a href="#3、存取控制属性" class="headerlink" title="3、存取控制属性"></a>3、存取控制属性</h4><h5 id="只执行文件"><a href="#只执行文件" class="headerlink" title="只执行文件"></a>只执行文件</h5><h5 id="只读文件"><a href="#只读文件" class="headerlink" title="只读文件"></a>只读文件</h5><h5 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h5><h4 id="4、组织形式和处理方式"><a href="#4、组织形式和处理方式" class="headerlink" title="4、组织形式和处理方式"></a>4、组织形式和处理方式</h4><h5 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h5><h5 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h5><h5 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h5><h6 id="各类I-O设备"><a href="#各类I-O设备" class="headerlink" title="各类I/O设备"></a>各类I/O设备</h6><h3 id="7-3-2-文件系统层次结构"><a href="#7-3-2-文件系统层次结构" class="headerlink" title="7.3.2.     文件系统层次结构"></a>7.3.2.     文件系统层次结构</h3><h4 id="从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口"><a href="#从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口" class="headerlink" title="从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口"></a>从下到上依次是——对象及其属性——对对象操纵和管理的软件集合——文件系统接口</h4><h4 id="对象及其属性"><a href="#对象及其属性" class="headerlink" title="对象及其属性"></a>对象及其属性</h4><h5 id="文件-目录-磁盘存储空间"><a href="#文件-目录-磁盘存储空间" class="headerlink" title="文件/目录/磁盘存储空间"></a>文件/目录/磁盘存储空间</h5><h4 id="对对象操纵和管理的软件集合-核心）"><a href="#对对象操纵和管理的软件集合-核心）" class="headerlink" title="对对象操纵和管理的软件集合(核心）"></a>对对象操纵和管理的软件集合(核心）</h4><h5 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h5><h6 id="1、文件存储空间管理-1"><a href="#1、文件存储空间管理-1" class="headerlink" title="1、文件存储空间管理"></a>1、文件存储空间管理</h6><h6 id="2、文件目录管理"><a href="#2、文件目录管理" class="headerlink" title="2、文件目录管理"></a>2、文件目录管理</h6><h6 id="3、文件逻辑地址和物理地址的转换"><a href="#3、文件逻辑地址和物理地址的转换" class="headerlink" title="3、文件逻辑地址和物理地址的转换"></a>3、文件逻辑地址和物理地址的转换</h6><h6 id="4、文件读和写管理"><a href="#4、文件读和写管理" class="headerlink" title="4、文件读和写管理"></a>4、文件读和写管理</h6><h6 id="5、文件共享和保护"><a href="#5、文件共享和保护" class="headerlink" title="5、文件共享和保护"></a>5、文件共享和保护</h6><h4 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h4><h5 id="1、命令接口-1"><a href="#1、命令接口-1" class="headerlink" title="1、命令接口"></a>1、命令接口</h5><h5 id="2、程序接口-1"><a href="#2、程序接口-1" class="headerlink" title="2、程序接口"></a>2、程序接口</h5><h3 id="7-3-3-文件操作"><a href="#7-3-3-文件操作" class="headerlink" title="7.3.3.     文件操作"></a>7.3.3.     文件操作</h3><h4 id="创建create"><a href="#创建create" class="headerlink" title="创建create"></a>创建create</h4><h4 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h4><h4 id="打开open"><a href="#打开open" class="headerlink" title="打开open"></a>打开open</h4><h4 id="关闭close"><a href="#关闭close" class="headerlink" title="关闭close"></a>关闭close</h4><h4 id="读写read-write"><a href="#读写read-write" class="headerlink" title="读写read/write"></a>读写read/write</h4><h4 id="截断：文件长度-0"><a href="#截断：文件长度-0" class="headerlink" title="截断：文件长度=0"></a>截断：文件长度=0</h4><h4 id="设置读写位置"><a href="#设置读写位置" class="headerlink" title="设置读写位置"></a>设置读写位置</h4><h4 id="其他（以系统调用方式提供）"><a href="#其他（以系统调用方式提供）" class="headerlink" title="其他（以系统调用方式提供）"></a>其他（以系统调用方式提供）</h4><h5 id="1、文件属性相关"><a href="#1、文件属性相关" class="headerlink" title="1、文件属性相关"></a>1、文件属性相关</h5><h5 id="2、有关目录操作"><a href="#2、有关目录操作" class="headerlink" title="2、有关目录操作"></a>2、有关目录操作</h5><h5 id="3、文件共享"><a href="#3、文件共享" class="headerlink" title="3、文件共享"></a>3、文件共享</h5><h3 id="7-3-4-文件逻辑结构"><a href="#7-3-4-文件逻辑结构" class="headerlink" title="7.3.4.     文件逻辑结构"></a>7.3.4.     文件逻辑结构</h3><h4 id="又称文件的组织，是指从用户观点出发观察到的文件组织形式"><a href="#又称文件的组织，是指从用户观点出发观察到的文件组织形式" class="headerlink" title="又称文件的组织，是指从用户观点出发观察到的文件组织形式"></a>又称文件的组织，是指从用户观点出发观察到的文件组织形式</h4><h4 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h4><h5 id="访问性能"><a href="#访问性能" class="headerlink" title="访问性能"></a>访问性能</h5><h6 id="便于检索，便于修改"><a href="#便于检索，便于修改" class="headerlink" title="便于检索，便于修改"></a>便于检索，便于修改</h6><h5 id="存储性能"><a href="#存储性能" class="headerlink" title="存储性能"></a>存储性能</h5><h6 id="转换方便，节省空间"><a href="#转换方便，节省空间" class="headerlink" title="转换方便，节省空间"></a>转换方便，节省空间</h6><h4 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h4><h5 id="是否有结构"><a href="#是否有结构" class="headerlink" title="是否有结构"></a>是否有结构</h5><h6 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h6><p>定长记录</p>
<p>记录长度相同</p>
<p>变长记录</p>
<p>各记录长度不同</p>
<h6 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h6><p>文件长度以字节为单位，读、写指针访问下一个字符</p>
<h5 id="组织形式划分"><a href="#组织形式划分" class="headerlink" title="组织形式划分"></a>组织形式划分</h5><h6 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h6><p>顺序排列，定长或变长都可</p>
<p>排列方式</p>
<p>1、串结构</p>
<p>存入时间决定顺序</p>
<p>2、顺序结构</p>
<p>按关键字排序，效率更高</p>
<p>读写方式</p>
<p>1、定长：ptr=ptr+L</p>
<p>2、变长：ptr=ptr+Li</p>
<p>优缺点</p>
<p>优点</p>
<p>批量处理数据</p>
<p>缺点</p>
<p>单个记录处理困难</p>
<h6 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h6><p>建立一张索引表，每个记录对应一个索引项</p>
<h6 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h6><p>建立一张索引表，将顺序文件中的·记录分为若干组，每组第一个记录对应一个索引项</p>
<h6 id="ps：直接文件："><a href="#ps：直接文件：" class="headerlink" title="ps：直接文件："></a>ps：直接文件：</h6><p>键值直接对应物理地址</p>
<h6 id="ps：哈希文件"><a href="#ps：哈希文件" class="headerlink" title="ps：哈希文件"></a>ps：哈希文件</h6><p>哈希函数根据键值计算相对位置，再根据相对位置得到内容</p>
<p>访问速度最快，但有空闲空间浪费</p>
<h3 id="7-3-5-文件物理结构"><a href="#7-3-5-文件物理结构" class="headerlink" title="7.3.5.     文件物理结构"></a>7.3.5.     文件物理结构</h3><h4 id="文件的存储结构，指文件在外存的组织形式"><a href="#文件的存储结构，指文件在外存的组织形式" class="headerlink" title="文件的存储结构，指文件在外存的组织形式"></a>文件的存储结构，指文件在外存的组织形式</h4><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><h5 id="1、提高存储空间的利用率"><a href="#1、提高存储空间的利用率" class="headerlink" title="1、提高存储空间的利用率"></a>1、提高存储空间的利用率</h5><h5 id="2、提高文件的访问速度"><a href="#2、提高文件的访问速度" class="headerlink" title="2、提高文件的访问速度"></a>2、提高文件的访问速度</h5><h4 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4><h5 id="1、连续分配"><a href="#1、连续分配" class="headerlink" title="1、连续分配"></a>1、连续分配</h5><h6 id="每个文件分配一组相邻接的盘块"><a href="#每个文件分配一组相邻接的盘块" class="headerlink" title="每个文件分配一组相邻接的盘块"></a>每个文件分配一组相邻接的盘块</h6><h6 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h6><p>随着使用磁盘碎片增多，性能下降，需要整理</p>
<h6 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h6><p>访问速度快，定位容易，只需记录第一个簇的位置，可通过紧凑合并外存空闲空间</p>
<h6 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h6><p>需要连续空间，需要事先知道文件长度</p>
<h5 id="2、链接分配"><a href="#2、链接分配" class="headerlink" title="2、链接分配"></a>2、链接分配</h5><h6 id="隐式分配"><a href="#隐式分配" class="headerlink" title="隐式分配"></a>隐式分配</h6><p>不连续，每个簇中有指向下一个簇的指针，目录存放第一个簇和最后一个簇的指针</p>
<p>优点</p>
<p>解决了连续分配的问题</p>
<p>缺点</p>
<p>随机访问效率差，可靠性差</p>
<h6 id="显式分配"><a href="#显式分配" class="headerlink" title="显式分配"></a>显式分配</h6><p>不连续，指针单独存放在文件分配表（FAT）中与文件对应的目录项存放文件首块的地址</p>
<h5 id="3、索引分配"><a href="#3、索引分配" class="headerlink" title="3、索引分配"></a>3、索引分配</h5><h6 id="单级索引"><a href="#单级索引" class="headerlink" title="单级索引"></a>单级索引</h6><h6 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h6><h6 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h6><h2 id="7-4-目录管理"><a href="#7-4-目录管理" class="headerlink" title="7.4.     目录管理"></a>7.4.     目录管理</h2><h3 id="7-4-1-用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址"><a href="#7-4-1-用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址" class="headerlink" title="7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址"></a>7.4.1.     用于文件检索的特殊文件，一种数据结构，表示系统中所有的文件及其物理地址</h3><h3 id="7-4-2-实现目标"><a href="#7-4-2-实现目标" class="headerlink" title="7.4.2.     实现目标"></a>7.4.2.     实现目标</h3><h4 id="按名存取"><a href="#按名存取" class="headerlink" title="按名存取"></a>按名存取</h4><h4 id="快速检索"><a href="#快速检索" class="headerlink" title="快速检索"></a>快速检索</h4><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h4 id="文件重名的解决"><a href="#文件重名的解决" class="headerlink" title="文件重名的解决"></a>文件重名的解决</h4><h3 id="7-4-3-文件控制块FCB"><a href="#7-4-3-文件控制块FCB" class="headerlink" title="7.4.3.     文件控制块FCB"></a>7.4.3.     文件控制块FCB</h3><h4 id="文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项"><a href="#文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项" class="headerlink" title="文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项"></a>文件存在的标识，文件管理所需的全部信息，保存在文件目录中作为一个目录项</h4><h4 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h4><h5 id="1、基本信息类"><a href="#1、基本信息类" class="headerlink" title="1、基本信息类"></a>1、基本信息类</h5><h5 id="2、存取控制信息类"><a href="#2、存取控制信息类" class="headerlink" title="2、存取控制信息类"></a>2、存取控制信息类</h5><h5 id="3、使用信息类"><a href="#3、使用信息类" class="headerlink" title="3、使用信息类"></a>3、使用信息类</h5><h3 id="7-4-4-索引结点"><a href="#7-4-4-索引结点" class="headerlink" title="7.4.4.     索引结点"></a>7.4.4.     索引结点</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h5 id="文件名和文件描述信息分开存放，将FCB拆分为两部分"><a href="#文件名和文件描述信息分开存放，将FCB拆分为两部分" class="headerlink" title="文件名和文件描述信息分开存放，将FCB拆分为两部分"></a>文件名和文件描述信息分开存放，将FCB拆分为两部分</h5><h5 id="1、文件目录部分"><a href="#1、文件目录部分" class="headerlink" title="1、文件目录部分"></a>1、文件目录部分</h5><h6 id="文件名-索引结点编号（指针）"><a href="#文件名-索引结点编号（指针）" class="headerlink" title="文件名+索引结点编号（指针）"></a>文件名+索引结点编号（指针）</h6><h5 id="2、I结点"><a href="#2、I结点" class="headerlink" title="2、I结点"></a>2、I结点</h5><h6 id="除文件名以外的数据结构"><a href="#除文件名以外的数据结构" class="headerlink" title="除文件名以外的数据结构"></a>除文件名以外的数据结构</h6><h4 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h4><h5 id="指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node"><a href="#指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node" class="headerlink" title="指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node"></a>指存放在磁盘上的I-node，磁盘上每一个文件都有唯一的I-node</h5><h4 id="内存索引结点"><a href="#内存索引结点" class="headerlink" title="内存索引结点"></a>内存索引结点</h4><h5 id="文件打开后，磁盘上的I-node拷贝到内存，以便使用"><a href="#文件打开后，磁盘上的I-node拷贝到内存，以便使用" class="headerlink" title="文件打开后，磁盘上的I-node拷贝到内存，以便使用"></a>文件打开后，磁盘上的I-node拷贝到内存，以便使用</h5><h3 id="7-4-5-目录结构"><a href="#7-4-5-目录结构" class="headerlink" title="7.4.5.     目录结构"></a>7.4.5.     目录结构</h3><h4 id="1、单级目录"><a href="#1、单级目录" class="headerlink" title="1、单级目录"></a>1、单级目录</h4><h4 id="2、两级目录"><a href="#2、两级目录" class="headerlink" title="2、两级目录"></a>2、两级目录</h4><h4 id="3、多级目录（树）"><a href="#3、多级目录（树）" class="headerlink" title="3、多级目录（树）"></a>3、多级目录（树）</h4><h4 id="4、无环图目录"><a href="#4、无环图目录" class="headerlink" title="4、无环图目录"></a>4、无环图目录</h4><h4 id="4、通用图目录"><a href="#4、通用图目录" class="headerlink" title="4、通用图目录"></a>4、通用图目录</h4><h2 id="7-5-文件存储空间管理"><a href="#7-5-文件存储空间管理" class="headerlink" title="7.5.     文件存储空间管理"></a>7.5.     文件存储空间管理</h2><h3 id="7-5-1-要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况"><a href="#7-5-1-要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况" class="headerlink" title="7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况"></a>7.5.1.     要分配给新文件存储空间，就要选数据结构存储空闲空间使用情况</h3><h3 id="7-5-2-方式"><a href="#7-5-2-方式" class="headerlink" title="7.5.2.     方式"></a>7.5.2.     方式</h3><h4 id="1、空闲表法"><a href="#1、空闲表法" class="headerlink" title="1、空闲表法"></a>1、空闲表法</h4><h5 id="首次-下次适应，最佳-最坏"><a href="#首次-下次适应，最佳-最坏" class="headerlink" title="首次/下次适应，最佳/最坏"></a>首次/下次适应，最佳/最坏</h5><h5 id="连续分配（一般），首次适应（算法）"><a href="#连续分配（一般），首次适应（算法）" class="headerlink" title="连续分配（一般），首次适应（算法）"></a>连续分配（一般），首次适应（算法）</h5><h5 id="序号-第一空闲盘块号-空闲盘块数"><a href="#序号-第一空闲盘块号-空闲盘块数" class="headerlink" title="序号+第一空闲盘块号+空闲盘块数"></a>序号+第一空闲盘块号+空闲盘块数</h5><h4 id="2、空闲链表法"><a href="#2、空闲链表法" class="headerlink" title="2、空闲链表法"></a>2、空闲链表法</h4><h5 id="空闲簇有指向下一个空闲簇的指针"><a href="#空闲簇有指向下一个空闲簇的指针" class="headerlink" title="空闲簇有指向下一个空闲簇的指针"></a>空闲簇有指向下一个空闲簇的指针</h5><h5 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h5><h6 id="空闲簇链接"><a href="#空闲簇链接" class="headerlink" title="空闲簇链接"></a>空闲簇链接</h6><h6 id="空闲区链接"><a href="#空闲区链接" class="headerlink" title="空闲区链接"></a>空闲区链接</h6><p>除指向下一个指针，还指明本盘区大小</p>
<h4 id="3、位示图"><a href="#3、位示图" class="headerlink" title="3、位示图"></a>3、位示图</h4><h5 id="每一位表示一个簇，0和1表示空闲和占用"><a href="#每一位表示一个簇，0和1表示空闲和占用" class="headerlink" title="每一位表示一个簇，0和1表示空闲和占用"></a>每一位表示一个簇，0和1表示空闲和占用</h5><h4 id="4、成组链接法"><a href="#4、成组链接法" class="headerlink" title="4、成组链接法"></a>4、成组链接法</h4><h5 id="栈底放盘块数"><a href="#栈底放盘块数" class="headerlink" title="栈底放盘块数"></a>栈底放盘块数</h5><h5 id="栈底上面一个存放一组空闲盘块"><a href="#栈底上面一个存放一组空闲盘块" class="headerlink" title="栈底上面一个存放一组空闲盘块"></a>栈底上面一个存放一组空闲盘块</h5><h2 id="7-6-文件共享"><a href="#7-6-文件共享" class="headerlink" title="7.6.     文件共享"></a>7.6.     文件共享</h2><h3 id="7-6-1-1、硬链接"><a href="#7-6-1-1、硬链接" class="headerlink" title="7.6.1.     1、硬链接"></a>7.6.1.     1、硬链接</h3><h4 id="文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针"><a href="#文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针" class="headerlink" title="文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针"></a>文件物理地址和其他属性信息不放在文件目录中，而是放在索引结点中，目录中设置指向相应索引结点的指针</h4><h3 id="7-6-2-2、符号链接"><a href="#7-6-2-2、符号链接" class="headerlink" title="7.6.2.     2、符号链接"></a>7.6.2.     2、符号链接</h3><h2 id="7-7-文件保护"><a href="#7-7-文件保护" class="headerlink" title="7.7.     文件保护"></a>7.7.     文件保护</h2><h3 id="7-7-1-1、文件不受物理损坏-2、避免文件被非法访问"><a href="#7-7-1-1、文件不受物理损坏-2、避免文件被非法访问" class="headerlink" title="7.7.1.     1、文件不受物理损坏/2、避免文件被非法访问"></a>7.7.1.     1、文件不受物理损坏/2、避免文件被非法访问</h3><h3 id="7-7-2-常用方法"><a href="#7-7-2-常用方法" class="headerlink" title="7.7.2.     常用方法:"></a>7.7.2.     常用方法:</h3><h4 id="根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问"><a href="#根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问" class="headerlink" title="根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问"></a>根据用户身份进行文件的访问控制，每个文件增加一个访问控制列表ACL，当用户请求访问时，OS检查ACL决定是否允许访问</h4><h4 id="ACL方法的缺点"><a href="#ACL方法的缺点" class="headerlink" title="ACL方法的缺点"></a>ACL方法的缺点</h4><h5 id="每个文件ACL过长，事先无法知道系统用户的列表"><a href="#每个文件ACL过长，事先无法知道系统用户的列表" class="headerlink" title="每个文件ACL过长，事先无法知道系统用户的列表"></a>每个文件ACL过长，事先无法知道系统用户的列表</h5><h5 id="原来固定大小的文件目录条目，现在必须可变，空间管理复杂化"><a href="#原来固定大小的文件目录条目，现在必须可变，空间管理复杂化" class="headerlink" title="原来固定大小的文件目录条目，现在必须可变，空间管理复杂化"></a>原来固定大小的文件目录条目，现在必须可变，空间管理复杂化</h5><h4 id="精简ACL的方法"><a href="#精简ACL的方法" class="headerlink" title="精简ACL的方法"></a>精简ACL的方法</h4><h5 id="每个文件三种类型用户"><a href="#每个文件三种类型用户" class="headerlink" title="每个文件三种类型用户"></a>每个文件三种类型用户</h5><h6 id="拥有者：创建文件的用户"><a href="#拥有者：创建文件的用户" class="headerlink" title="拥有者：创建文件的用户"></a>拥有者：创建文件的用户</h6><h6 id="组：可访问者"><a href="#组：可访问者" class="headerlink" title="组：可访问者"></a>组：可访问者</h6><h6 id="其他用户"><a href="#其他用户" class="headerlink" title="其他用户"></a>其他用户</h6>]]></content>
      <categories>
        <category>基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
